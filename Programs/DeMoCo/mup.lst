680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 10 Apr 2024      Time: 00:50:14          Source: D:\CPEN412\M68K\PROGRAMS\DEMOCO\MUP.SRC

                       1          section   code
                       2   **********************************************************************************************************
                       3   * CSTART.ASM  -  C startup-code
                       4   *
                       5   *          Initialises the system prior to running the users main() program
                       6   *
                       7   *          1) Sets up the user program stack pointer
                       8   *          2) Switches to User mode in the 68000
                       9   *          3) Enables All Interrupts 1-7 on 68000
                      10   *          4) Copies all initialised C program variables from Rom to Ram prior to running main()
                      11   *
                      12   **********************************************************************************************************
00000000              13                   align
                      14   
                      15   
                      16   **********************************************************************************************************
                      17   * The Following ORG Statement marks the address of the start of the this CStart Program
                      18   *
                      19   * The debug Monitor and Flash Load and Program routines assume your program lives here
                      20   **********************************************************************************************************
0B000000              21                   org       $0B000000
0B000000  46FC 2000   22   start:          move.w    #$2000,SR             clear interrupts to enable all, move to supervisor mode
                      23   
                      24   ******************************************************************************************
                      25   * Set unitialised global variables to 0 at startup
                      26   ******************************************************************************************
0B000004  207C 0B00   27   mainloop        movea.l   #BssStart,a0          point a0 to the start of the initialised data section held in ROM
0B000008  1D34      
0B00000A  203C 0000   28                   move.l    #BssLength,d0         figure out how many bytes of C program variables data to copy
0B00000E  001C      
0B000010  6700 0024   29                   beq       go_main               if no data to copy go straight to program
0B000014  10FC 0000   30   Zeroinit        move.b    #0,(a0)+              copy the C program initialise variables from rom to ram
0B000018  5380        31                   subq.l    #1,d0
0B00001A  66F8        32                   bne       Zeroinit
                      33   
                      34   *******************************************************************************************
                      35   * last minute initialisation before calling main
                      36   *******************************************************************************************
                      37   
0B00001C  23FC FFFF   38                   move.l    #-1,__ungetbuf         required for use of scanf() etc in C programs
0B000020  FFFF 0B00 
0B000024  1D1C      
0B000026  42B9 0B00   39                   clr.l     __allocp               used by malloc() in C
0B00002A  1D20      
0B00002C  23FC 0B00   40                   move.l    #heap,__heap           pointer to free memory
0B000030  1D50 0B00 
0B000034  1D24      
0B000036  4EB9 0B00   41   go_main         jsr       _main
0B00003A  0EFE      
0B00003C  60C2        42                   bra       start
                      43   
                      44   ; D:\CPEN412\M68K\PROGRAMS\DEMOCO\MUP.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                      45   ; #include <stdio.h>
                      46   ; #include <string.h>
                      47   ; #include <ctype.h>
                      48   ; //IMPORTANT
                      49   ; //
                      50   ; // Uncomment one of the two #defines below
                      51   ; // Define StartOfExceptionVectorTable as 08030000 if running programs from sram or
                      52   ; // 0B000000 for running programs from dram
                      53   ; //
                      54   ; // In your labs, you will initially start by designing a system with SRam and later move to
                      55   ; // Dram, so these constants will need to be changed based on the version of the system you have
                      56   ; // building
                      57   ; //
                      58   ; // The working 68k system SOF file posted on canvas that you can use for your pre-lab
                      59   ; // is based around Dram so #define accordingly before building
                      60   ; //#define StartOfExceptionVectorTable 0x08030000
                      61   ; #define StartOfExceptionVectorTable 0x0B000000
                      62   ; /**********************************************************************************************
                      63   ; **	Parallel port addresses
                      64   ; **********************************************************************************************/
                      65   ; #define PortA   *(volatile unsigned char *)(0x00400000)
                      66   ; #define PortB   *(volatile unsigned char *)(0x00400002)
                      67   ; #define PortC   *(volatile unsigned char *)(0x00400004)
                      68   ; #define PortD   *(volatile unsigned char *)(0x00400006)
                      69   ; #define PortE   *(volatile unsigned char *)(0x00400008)
                      70   ; /*********************************************************************************************
                      71   ; **	Hex 7 seg displays port addresses
                      72   ; *********************************************************************************************/
                      73   ; #define HEX_A        *(volatile unsigned char *)(0x00400010)
                      74   ; #define HEX_B        *(volatile unsigned char *)(0x00400012)
                      75   ; #define HEX_C        *(volatile unsigned char *)(0x00400014)    // de2 only
                      76   ; #define HEX_D        *(volatile unsigned char *)(0x00400016)    // de2 only
                      77   ; /**********************************************************************************************
                      78   ; **	LCD display port addresses
                      79   ; **********************************************************************************************/
                      80   ; #define LCDcommand   *(volatile unsigned char *)(0x00400020)
                      81   ; #define LCDdata      *(volatile unsigned char *)(0x00400022)
                      82   ; /********************************************************************************************
                      83   ; **	Timer Port addresses
                      84   ; *********************************************************************************************/
                      85   ; #define Timer1Data      *(volatile unsigned char *)(0x00400030)
                      86   ; #define Timer1Control   *(volatile unsigned char *)(0x00400032)
                      87   ; #define Timer1Status    *(volatile unsigned char *)(0x00400032)
                      88   ; #define Timer2Data      *(volatile unsigned char *)(0x00400034)
                      89   ; #define Timer2Control   *(volatile unsigned char *)(0x00400036)
                      90   ; #define Timer2Status    *(volatile unsigned char *)(0x00400036)
                      91   ; #define Timer3Data      *(volatile unsigned char *)(0x00400038)
                      92   ; #define Timer3Control   *(volatile unsigned char *)(0x0040003A)
                      93   ; #define Timer3Status    *(volatile unsigned char *)(0x0040003A)
                      94   ; #define Timer4Data      *(volatile unsigned char *)(0x0040003C)
                      95   ; #define Timer4Control   *(volatile unsigned char *)(0x0040003E)
                      96   ; #define Timer4Status    *(volatile unsigned char *)(0x0040003E)
                      97   ; /*********************************************************************************************
                      98   ; **	RS232 port addresses
                      99   ; *********************************************************************************************/
                     100   ; #define RS232_Control     *(volatile unsigned char *)(0x00400040)
                     101   ; #define RS232_Status      *(volatile unsigned char *)(0x00400040)
                     102   ; #define RS232_TxData      *(volatile unsigned char *)(0x00400042)
                     103   ; #define RS232_RxData      *(volatile unsigned char *)(0x00400042)
                     104   ; #define RS232_Baud        *(volatile unsigned char *)(0x00400044)
                     105   ; /*********************************************************************************************
                     106   ; **	PIA 1 and 2 port addresses
                     107   ; *********************************************************************************************/
                     108   ; #define PIA1_PortA_Data     *(volatile unsigned char *)(0x00400050)         // combined data and data direction register share same address
                     109   ; #define PIA1_PortA_Control *(volatile unsigned char *)(0x00400052)
                     110   ; #define PIA1_PortB_Data     *(volatile unsigned char *)(0x00400054)         // combined data and data direction register share same address
                     111   ; #define PIA1_PortB_Control *(volatile unsigned char *)(0x00400056)
                     112   ; #define PIA2_PortA_Data     *(volatile unsigned char *)(0x00400060)         // combined data and data direction register share same address
                     113   ; #define PIA2_PortA_Control *(volatile unsigned char *)(0x00400062)
                     114   ; #define PIA2_PortB_data     *(volatile unsigned char *)(0x00400064)         // combined data and data direction register share same address
                     115   ; #define PIA2_PortB_Control *(volatile unsigned char *)(0x00400066)
                     116   ; //////////////////////////////
                     117   ; // I2C Controller Registers //
                     118   ; //////////////////////////////
                     119   ; #define I2C_CLK_PRESCALE_LOW (*(volatile unsigned char *)(0x00408000))
                     120   ; #define I2C_CLK_PRESCALE_HIGH (*(volatile unsigned char *)(0x00408002))
                     121   ; #define I2C_CTRL (*(volatile unsigned char *)(0x00408004))
                     122   ; #define I2C_TX (*(volatile unsigned char *)(0x00408006))
                     123   ; #define I2C_RX (*(volatile unsigned char *)(0x00408006))
                     124   ; #define I2C_CMD (*(volatile unsigned char *)(0x00408008))
                     125   ; #define I2C_STAT (*(volatile unsigned char *)(0x00408008))
                     126   ; //////////////////
                     127   ; // I2C Commands //
                     128   ; //////////////////
                     129   ; #define I2C_CMD_Slave_Write_With_Start 0x91 // 1001 0001
                     130   ; #define I2C_CMD_Slave_Read_With_Start 0xA9  // 1010 1001
                     131   ; #define I2C_CMD_Slave_Write 0x11            // 0001 0001
                     132   ; #define I2C_CMD_Slave_Read 0x21             // 0010 0001
                     133   ; #define I2C_CMD_Slave_Read_Ack 0x29         // 0010 1001
                     134   ; #define I2C_CMD_Slave_Write_Stop 0x51       // 0101 0001
                     135   ; #define I2C_CMD_Slave_Read_Stop 0x49        // 0100 1001
                     136   ; /////////////////////
                     137   ; // EEPROM Commands //
                     138   ; /////////////////////
                     139   ; #define EEPROM_Write_Block_1 0xA2           // 1010 0010
                     140   ; #define EEPROM_Read_Block_1 0xA3            // 1010 0011
                     141   ; #define EEPROM_Write_Block_0 0xA0           // 1010 0000
                     142   ; #define EEPROM_Read_Block_0 0xA1            // 1010 0001
                     143   ; //////////////////////
                     144   ; // ADC/DAC Commands //
                     145   ; //////////////////////
                     146   ; #define ADC_DAC_Write_Address 0x90          // 1001 0000
                     147   ; #define ADC_Read_Address 0x91               // 1001 0001
                     148   ; #define ADC_CMD_Enable 0x44                 // 0100 0100
                     149   ; #define DAC_CMD_Enable 0x40                 // 0100 0000
                     150   ; #define Enable_I2C_Controller() I2C_CTRL = 0x80     // 1000 0000
                     151   ; /*********************************************************************************************
                     152   ; ** These addresses and definitions were taken from Appendix 7 of the Can Controller
                     153   ; ** application note and adapted for the 68k assignment
                     154   ; *********************************************************************************************/
                     155   ; /*
                     156   ; ** definition for the SJA1000 registers and bits based on 68k address map areas
                     157   ; ** assume the addresses for the 2 can controllers given in the assignment
                     158   ; **
                     159   ; ** Registers are defined in terms of the following Macro for each Can controller,
                     160   ; ** where (i) represents an registers number
                     161   ; */
                     162   ; #define CAN0_CONTROLLER(i) (*(volatile unsigned char *)(0x00500000 + (i << 1)))
                     163   ; #define CAN1_CONTROLLER(i) (*(volatile unsigned char *)(0x00500200 + (i << 1)))
                     164   ; /* Can 0 register definitions */
                     165   ; #define Can0_ModeControlReg      CAN0_CONTROLLER(0)
                     166   ; #define Can0_CommandReg          CAN0_CONTROLLER(1)
                     167   ; #define Can0_StatusReg           CAN0_CONTROLLER(2)
                     168   ; #define Can0_InterruptReg        CAN0_CONTROLLER(3)
                     169   ; #define Can0_InterruptEnReg      CAN0_CONTROLLER(4) /* PeliCAN mode */
                     170   ; #define Can0_BusTiming0Reg       CAN0_CONTROLLER(6)
                     171   ; #define Can0_BusTiming1Reg       CAN0_CONTROLLER(7)
                     172   ; #define Can0_OutControlReg       CAN0_CONTROLLER(8)
                     173   ; /* address definitions of Other Registers */
                     174   ; #define Can0_ArbLostCapReg       CAN0_CONTROLLER(11)
                     175   ; #define Can0_ErrCodeCapReg       CAN0_CONTROLLER(12)
                     176   ; #define Can0_ErrWarnLimitReg     CAN0_CONTROLLER(13)
                     177   ; #define Can0_RxErrCountReg       CAN0_CONTROLLER(14)
                     178   ; #define Can0_TxErrCountReg       CAN0_CONTROLLER(15)
                     179   ; #define Can0_RxMsgCountReg       CAN0_CONTROLLER(29)
                     180   ; #define Can0_RxBufStartAdr       CAN0_CONTROLLER(30)
                     181   ; #define Can0_ClockDivideReg      CAN0_CONTROLLER(31)
                     182   ; /* address definitions of Acceptance Code & Mask Registers - RESET MODE */
                     183   ; #define Can0_AcceptCode0Reg      CAN0_CONTROLLER(16)
                     184   ; #define Can0_AcceptCode1Reg      CAN0_CONTROLLER(17)
                     185   ; #define Can0_AcceptCode2Reg      CAN0_CONTROLLER(18)
                     186   ; #define Can0_AcceptCode3Reg      CAN0_CONTROLLER(19)
                     187   ; #define Can0_AcceptMask0Reg      CAN0_CONTROLLER(20)
                     188   ; #define Can0_AcceptMask1Reg      CAN0_CONTROLLER(21)
                     189   ; #define Can0_AcceptMask2Reg      CAN0_CONTROLLER(22)
                     190   ; #define Can0_AcceptMask3Reg      CAN0_CONTROLLER(23)
                     191   ; /* address definitions Rx Buffer - OPERATING MODE - Read only register*/
                     192   ; #define Can0_RxFrameInfo         CAN0_CONTROLLER(16)
                     193   ; #define Can0_RxBuffer1           CAN0_CONTROLLER(17)
                     194   ; #define Can0_RxBuffer2           CAN0_CONTROLLER(18)
                     195   ; #define Can0_RxBuffer3           CAN0_CONTROLLER(19)
                     196   ; #define Can0_RxBuffer4           CAN0_CONTROLLER(20)
                     197   ; #define Can0_RxBuffer5           CAN0_CONTROLLER(21)
                     198   ; #define Can0_RxBuffer6           CAN0_CONTROLLER(22)
                     199   ; #define Can0_RxBuffer7           CAN0_CONTROLLER(23)
                     200   ; #define Can0_RxBuffer8           CAN0_CONTROLLER(24)
                     201   ; #define Can0_RxBuffer9           CAN0_CONTROLLER(25)
                     202   ; #define Can0_RxBuffer10          CAN0_CONTROLLER(26)
                     203   ; #define Can0_RxBuffer11          CAN0_CONTROLLER(27)
                     204   ; #define Can0_RxBuffer12          CAN0_CONTROLLER(28)
                     205   ; /* address definitions of the Tx-Buffer - OPERATING MODE - Write only register */
                     206   ; #define Can0_TxFrameInfo         CAN0_CONTROLLER(16)
                     207   ; #define Can0_TxBuffer1           CAN0_CONTROLLER(17)
                     208   ; #define Can0_TxBuffer2           CAN0_CONTROLLER(18)
                     209   ; #define Can0_TxBuffer3           CAN0_CONTROLLER(19)
                     210   ; #define Can0_TxBuffer4           CAN0_CONTROLLER(20)
                     211   ; #define Can0_TxBuffer5           CAN0_CONTROLLER(21)
                     212   ; #define Can0_TxBuffer6           CAN0_CONTROLLER(22)
                     213   ; #define Can0_TxBuffer7           CAN0_CONTROLLER(23)
                     214   ; #define Can0_TxBuffer8           CAN0_CONTROLLER(24)
                     215   ; #define Can0_TxBuffer9           CAN0_CONTROLLER(25)
                     216   ; #define Can0_TxBuffer10          CAN0_CONTROLLER(26)
                     217   ; #define Can0_TxBuffer11          CAN0_CONTROLLER(27)
                     218   ; #define Can0_TxBuffer12          CAN0_CONTROLLER(28)
                     219   ; /* read only addresses */
                     220   ; #define Can0_TxFrameInfoRd       CAN0_CONTROLLER(96)
                     221   ; #define Can0_TxBufferRd1         CAN0_CONTROLLER(97)
                     222   ; #define Can0_TxBufferRd2         CAN0_CONTROLLER(98)
                     223   ; #define Can0_TxBufferRd3         CAN0_CONTROLLER(99)
                     224   ; #define Can0_TxBufferRd4         CAN0_CONTROLLER(100)
                     225   ; #define Can0_TxBufferRd5         CAN0_CONTROLLER(101)
                     226   ; #define Can0_TxBufferRd6         CAN0_CONTROLLER(102)
                     227   ; #define Can0_TxBufferRd7         CAN0_CONTROLLER(103)
                     228   ; #define Can0_TxBufferRd8         CAN0_CONTROLLER(104)
                     229   ; #define Can0_TxBufferRd9         CAN0_CONTROLLER(105)
                     230   ; #define Can0_TxBufferRd10        CAN0_CONTROLLER(106)
                     231   ; #define Can0_TxBufferRd11        CAN0_CONTROLLER(107)
                     232   ; #define Can0_TxBufferRd12        CAN0_CONTROLLER(108)
                     233   ; /* CAN1 Controller register definitions */
                     234   ; #define Can1_ModeControlReg      CAN1_CONTROLLER(0)
                     235   ; #define Can1_CommandReg          CAN1_CONTROLLER(1)
                     236   ; #define Can1_StatusReg           CAN1_CONTROLLER(2)
                     237   ; #define Can1_InterruptReg        CAN1_CONTROLLER(3)
                     238   ; #define Can1_InterruptEnReg      CAN1_CONTROLLER(4) /* PeliCAN mode */
                     239   ; #define Can1_BusTiming0Reg       CAN1_CONTROLLER(6)
                     240   ; #define Can1_BusTiming1Reg       CAN1_CONTROLLER(7)
                     241   ; #define Can1_OutControlReg       CAN1_CONTROLLER(8)
                     242   ; /* address definitions of Other Registers */
                     243   ; #define Can1_ArbLostCapReg       CAN1_CONTROLLER(11)
                     244   ; #define Can1_ErrCodeCapReg       CAN1_CONTROLLER(12)
                     245   ; #define Can1_ErrWarnLimitReg     CAN1_CONTROLLER(13)
                     246   ; #define Can1_RxErrCountReg       CAN1_CONTROLLER(14)
                     247   ; #define Can1_TxErrCountReg       CAN1_CONTROLLER(15)
                     248   ; #define Can1_RxMsgCountReg       CAN1_CONTROLLER(29)
                     249   ; #define Can1_RxBufStartAdr       CAN1_CONTROLLER(30)
                     250   ; #define Can1_ClockDivideReg      CAN1_CONTROLLER(31)
                     251   ; /* address definitions of Acceptance Code & Mask Registers - RESET MODE */
                     252   ; #define Can1_AcceptCode0Reg      CAN1_CONTROLLER(16)
                     253   ; #define Can1_AcceptCode1Reg      CAN1_CONTROLLER(17)
                     254   ; #define Can1_AcceptCode2Reg      CAN1_CONTROLLER(18)
                     255   ; #define Can1_AcceptCode3Reg      CAN1_CONTROLLER(19)
                     256   ; #define Can1_AcceptMask0Reg      CAN1_CONTROLLER(20)
                     257   ; #define Can1_AcceptMask1Reg      CAN1_CONTROLLER(21)
                     258   ; #define Can1_AcceptMask2Reg      CAN1_CONTROLLER(22)
                     259   ; #define Can1_AcceptMask3Reg      CAN1_CONTROLLER(23)
                     260   ; /* address definitions Rx Buffer - OPERATING MODE - Read only register*/
                     261   ; #define Can1_RxFrameInfo         CAN1_CONTROLLER(16)
                     262   ; #define Can1_RxBuffer1           CAN1_CONTROLLER(17)
                     263   ; #define Can1_RxBuffer2           CAN1_CONTROLLER(18)
                     264   ; #define Can1_RxBuffer3           CAN1_CONTROLLER(19)
                     265   ; #define Can1_RxBuffer4           CAN1_CONTROLLER(20)
                     266   ; #define Can1_RxBuffer5           CAN1_CONTROLLER(21)
                     267   ; #define Can1_RxBuffer6           CAN1_CONTROLLER(22)
                     268   ; #define Can1_RxBuffer7           CAN1_CONTROLLER(23)
                     269   ; #define Can1_RxBuffer8           CAN1_CONTROLLER(24)
                     270   ; #define Can1_RxBuffer9           CAN1_CONTROLLER(25)
                     271   ; #define Can1_RxBuffer10          CAN1_CONTROLLER(26)
                     272   ; #define Can1_RxBuffer11          CAN1_CONTROLLER(27)
                     273   ; #define Can1_RxBuffer12          CAN1_CONTROLLER(28)
                     274   ; /* address definitions of the Tx-Buffer - OPERATING MODE - Write only register */
                     275   ; #define Can1_TxFrameInfo         CAN1_CONTROLLER(16)
                     276   ; #define Can1_TxBuffer1           CAN1_CONTROLLER(17)
                     277   ; #define Can1_TxBuffer2           CAN1_CONTROLLER(18)
                     278   ; #define Can1_TxBuffer3           CAN1_CONTROLLER(19)
                     279   ; #define Can1_TxBuffer4           CAN1_CONTROLLER(20)
                     280   ; #define Can1_TxBuffer5           CAN1_CONTROLLER(21)
                     281   ; #define Can1_TxBuffer6           CAN1_CONTROLLER(22)
                     282   ; #define Can1_TxBuffer7           CAN1_CONTROLLER(23)
                     283   ; #define Can1_TxBuffer8           CAN1_CONTROLLER(24)
                     284   ; #define Can1_TxBuffer9           CAN1_CONTROLLER(25)
                     285   ; #define Can1_TxBuffer10          CAN1_CONTROLLER(26)
                     286   ; #define Can1_TxBuffer11          CAN1_CONTROLLER(27)
                     287   ; #define Can1_TxBuffer12          CAN1_CONTROLLER(28)
                     288   ; /* read only addresses */
                     289   ; #define Can1_TxFrameInfoRd       CAN1_CONTROLLER(96)
                     290   ; #define Can1_TxBufferRd1         CAN1_CONTROLLER(97)
                     291   ; #define Can1_TxBufferRd2         CAN1_CONTROLLER(98)
                     292   ; #define Can1_TxBufferRd3         CAN1_CONTROLLER(99)
                     293   ; #define Can1_TxBufferRd4         CAN1_CONTROLLER(100)
                     294   ; #define Can1_TxBufferRd5         CAN1_CONTROLLER(101)
                     295   ; #define Can1_TxBufferRd6         CAN1_CONTROLLER(102)
                     296   ; #define Can1_TxBufferRd7         CAN1_CONTROLLER(103)
                     297   ; #define Can1_TxBufferRd8         CAN1_CONTROLLER(104)
                     298   ; #define Can1_TxBufferRd9         CAN1_CONTROLLER(105)
                     299   ; #define Can1_TxBufferRd10        CAN1_CONTROLLER(106)
                     300   ; #define Can1_TxBufferRd11        CAN1_CONTROLLER(107)
                     301   ; #define Can1_TxBufferRd12        CAN1_CONTROLLER(108)
                     302   ; /* bit definitions for the Mode & Control Register */
                     303   ; #define RM_RR_Bit 0x01 /* reset mode (request) bit */
                     304   ; #define LOM_Bit 0x02 /* listen only mode bit */
                     305   ; #define STM_Bit 0x04 /* self test mode bit */
                     306   ; #define AFM_Bit 0x08 /* acceptance filter mode bit */
                     307   ; #define SM_Bit  0x10 /* enter sleep mode bit */
                     308   ; /* bit definitions for the Interrupt Enable & Control Register */
                     309   ; #define RIE_Bit 0x01 /* receive interrupt enable bit */
                     310   ; #define TIE_Bit 0x02 /* transmit interrupt enable bit */
                     311   ; #define EIE_Bit 0x04 /* error warning interrupt enable bit */
                     312   ; #define DOIE_Bit 0x08 /* data overrun interrupt enable bit */
                     313   ; #define WUIE_Bit 0x10 /* wake-up interrupt enable bit */
                     314   ; #define EPIE_Bit 0x20 /* error passive interrupt enable bit */
                     315   ; #define ALIE_Bit 0x40 /* arbitration lost interr. enable bit*/
                     316   ; #define BEIE_Bit 0x80 /* bus error interrupt enable bit */
                     317   ; /* bit definitions for the Command Register */
                     318   ; #define TR_Bit 0x01 /* transmission request bit */
                     319   ; #define AT_Bit 0x02 /* abort transmission bit */
                     320   ; #define RRB_Bit 0x04 /* release receive buffer bit */
                     321   ; #define CDO_Bit 0x08 /* clear data overrun bit */
                     322   ; #define SRR_Bit 0x10 /* self reception request bit */
                     323   ; /* bit definitions for the Status Register */
                     324   ; #define RBS_Bit 0x01 /* receive buffer status bit */
                     325   ; #define DOS_Bit 0x02 /* data overrun status bit */
                     326   ; #define TBS_Bit 0x04 /* transmit buffer status bit */
                     327   ; #define TCS_Bit 0x08 /* transmission complete status bit */
                     328   ; #define RS_Bit 0x10 /* receive status bit */
                     329   ; #define TS_Bit 0x20 /* transmit status bit */
                     330   ; #define ES_Bit 0x40 /* error status bit */
                     331   ; #define BS_Bit 0x80 /* bus status bit */
                     332   ; /* bit definitions for the Interrupt Register */
                     333   ; #define RI_Bit 0x01 /* receive interrupt bit */
                     334   ; #define TI_Bit 0x02 /* transmit interrupt bit */
                     335   ; #define EI_Bit 0x04 /* error warning interrupt bit */
                     336   ; #define DOI_Bit 0x08 /* data overrun interrupt bit */
                     337   ; #define WUI_Bit 0x10 /* wake-up interrupt bit */
                     338   ; #define EPI_Bit 0x20 /* error passive interrupt bit */
                     339   ; #define ALI_Bit 0x40 /* arbitration lost interrupt bit */
                     340   ; #define BEI_Bit 0x80 /* bus error interrupt bit */
                     341   ; /* bit definitions for the Bus Timing Registers */
                     342   ; #define SAM_Bit 0x80                        /* sample mode bit 1 == the bus is sampled 3 times, 0 == the bus is sampled once */
                     343   ; /* bit definitions for the Output Control Register OCMODE1, OCMODE0 */
                     344   ; #define BiPhaseMode 0x00 /* bi-phase output mode */
                     345   ; #define NormalMode 0x02 /* normal output mode */
                     346   ; #define ClkOutMode 0x03 /* clock output mode */
                     347   ; /* output pin configuration for TX1 */
                     348   ; #define OCPOL1_Bit 0x20 /* output polarity control bit */
                     349   ; #define Tx1Float 0x00 /* configured as float */
                     350   ; #define Tx1PullDn 0x40 /* configured as pull-down */
                     351   ; #define Tx1PullUp 0x80 /* configured as pull-up */
                     352   ; #define Tx1PshPull 0xC0 /* configured as push/pull */
                     353   ; /* output pin configuration for TX0 */
                     354   ; #define OCPOL0_Bit 0x04 /* output polarity control bit */
                     355   ; #define Tx0Float 0x00 /* configured as float */
                     356   ; #define Tx0PullDn 0x08 /* configured as pull-down */
                     357   ; #define Tx0PullUp 0x10 /* configured as pull-up */
                     358   ; #define Tx0PshPull 0x18 /* configured as push/pull */
                     359   ; /* bit definitions for the Clock Divider Register */
                     360   ; #define DivBy1 0x07 /* CLKOUT = oscillator frequency */
                     361   ; #define DivBy2 0x00 /* CLKOUT = 1/2 oscillator frequency */
                     362   ; #define ClkOff_Bit 0x08 /* clock off bit, control of the CLK OUT pin */
                     363   ; #define RXINTEN_Bit 0x20 /* pin TX1 used for receive interrupt */
                     364   ; #define CBP_Bit 0x40 /* CAN comparator bypass control bit */
                     365   ; #define CANMode_Bit 0x80 /* CAN mode definition bit */
                     366   ; /*- definition of used constants ---------------------------------------*/
                     367   ; #define YES 1
                     368   ; #define NO 0
                     369   ; #define ENABLE 1
                     370   ; #define DISABLE 0
                     371   ; #define ENABLE_N 0
                     372   ; #define DISABLE_N 1
                     373   ; #define INTLEVELACT 0
                     374   ; #define INTEDGEACT 1
                     375   ; #define PRIORITY_LOW 0
                     376   ; #define PRIORITY_HIGH 1
                     377   ; /* default (reset) value for register content, clear register */
                     378   ; #define ClrByte 0x00
                     379   ; /* constant: clear Interrupt Enable Register */
                     380   ; #define ClrIntEnSJA ClrByte
                     381   ; /* definitions for the acceptance code and mask register */
                     382   ; #define DontCare 0xFF
                     383   ; /*  bus timing values for
                     384   ; **  bit-rate : 100 kBit/s
                     385   ; **  oscillator frequency : 25 MHz, 1 sample per bit, 0 tolerance %
                     386   ; **  maximum tolerated propagation delay : 4450 ns
                     387   ; **  minimum requested propagation delay : 500 ns
                     388   ; **
                     389   ; **  https://www.kvaser.com/support/calculators/bit-timing-calculator/
                     390   ; **  T1 	T2 	BTQ 	SP% 	SJW 	BIT RATE 	ERR% 	BTR0 	BTR1
                     391   ; **  17	8	25	    68	     1	      100	    0	      04	7f
                     392   ; */
                     393   ; #define BTR0 0x04
                     394   ; #define BTR1 0x7f
                     395   ; /*********************************************************************************************************************************
                     396   ; (( DO NOT initialise global variables here, do it main even if you want 0
                     397   ; (( it's a limitation of the compiler
                     398   ; (( YOU HAVE BEEN WARNED
                     399   ; *********************************************************************************************************************************/
                     400   ; unsigned int i, x, y, z, PortA_Count;
                     401   ; unsigned char Timer1Count, Timer2Count, Timer3Count, Timer4Count ;
                     402   ; /*******************************************************************************************
                     403   ; ** Function Prototypes
                     404   ; *******************************************************************************************/
                     405   ; void Wait1ms(void);
                     406   ; void Wait3ms(void);
                     407   ; void Init_LCD(void) ;
                     408   ; void LCDOutchar(int c);
                     409   ; void LCDOutMess(char *theMessage);
                     410   ; void LCDClearln(void);
                     411   ; void LCDline1Message(char *theMessage);
                     412   ; void LCDline2Message(char *theMessage);
                     413   ; int sprintf(char *out, const char *format, ...) ;
                     414   ; // initialisation for Can controller 0
                     415   ; void Init_CanBus_Controller0(void);
                     416   ; // initialisation for Can controller 1
                     417   ; void Init_CanBus_Controller1(void);
                     418   ; // Transmit for sending a message via Can controller 0
                     419   ; void CanBus0_Transmit(int id, char data);
                     420   ; // Transmit for sending a message via Can controller 1
                     421   ; void CanBus1_Transmit(int id, char data);
                     422   ; // Receive for reading a received message via Can controller 0
                     423   ; void CanBus0_Receive(void);
                     424   ; // Receive for reading a received message via Can controller 1
                     425   ; void CanBus1_Receive(void);
                     426   ; void CanBusTest(void);
                     427   ; // I2C prototypes
                     428   ; void I2C_Init(void);
                     429   ; void WriteI2CInteraction(int block, unsigned int Address, unsigned char AddressMSB, unsigned char AddressLSB, unsigned char data, int flag);
                     430   ; void PageWriteI2CInteraction(unsigned int AddressFrom, unsigned int AddressTo, unsigned char data);
                     431   ; void ReadI2CByteInteraction(int block, unsigned int Address, unsigned char AddressMSB, unsigned char AddressLSB);
                     432   ; void ReadI2CSequential(int block, int AddressTo, int AddressFrom,  unsigned int ChipAddress);
                     433   ; void DACWrite(void);
                     434   ; char ADCRead(int);
                     435   ; void WriteI2C(void);
                     436   ; void ReadI2C(void);
                     437   ; void PageWriteI2C(void);
                     438   ; void SeqReadI2C(void);
                     439   ; /*****************************************************************************************
                     440   ; **	Interrupt service routine for Timers
                     441   ; **
                     442   ; **  Timers 1 - 4 share a common IRQ on the CPU  so this function uses polling to figure
                     443   ; **  out which timer is producing the interrupt
                     444   ; **
                     445   ; *****************************************************************************************/
                     446   ; void Timer_ISR()
                     447   ; {
                     448   _Timer_ISR:
0B00003E  48E7 0030  449          movem.l   A2/A3,-(A7)
0B000042  45F9 0B00  450          lea       _CanBus0_Transmit.L,A2
0B000046  0CC2      
0B000048  47F9 0B00  451          lea       _ADCRead.L,A3
0B00004C  0A5A      
                     452   ; if(Timer1Status == 1) {         // Did Timer 1 produce the Interrupt?
0B00004E  1039 0040  453          move.b    4194354,D0
0B000052  0032      
0B000054  0C00 0001  454          cmp.b     #1,D0
0B000058  6600 00B8  455          bne       Timer_ISR_1
                     456   ; CanBus0_Transmit(0, PortA); // every 100ms
0B00005C  1239 0040  457          move.b    4194304,D1
0B000060  0000      
0B000062  4881       458          ext.w     D1
0B000064  48C1       459          ext.l     D1
0B000066  2F01       460          move.l    D1,-(A7)
0B000068  42A7       461          clr.l     -(A7)
0B00006A  4E92       462          jsr       (A2)
0B00006C  504F       463          addq.w    #8,A7
                     464   ; if (Timer1Count % 2 == 0) {
0B00006E  1039 0B00  465          move.b    _Timer1Count.L,D0
0B000072  1D48      
0B000074  C0BC 0000  466          and.l     #65535,D0
0B000078  FFFF      
0B00007A  80FC 0002  467          divu.w    #2,D0
0B00007E  4840       468          swap      D0
0B000080  4A00       469          tst.b     D0
0B000082  661C       470          bne.s     Timer_ISR_3
                     471   ; CanBus0_Transmit(1, ADCRead(1)); // read the value of the ADC potentiometer(from Lab 5) every 200ms
0B000084  2F00       472          move.l    D0,-(A7)
0B000086  4878 0001  473          pea       1
0B00008A  4E93       474          jsr       (A3)
0B00008C  584F       475          addq.w    #4,A7
0B00008E  2200       476          move.l    D0,D1
0B000090  201F       477          move.l    (A7)+,D0
0B000092  4881       478          ext.w     D1
0B000094  48C1       479          ext.l     D1
0B000096  2F01       480          move.l    D1,-(A7)
0B000098  4878 0001  481          pea       1
0B00009C  4E92       482          jsr       (A2)
0B00009E  504F       483          addq.w    #8,A7
                     484   Timer_ISR_3:
                     485   ; }
                     486   ; if (Timer1Count % 5 == 0) {
0B0000A0  1039 0B00  487          move.b    _Timer1Count.L,D0
0B0000A4  1D48      
0B0000A6  C0BC 0000  488          and.l     #65535,D0
0B0000AA  FFFF      
0B0000AC  80FC 0005  489          divu.w    #5,D0
0B0000B0  4840       490          swap      D0
0B0000B2  4A00       491          tst.b     D0
0B0000B4  661C       492          bne.s     Timer_ISR_5
                     493   ; CanBus0_Transmit(2, ADCRead(2));
0B0000B6  2F00       494          move.l    D0,-(A7)
0B0000B8  4878 0002  495          pea       2
0B0000BC  4E93       496          jsr       (A3)
0B0000BE  584F       497          addq.w    #4,A7
0B0000C0  2200       498          move.l    D0,D1
0B0000C2  201F       499          move.l    (A7)+,D0
0B0000C4  4881       500          ext.w     D1
0B0000C6  48C1       501          ext.l     D1
0B0000C8  2F01       502          move.l    D1,-(A7)
0B0000CA  4878 0002  503          pea       2
0B0000CE  4E92       504          jsr       (A2)
0B0000D0  504F       505          addq.w    #8,A7
                     506   Timer_ISR_5:
                     507   ; }
                     508   ; if (Timer1Count % 20 == 0) {
0B0000D2  1039 0B00  509          move.b    _Timer1Count.L,D0
0B0000D6  1D48      
0B0000D8  C0BC 0000  510          and.l     #65535,D0
0B0000DC  FFFF      
0B0000DE  80FC 0014  511          divu.w    #20,D0
0B0000E2  4840       512          swap      D0
0B0000E4  4A00       513          tst.b     D0
0B0000E6  661C       514          bne.s     Timer_ISR_7
                     515   ; CanBus0_Transmit(3, ADCRead(3));
0B0000E8  2F00       516          move.l    D0,-(A7)
0B0000EA  4878 0003  517          pea       3
0B0000EE  4E93       518          jsr       (A3)
0B0000F0  584F       519          addq.w    #4,A7
0B0000F2  2200       520          move.l    D0,D1
0B0000F4  201F       521          move.l    (A7)+,D0
0B0000F6  4881       522          ext.w     D1
0B0000F8  48C1       523          ext.l     D1
0B0000FA  2F01       524          move.l    D1,-(A7)
0B0000FC  4878 0003  525          pea       3
0B000100  4E92       526          jsr       (A2)
0B000102  504F       527          addq.w    #8,A7
                     528   Timer_ISR_7:
                     529   ; }
                     530   ; Timer1Count++ ;     
0B000104  5239 0B00  531          addq.b    #1,_Timer1Count.L
0B000108  1D48      
                     532   ; Timer1Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
0B00010A  13FC 0003  533          move.b    #3,4194354
0B00010E  0040 0032 
                     534   Timer_ISR_1:
                     535   ; }
                     536   ; if(Timer2Status == 1) {         // Did Timer 2 produce the Interrupt?
0B000112  1039 0040  537          move.b    4194358,D0
0B000116  0036      
0B000118  0C00 0001  538          cmp.b     #1,D0
0B00011C  661A       539          bne.s     Timer_ISR_9
                     540   ; Timer2Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
0B00011E  13FC 0003  541          move.b    #3,4194358
0B000122  0040 0036 
                     542   ; PortC = Timer2Count++ ;     // increment an LED count on PortC with each tick of Timer 2
0B000126  1039 0B00  543          move.b    _Timer2Count.L,D0
0B00012A  1D4A      
0B00012C  5239 0B00  544          addq.b    #1,_Timer2Count.L
0B000130  1D4A      
0B000132  13C0 0040  545          move.b    D0,4194308
0B000136  0004      
                     546   Timer_ISR_9:
                     547   ; }
                     548   ; if(Timer3Status == 1) {         // Did Timer 3 produce the Interrupt?
0B000138  1039 0040  549          move.b    4194362,D0
0B00013C  003A      
0B00013E  0C00 0001  550          cmp.b     #1,D0
0B000142  661A       551          bne.s     Timer_ISR_11
                     552   ; Timer3Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
0B000144  13FC 0003  553          move.b    #3,4194362
0B000148  0040 003A 
                     554   ; HEX_A = Timer3Count++ ;     // increment a HEX count on Port HEX_A with each tick of Timer 3
0B00014C  1039 0B00  555          move.b    _Timer3Count.L,D0
0B000150  1D4C      
0B000152  5239 0B00  556          addq.b    #1,_Timer3Count.L
0B000156  1D4C      
0B000158  13C0 0040  557          move.b    D0,4194320
0B00015C  0010      
                     558   Timer_ISR_11:
                     559   ; }
                     560   ; if(Timer4Status == 1) {         // Did Timer 4 produce the Interrupt?
0B00015E  1039 0040  561          move.b    4194366,D0
0B000162  003E      
0B000164  0C00 0001  562          cmp.b     #1,D0
0B000168  661A       563          bne.s     Timer_ISR_13
                     564   ; Timer4Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
0B00016A  13FC 0003  565          move.b    #3,4194366
0B00016E  0040 003E 
                     566   ; HEX_B = Timer4Count++ ;     // increment a HEX count on HEX_B with each tick of Timer 4
0B000172  1039 0B00  567          move.b    _Timer4Count.L,D0
0B000176  1D4E      
0B000178  5239 0B00  568          addq.b    #1,_Timer4Count.L
0B00017C  1D4E      
0B00017E  13C0 0040  569          move.b    D0,4194322
0B000182  0012      
                     570   Timer_ISR_13:
0B000184  4CDF 0C00  571          movem.l   (A7)+,A2/A3
0B000188  4E75       572          rts
                     573   ; }
                     574   ; }
                     575   ; /*****************************************************************************************
                     576   ; **	Interrupt service routine for ACIA. This device has it's own dedicate IRQ level
                     577   ; **  Add your code here to poll Status register and clear interrupt
                     578   ; *****************************************************************************************/
                     579   ; void ACIA_ISR()
                     580   ; {}
                     581   _ACIA_ISR:
0B00018A  4E75       582          rts
                     583   ; /***************************************************************************************
                     584   ; **	Interrupt service routine for PIAs 1 and 2. These devices share an IRQ level
                     585   ; **  Add your code here to poll Status register and clear interrupt
                     586   ; *****************************************************************************************/
                     587   ; void PIA_ISR()
                     588   ; {}
                     589   _PIA_ISR:
0B00018C  4E75       590          rts
                     591   ; /***********************************************************************************
                     592   ; **	Interrupt service routine for Key 2 on DE1 board. Add your own response here
                     593   ; ************************************************************************************/
                     594   ; void Key2PressISR()
                     595   ; {}
                     596   _Key2PressISR:
0B00018E  4E75       597          rts
                     598   ; /***********************************************************************************
                     599   ; **	Interrupt service routine for Key 1 on DE1 board. Add your own response here
                     600   ; ************************************************************************************/
                     601   ; void Key1PressISR()
                     602   ; {}
                     603   _Key1PressISR:
0B000190  4E75       604          rts
                     605   ; /************************************************************************************
                     606   ; **   Delay Subroutine to give the 68000 something useless to do to waste 1 mSec
                     607   ; ************************************************************************************/
                     608   ; void Wait1ms(void)
                     609   ; {
                     610   _Wait1ms:
0B000192  2F02       611          move.l    D2,-(A7)
                     612   ; int  i ;
                     613   ; for(i = 0; i < 1000; i ++)
0B000194  4282       614          clr.l     D2
                     615   Wait1ms_1:
0B000196  0C82 0000  616          cmp.l     #1000,D2
0B00019A  03E8      
0B00019C  6C04       617          bge.s     Wait1ms_3
0B00019E  5282       618          addq.l    #1,D2
0B0001A0  60F4       619          bra       Wait1ms_1
                     620   Wait1ms_3:
0B0001A2  241F       621          move.l    (A7)+,D2
0B0001A4  4E75       622          rts
                     623   ; ;
                     624   ; }
                     625   ; /************************************************************************************
                     626   ; **  Subroutine to give the 68000 something useless to do to waste 3 mSec
                     627   ; **************************************************************************************/
                     628   ; void Wait3ms(void)
                     629   ; {
                     630   _Wait3ms:
0B0001A6  2F02       631          move.l    D2,-(A7)
                     632   ; int i ;
                     633   ; for(i = 0; i < 3; i++)
0B0001A8  4282       634          clr.l     D2
                     635   Wait3ms_1:
0B0001AA  0C82 0000  636          cmp.l     #3,D2
0B0001AE  0003      
0B0001B0  6C0A       637          bge.s     Wait3ms_3
                     638   ; Wait1ms() ;
0B0001B2  4EB9 0B00  639          jsr       _Wait1ms
0B0001B6  0192      
0B0001B8  5282       640          addq.l    #1,D2
0B0001BA  60EE       641          bra       Wait3ms_1
                     642   Wait3ms_3:
0B0001BC  241F       643          move.l    (A7)+,D2
0B0001BE  4E75       644          rts
                     645   ; }
                     646   ; /*********************************************************************************************
                     647   ; **  Subroutine to initialise the LCD display by writing some commands to the LCD internal registers
                     648   ; **  Sets it for parallel port and 2 line display mode (if I recall correctly)
                     649   ; *********************************************************************************************/
                     650   ; void Init_LCD(void)
                     651   ; {
                     652   _Init_LCD:
                     653   ; LCDcommand = 0x0c ;
0B0001C0  13FC 000C  654          move.b    #12,4194336
0B0001C4  0040 0020 
                     655   ; Wait3ms() ;
0B0001C8  4EB9 0B00  656          jsr       _Wait3ms
0B0001CC  01A6      
                     657   ; LCDcommand = 0x38 ;
0B0001CE  13FC 0038  658          move.b    #56,4194336
0B0001D2  0040 0020 
                     659   ; Wait3ms() ;
0B0001D6  4EB9 0B00  660          jsr       _Wait3ms
0B0001DA  01A6      
0B0001DC  4E75       661          rts
                     662   ; }
                     663   ; /*********************************************************************************************
                     664   ; **  Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                     665   ; *********************************************************************************************/
                     666   ; void Init_RS232(void)
                     667   ; {
                     668   _Init_RS232:
                     669   ; RS232_Control = 0x15 ; //  %00010101 set up 6850 uses divide by 16 clock, set RTS low, 8 bits no parity, 1 stop bit, transmitter interrupt disabled
0B0001DE  13FC 0015  670          move.b    #21,4194368
0B0001E2  0040 0040 
                     671   ; RS232_Baud = 0x1 ;      // program baud rate generator 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
0B0001E6  13FC 0001  672          move.b    #1,4194372
0B0001EA  0040 0044 
0B0001EE  4E75       673          rts
                     674   ; }
                     675   ; /*********************************************************************************************************
                     676   ; **  Subroutine to provide a low level output function to 6850 ACIA
                     677   ; **  This routine provides the basic functionality to output a single character to the serial Port
                     678   ; **  to allow the board to communicate with HyperTerminal Program
                     679   ; **
                     680   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                     681   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                     682   ; **  call _putch() also
                     683   ; *********************************************************************************************************/
                     684   ; int _putch( int c)
                     685   ; {
                     686   __putch:
0B0001F0  4E56 0000  687          link      A6,#0
                     688   ; while((RS232_Status & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                     689   _putch_1:
0B0001F4  1039 0040  690          move.b    4194368,D0
0B0001F8  0040      
0B0001FA  C03C 0002  691          and.b     #2,D0
0B0001FE  0C00 0002  692          cmp.b     #2,D0
0B000202  6702       693          beq.s     _putch_3
0B000204  60EE       694          bra       _putch_1
                     695   _putch_3:
                     696   ; ;
                     697   ; RS232_TxData = (c & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
0B000206  202E 0008  698          move.l    8(A6),D0
0B00020A  C0BC 0000  699          and.l     #127,D0
0B00020E  007F      
0B000210  13C0 0040  700          move.b    D0,4194370
0B000214  0042      
                     701   ; return c ;                                              // putchar() expects the character to be returned
0B000216  202E 0008  702          move.l    8(A6),D0
0B00021A  4E5E       703          unlk      A6
0B00021C  4E75       704          rts
                     705   ; }
                     706   ; /*********************************************************************************************************
                     707   ; **  Subroutine to provide a low level input function to 6850 ACIA
                     708   ; **  This routine provides the basic functionality to input a single character from the serial Port
                     709   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                     710   ; **
                     711   ; **  NOTE you do not call this function directly, instead you call the normal getchar() function
                     712   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call getchar() so will
                     713   ; **  call _getch() also
                     714   ; *********************************************************************************************************/
                     715   ; int _getch( void )
                     716   ; {
                     717   __getch:
0B00021E  4E56 FFFC  718          link      A6,#-4
                     719   ; char c ;
                     720   ; while((RS232_Status & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                     721   _getch_1:
0B000222  1039 0040  722          move.b    4194368,D0
0B000226  0040      
0B000228  C03C 0001  723          and.b     #1,D0
0B00022C  0C00 0001  724          cmp.b     #1,D0
0B000230  6702       725          beq.s     _getch_3
0B000232  60EE       726          bra       _getch_1
                     727   _getch_3:
                     728   ; ;
                     729   ; return (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
0B000234  1039 0040  730          move.b    4194370,D0
0B000238  0042      
0B00023A  C0BC 0000  731          and.l     #255,D0
0B00023E  00FF      
0B000240  C0BC 0000  732          and.l     #127,D0
0B000244  007F      
0B000246  4E5E       733          unlk      A6
0B000248  4E75       734          rts
                     735   ; }
                     736   ; /******************************************************************************
                     737   ; **  Subroutine to output a single character to the 2 row LCD display
                     738   ; **  It is assumed the character is an ASCII code and it will be displayed at the
                     739   ; **  current cursor position
                     740   ; *******************************************************************************/
                     741   ; void LCDOutchar(int c)
                     742   ; {
                     743   _LCDOutchar:
0B00024A  4E56 0000  744          link      A6,#0
                     745   ; LCDdata = (char)(c);
0B00024E  202E 0008  746          move.l    8(A6),D0
0B000252  13C0 0040  747          move.b    D0,4194338
0B000256  0022      
                     748   ; Wait1ms() ;
0B000258  4EB9 0B00  749          jsr       _Wait1ms
0B00025C  0192      
0B00025E  4E5E       750          unlk      A6
0B000260  4E75       751          rts
                     752   ; }
                     753   ; /**********************************************************************************
                     754   ; *subroutine to output a message at the current cursor position of the LCD display
                     755   ; ************************************************************************************/
                     756   ; void LCDOutMessage(char *theMessage)
                     757   ; {
                     758   _LCDOutMessage:
0B000262  4E56 FFFC  759          link      A6,#-4
                     760   ; char c ;
                     761   ; while((c = *theMessage++) != 0)     // output characters from the string until NULL
                     762   LCDOutMessage_1:
0B000266  206E 0008  763          move.l    8(A6),A0
0B00026A  52AE 0008  764          addq.l    #1,8(A6)
0B00026E  1D50 FFFF  765          move.b    (A0),-1(A6)
0B000272  1010       766          move.b    (A0),D0
0B000274  6714       767          beq.s     LCDOutMessage_3
                     768   ; LCDOutchar(c) ;
0B000276  122E FFFF  769          move.b    -1(A6),D1
0B00027A  4881       770          ext.w     D1
0B00027C  48C1       771          ext.l     D1
0B00027E  2F01       772          move.l    D1,-(A7)
0B000280  4EB9 0B00  773          jsr       _LCDOutchar
0B000284  024A      
0B000286  584F       774          addq.w    #4,A7
0B000288  60DC       775          bra       LCDOutMessage_1
                     776   LCDOutMessage_3:
0B00028A  4E5E       777          unlk      A6
0B00028C  4E75       778          rts
                     779   ; }
                     780   ; /******************************************************************************
                     781   ; *subroutine to clear the line by issuing 24 space characters
                     782   ; *******************************************************************************/
                     783   ; void LCDClearln(void)
                     784   ; {
                     785   _LCDClearln:
0B00028E  2F02       786          move.l    D2,-(A7)
                     787   ; int i ;
                     788   ; for(i = 0; i < 24; i ++)
0B000290  4282       789          clr.l     D2
                     790   LCDClearln_1:
0B000292  0C82 0000  791          cmp.l     #24,D2
0B000296  0018      
0B000298  6C10       792          bge.s     LCDClearln_3
                     793   ; LCDOutchar(' ') ;       // write a space char to the LCD display
0B00029A  4878 0020  794          pea       32
0B00029E  4EB9 0B00  795          jsr       _LCDOutchar
0B0002A2  024A      
0B0002A4  584F       796          addq.w    #4,A7
0B0002A6  5282       797          addq.l    #1,D2
0B0002A8  60E8       798          bra       LCDClearln_1
                     799   LCDClearln_3:
0B0002AA  241F       800          move.l    (A7)+,D2
0B0002AC  4E75       801          rts
                     802   ; }
                     803   ; /******************************************************************************
                     804   ; **  Subroutine to move the LCD cursor to the start of line 1 and clear that line
                     805   ; *******************************************************************************/
                     806   ; void LCDLine1Message(char *theMessage)
                     807   ; {
                     808   _LCDLine1Message:
0B0002AE  4E56 0000  809          link      A6,#0
                     810   ; LCDcommand = 0x80 ;
0B0002B2  13FC 0080  811          move.b    #128,4194336
0B0002B6  0040 0020 
                     812   ; Wait3ms();
0B0002BA  4EB9 0B00  813          jsr       _Wait3ms
0B0002BE  01A6      
                     814   ; LCDClearln() ;
0B0002C0  4EB9 0B00  815          jsr       _LCDClearln
0B0002C4  028E      
                     816   ; LCDcommand = 0x80 ;
0B0002C6  13FC 0080  817          move.b    #128,4194336
0B0002CA  0040 0020 
                     818   ; Wait3ms() ;
0B0002CE  4EB9 0B00  819          jsr       _Wait3ms
0B0002D2  01A6      
                     820   ; LCDOutMessage(theMessage) ;
0B0002D4  2F2E 0008  821          move.l    8(A6),-(A7)
0B0002D8  4EB9 0B00  822          jsr       _LCDOutMessage
0B0002DC  0262      
0B0002DE  584F       823          addq.w    #4,A7
0B0002E0  4E5E       824          unlk      A6
0B0002E2  4E75       825          rts
                     826   ; }
                     827   ; /******************************************************************************
                     828   ; **  Subroutine to move the LCD cursor to the start of line 2 and clear that line
                     829   ; *******************************************************************************/
                     830   ; void LCDLine2Message(char *theMessage)
                     831   ; {
                     832   _LCDLine2Message:
0B0002E4  4E56 0000  833          link      A6,#0
                     834   ; LCDcommand = 0xC0 ;
0B0002E8  13FC 00C0  835          move.b    #192,4194336
0B0002EC  0040 0020 
                     836   ; Wait3ms();
0B0002F0  4EB9 0B00  837          jsr       _Wait3ms
0B0002F4  01A6      
                     838   ; LCDClearln() ;
0B0002F6  4EB9 0B00  839          jsr       _LCDClearln
0B0002FA  028E      
                     840   ; LCDcommand = 0xC0 ;
0B0002FC  13FC 00C0  841          move.b    #192,4194336
0B000300  0040 0020 
                     842   ; Wait3ms() ;
0B000304  4EB9 0B00  843          jsr       _Wait3ms
0B000308  01A6      
                     844   ; LCDOutMessage(theMessage) ;
0B00030A  2F2E 0008  845          move.l    8(A6),-(A7)
0B00030E  4EB9 0B00  846          jsr       _LCDOutMessage
0B000312  0262      
0B000314  584F       847          addq.w    #4,A7
0B000316  4E5E       848          unlk      A6
0B000318  4E75       849          rts
                     850   ; }
                     851   ; /*********************************************************************************************************************************
                     852   ; **  IMPORTANT FUNCTION
                     853   ; **  This function install an exception handler so you can capture and deal with any 68000 exception in your program
                     854   ; **  You pass it the name of a function in your code that will get called in response to the exception (as the 1st parameter)
                     855   ; **  and in the 2nd parameter, you pass it the exception number that you want to take over (see 68000 exceptions for details)
                     856   ; **  Calling this function allows you to deal with Interrupts for example
                     857   ; ***********************************************************************************************************************************/
                     858   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                     859   ; {
                     860   _InstallExceptionHandler:
0B00031A  4E56 FFFC  861          link      A6,#-4
                     862   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
0B00031E  2D7C 0B00  863          move.l    #184549376,-4(A6)
0B000322  0000 FFFC 
                     864   ; RamVectorAddress[level] = (long int *)(function_ptr);                       // install the address of our function into the exception table
0B000326  206E FFFC  865          move.l    -4(A6),A0
0B00032A  202E 000C  866          move.l    12(A6),D0
0B00032E  E588       867          lsl.l     #2,D0
0B000330  21AE 0008  868          move.l    8(A6),0(A0,D0.L)
0B000334  0800      
0B000336  4E5E       869          unlk      A6
0B000338  4E75       870          rts
                     871   ; }
                     872   ; /******************************************************************************************************************************
                     873   ; * Start of user program
                     874   ; ******************************************************************************************************************************/
                     875   ; void Enable_SCL(void){
                     876   _Enable_SCL:
                     877   ; I2C_CLK_PRESCALE_LOW = 0x31;
0B00033A  13FC 0031  878          move.b    #49,4227072
0B00033E  0040 8000 
                     879   ; I2C_CLK_PRESCALE_HIGH = 0x00;
0B000342  4239 0040  880          clr.b     4227074
0B000346  8002      
0B000348  4E75       881          rts
                     882   ; }
                     883   ; void WaitTIP(void){
                     884   _WaitTIP:
0B00034A  4E56 FFFC  885          link      A6,#-4
                     886   ; int TIP_bit;
                     887   ; do{
                     888   WaitTIP_1:
                     889   ; TIP_bit = (I2C_STAT >> 1) & 0x01; // this flag represents acknowledge from the addressed slave | 1 = No acknowledge received | 0 = Acknowledge received
0B00034E  1039 0040  890          move.b    4227080,D0
0B000352  8008      
0B000354  C0BC 0000  891          and.l     #255,D0
0B000358  00FF      
0B00035A  E288       892          lsr.l     #1,D0
0B00035C  C0BC 0000  893          and.l     #1,D0
0B000360  0001      
0B000362  2D40 FFFC  894          move.l    D0,-4(A6)
0B000366  202E FFFC  895          move.l    -4(A6),D0
0B00036A  66E2       896          bne       WaitTIP_1
0B00036C  4E5E       897          unlk      A6
0B00036E  4E75       898          rts
                     899   ; }while(TIP_bit != 0);
                     900   ; }
                     901   ; void WaitACK(void){
                     902   _WaitACK:
0B000370  4E56 FFFC  903          link      A6,#-4
                     904   ; int ACK;
                     905   ; do{
                     906   WaitACK_1:
                     907   ; ACK = (I2C_STAT >> 7) & 0x01;
0B000374  1039 0040  908          move.b    4227080,D0
0B000378  8008      
0B00037A  C0BC 0000  909          and.l     #255,D0
0B00037E  00FF      
0B000380  EE88       910          lsr.l     #7,D0
0B000382  C0BC 0000  911          and.l     #1,D0
0B000386  0001      
0B000388  2D40 FFFC  912          move.l    D0,-4(A6)
0B00038C  202E FFFC  913          move.l    -4(A6),D0
0B000390  66E2       914          bne       WaitACK_1
0B000392  4E5E       915          unlk      A6
0B000394  4E75       916          rts
                     917   ; }while(ACK != 0);
                     918   ; }
                     919   ; ///////////////////////////////////
                     920   ; // I2C controller initialization //
                     921   ; ///////////////////////////////////
                     922   ; void I2C_Init(void){
                     923   _I2C_Init:
                     924   ; Enable_SCL();
0B000396  4EB9 0B00  925          jsr       _Enable_SCL
0B00039A  033A      
                     926   ; Enable_I2C_Controller();
0B00039C  13FC 0080  927          move.b    #128,4227076
0B0003A0  0040 8004 
0B0003A4  4E75       928          rts
                     929   ; }
                     930   ; ///////////////////////////////////////////////
                     931   ; // write a single byte to the EEPROM via I2C //
                     932   ; ///////////////////////////////////////////////
                     933   ; void WriteI2CInteraction(int block, unsigned int Address, unsigned char AddressMSB, unsigned char AddressLSB, unsigned char data, int flag){
                     934   _WriteI2CInteraction:
0B0003A6  4E56 0000  935          link      A6,#0
0B0003AA  48E7 2030  936          movem.l   D2/A2/A3,-(A7)
0B0003AE  45F9 0B00  937          lea       _WaitTIP.L,A2
0B0003B2  034A      
0B0003B4  47F9 0B00  938          lea       _WaitACK.L,A3
0B0003B8  0370      
                     939   ; unsigned char controlByte;
                     940   ; // determine the block of interest 
                     941   ; if (block == 1) {
0B0003BA  202E 0008  942          move.l    8(A6),D0
0B0003BE  0C80 0000  943          cmp.l     #1,D0
0B0003C2  0001      
0B0003C4  6606       944          bne.s     WriteI2CInteraction_1
                     945   ; controlByte = EEPROM_Write_Block_1;
0B0003C6  143C 00A2  946          move.b    #162,D2
0B0003CA  6004       947          bra.s     WriteI2CInteraction_2
                     948   WriteI2CInteraction_1:
                     949   ; } 
                     950   ; else {
                     951   ; controlByte = EEPROM_Write_Block_0;
0B0003CC  143C 00A0  952          move.b    #160,D2
                     953   WriteI2CInteraction_2:
                     954   ; }
                     955   ; // wait for TIP
                     956   ; WaitTIP();
0B0003D0  4E92       957          jsr       (A2)
                     958   ; // store the data to TX register
                     959   ; I2C_TX = controlByte;
0B0003D2  13C2 0040  960          move.b    D2,4227078
0B0003D6  8006      
                     961   ; // command to generate start condition, write, and clear pending interrupt 
                     962   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
0B0003D8  13FC 0091  963          move.b    #145,4227080
0B0003DC  0040 8008 
                     964   ; //Wait for TIP bit in Status Register
                     965   ; WaitTIP();
0B0003E0  4E92       966          jsr       (A2)
                     967   ; //Wait RxACK bit in Status Register
                     968   ; WaitACK();
0B0003E2  4E93       969          jsr       (A3)
                     970   ; // send the most significant byte of the address
                     971   ; I2C_TX = AddressMSB;
0B0003E4  13EE 0013  972          move.b    19(A6),4227078
0B0003E8  0040 8006 
                     973   ; // command to write and clear pending interrupt 
                     974   ; I2C_CMD = I2C_CMD_Slave_Write;
0B0003EC  13FC 0011  975          move.b    #17,4227080
0B0003F0  0040 8008 
                     976   ; WaitTIP();
0B0003F4  4E92       977          jsr       (A2)
                     978   ; WaitACK();
0B0003F6  4E93       979          jsr       (A3)
                     980   ; // send the least significant byte of the address
                     981   ; I2C_TX = AddressLSB;
0B0003F8  13EE 0017  982          move.b    23(A6),4227078
0B0003FC  0040 8006 
                     983   ; I2C_CMD = I2C_CMD_Slave_Write;
0B000400  13FC 0011  984          move.b    #17,4227080
0B000404  0040 8008 
                     985   ; WaitTIP();
0B000408  4E92       986          jsr       (A2)
                     987   ; WaitACK();
0B00040A  4E93       988          jsr       (A3)
                     989   ; // send data
                     990   ; I2C_TX = data;
0B00040C  13EE 001B  991          move.b    27(A6),4227078
0B000410  0040 8006 
                     992   ; I2C_CMD = I2C_CMD_Slave_Write_Stop;
0B000414  13FC 0051  993          move.b    #81,4227080
0B000418  0040 8008 
                     994   ; WaitTIP();
0B00041C  4E92       995          jsr       (A2)
                     996   ; WaitACK();
0B00041E  4E93       997          jsr       (A3)
                     998   ; if(flag == 0){
0B000420  202E 001C  999          move.l    28(A6),D0
0B000424  6620      1000          bne.s     WriteI2CInteraction_3
                    1001   ; printf("\r\nWrote [%x] to Address[%x]", data, Address);
0B000426  2F2E 000C 1002          move.l    12(A6),-(A7)
0B00042A  122E 001B 1003          move.b    27(A6),D1
0B00042E  C2BC 0000 1004          and.l     #255,D1
0B000432  00FF      
0B000434  2F01      1005          move.l    D1,-(A7)
0B000436  4879 0B00 1006          pea       @mup_1.L
0B00043A  1AC8      
0B00043C  4EB9 0B00 1007          jsr       _printf
0B000440  110A      
0B000442  DEFC 000C 1008          add.w     #12,A7
                    1009   WriteI2CInteraction_3:
0B000446  4CDF 0C04 1010          movem.l   (A7)+,D2/A2/A3
0B00044A  4E5E      1011          unlk      A6
0B00044C  4E75      1012          rts
                    1013   ; }
                    1014   ; }
                    1015   ; //////////////////////////////////////////////////
                    1016   ; // write up to 128k bytes to the EEPROM via I2C //
                    1017   ; //////////////////////////////////////////////////
                    1018   ; void PageWriteI2CInteraction(unsigned int AddressFrom, unsigned int AddressTo, unsigned char data){
                    1019   _PageWriteI2CInteraction:
0B00044E  4E56 FFF4 1020          link      A6,#-12
0B000452  48E7 3F3C 1021          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
0B000456  242E 0008 1022          move.l    8(A6),D2
0B00045A  45F9 0B00 1023          lea       _WaitTIP.L,A2
0B00045E  034A      
0B000460  47F9 0B00 1024          lea       _WaitACK.L,A3
0B000464  0370      
0B000466  1E2E 0013 1025          move.b    19(A6),D7
0B00046A  CEBC 0000 1026          and.l     #255,D7
0B00046E  00FF      
0B000470  286E 000C 1027          move.l    12(A6),A4
                    1028   ; int flag = 0;
0B000474  3A7C 0000 1029          move.w    #0,A5
                    1030   ; int flag_special = 0;
0B000478  42AE FFF6 1031          clr.l     -10(A6)
                    1032   ; int i = 0;
0B00047C  4283      1033          clr.l     D3
                    1034   ; unsigned char controlByte;
                    1035   ; unsigned char AddressFromMSB;
                    1036   ; unsigned char AddressFromLSB;
                    1037   ; unsigned char AddressRange;
                    1038   ; unsigned int AddressFrom_Initial;
                    1039   ; AddressFrom_Initial = AddressFrom;
0B00047E  2D42 FFFC 1040          move.l    D2,-4(A6)
                    1041   ; while(AddressFrom < AddressTo){
                    1042   PageWriteI2CInteraction_1:
0B000482  B48C      1043          cmp.l     A4,D2
0B000484  6400 0178 1044          bhs       PageWriteI2CInteraction_3
                    1045   ; if (AddressFrom + 128 > AddressTo) {
0B000488  2002      1046          move.l    D2,D0
0B00048A  0680 0000 1047          add.l     #128,D0
0B00048E  0080      
0B000490  B08C      1048          cmp.l     A4,D0
0B000492  6304      1049          bls.s     PageWriteI2CInteraction_4
                    1050   ; flag = 1;
0B000494  3A7C 0001 1051          move.w    #1,A5
                    1052   PageWriteI2CInteraction_4:
                    1053   ; }
                    1054   ; if (AddressFrom > 0xFFFF) {
0B000498  0C82 0000 1055          cmp.l     #65535,D2
0B00049C  FFFF      
0B00049E  6328      1056          bls.s     PageWriteI2CInteraction_6
                    1057   ; controlByte = EEPROM_Write_Block_1;
0B0004A0  1C3C 00A2 1058          move.b    #162,D6
                    1059   ; AddressFromMSB = ((AddressFrom - 0x10000) >> 8) & 0xFF;
0B0004A4  2002      1060          move.l    D2,D0
0B0004A6  0480 0001 1061          sub.l     #65536,D0
0B0004AA  0000      
0B0004AC  E088      1062          lsr.l     #8,D0
0B0004AE  C0BC 0000 1063          and.l     #255,D0
0B0004B2  00FF      
0B0004B4  1A00      1064          move.b    D0,D5
                    1065   ; AddressFromLSB = (AddressFrom - 0x10000) & 0xFF;
0B0004B6  2002      1066          move.l    D2,D0
0B0004B8  0480 0001 1067          sub.l     #65536,D0
0B0004BC  0000      
0B0004BE  C0BC 0000 1068          and.l     #255,D0
0B0004C2  00FF      
0B0004C4  1800      1069          move.b    D0,D4
0B0004C6  601A      1070          bra.s     PageWriteI2CInteraction_7
                    1071   PageWriteI2CInteraction_6:
                    1072   ; }
                    1073   ; else {
                    1074   ; controlByte = EEPROM_Write_Block_0;
0B0004C8  1C3C 00A0 1075          move.b    #160,D6
                    1076   ; AddressFromMSB = (AddressFrom >> 8) & 0xFF;
0B0004CC  2002      1077          move.l    D2,D0
0B0004CE  E088      1078          lsr.l     #8,D0
0B0004D0  C0BC 0000 1079          and.l     #255,D0
0B0004D4  00FF      
0B0004D6  1A00      1080          move.b    D0,D5
                    1081   ; AddressFromLSB = AddressFrom & 0xFF;
0B0004D8  2002      1082          move.l    D2,D0
0B0004DA  C0BC 0000 1083          and.l     #255,D0
0B0004DE  00FF      
0B0004E0  1800      1084          move.b    D0,D4
                    1085   PageWriteI2CInteraction_7:
                    1086   ; }
                    1087   ; WaitTIP();
0B0004E2  4E92      1088          jsr       (A2)
                    1089   ; I2C_TX = controlByte;
0B0004E4  13C6 0040 1090          move.b    D6,4227078
0B0004E8  8006      
                    1091   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
0B0004EA  13FC 0091 1092          move.b    #145,4227080
0B0004EE  0040 8008 
                    1093   ; WaitTIP();
0B0004F2  4E92      1094          jsr       (A2)
                    1095   ; WaitACK();
0B0004F4  4E93      1096          jsr       (A3)
                    1097   ; I2C_TX = AddressFromMSB;
0B0004F6  13C5 0040 1098          move.b    D5,4227078
0B0004FA  8006      
                    1099   ; I2C_CMD = I2C_CMD_Slave_Write;
0B0004FC  13FC 0011 1100          move.b    #17,4227080
0B000500  0040 8008 
                    1101   ; WaitTIP();
0B000504  4E92      1102          jsr       (A2)
                    1103   ; WaitACK();
0B000506  4E93      1104          jsr       (A3)
                    1105   ; I2C_TX = AddressFromLSB;
0B000508  13C4 0040 1106          move.b    D4,4227078
0B00050C  8006      
                    1107   ; I2C_CMD = I2C_CMD_Slave_Write;
0B00050E  13FC 0011 1108          move.b    #17,4227080
0B000512  0040 8008 
                    1109   ; WaitTIP();
0B000516  4E92      1110          jsr       (A2)
                    1111   ; WaitACK();
0B000518  4E93      1112          jsr       (A3)
                    1113   ; if(flag == 0){
0B00051A  200D      1114          move.l    A5,D0
0B00051C  6600 0052 1115          bne       PageWriteI2CInteraction_8
                    1116   ; for (i = 0; i < 128; i++){  // limit write to 128 bytes
0B000520  4283      1117          clr.l     D3
                    1118   PageWriteI2CInteraction_10:
0B000522  0C83 0000 1119          cmp.l     #128,D3
0B000526  0080      
0B000528  6C00 0042 1120          bge       PageWriteI2CInteraction_12
                    1121   ; I2C_TX = data;
0B00052C  13C7 0040 1122          move.b    D7,4227078
0B000530  8006      
                    1123   ; I2C_CMD = I2C_CMD_Slave_Write;
0B000532  13FC 0011 1124          move.b    #17,4227080
0B000536  0040 8008 
                    1125   ; WaitTIP();
0B00053A  4E92      1126          jsr       (A2)
                    1127   ; WaitACK();
0B00053C  4E93      1128          jsr       (A3)
                    1129   ; if((AddressFrom + i) % 128 == 0){
0B00053E  2002      1130          move.l    D2,D0
0B000540  D083      1131          add.l     D3,D0
0B000542  2F00      1132          move.l    D0,-(A7)
0B000544  4878 0080 1133          pea       128
0B000548  4EB9 0B00 1134          jsr       ULDIV
0B00054C  102C      
0B00054E  202F 0004 1135          move.l    4(A7),D0
0B000552  504F      1136          addq.w    #8,A7
0B000554  4A80      1137          tst.l     D0
0B000556  6602      1138          bne.s     PageWriteI2CInteraction_13
                    1139   ; break;
0B000558  6012      1140          bra.s     PageWriteI2CInteraction_12
                    1141   PageWriteI2CInteraction_13:
                    1142   ; }
                    1143   ; // check if need to switch blocks
                    1144   ; if(AddressFrom + i == 0xFFFF){
0B00055A  2002      1145          move.l    D2,D0
0B00055C  D083      1146          add.l     D3,D0
0B00055E  0C80 0000 1147          cmp.l     #65535,D0
0B000562  FFFF      
0B000564  6602      1148          bne.s     PageWriteI2CInteraction_15
                    1149   ; break;
0B000566  6004      1150          bra.s     PageWriteI2CInteraction_12
                    1151   PageWriteI2CInteraction_15:
0B000568  5283      1152          addq.l    #1,D3
0B00056A  60B6      1153          bra       PageWriteI2CInteraction_10
                    1154   PageWriteI2CInteraction_12:
0B00056C  6000 005C 1155          bra       PageWriteI2CInteraction_19
                    1156   PageWriteI2CInteraction_8:
                    1157   ; }
                    1158   ; }
                    1159   ; }
                    1160   ; else {
                    1161   ; AddressRange = AddressTo - AddressFrom;
0B000570  200C      1162          move.l    A4,D0
0B000572  9082      1163          sub.l     D2,D0
0B000574  1D40 FFFB 1164          move.b    D0,-5(A6)
                    1165   ; for(i = 0; i < AddressRange; i++){                
0B000578  4283      1166          clr.l     D3
                    1167   PageWriteI2CInteraction_17:
0B00057A  102E FFFB 1168          move.b    -5(A6),D0
0B00057E  C0BC 0000 1169          and.l     #255,D0
0B000582  00FF      
0B000584  B680      1170          cmp.l     D0,D3
0B000586  6400 0042 1171          bhs       PageWriteI2CInteraction_19
                    1172   ; I2C_TX = data;
0B00058A  13C7 0040 1173          move.b    D7,4227078
0B00058E  8006      
                    1174   ; I2C_CMD = I2C_CMD_Slave_Write;
0B000590  13FC 0011 1175          move.b    #17,4227080
0B000594  0040 8008 
                    1176   ; WaitTIP();
0B000598  4E92      1177          jsr       (A2)
                    1178   ; WaitACK();
0B00059A  4E93      1179          jsr       (A3)
                    1180   ; if((AddressFrom + i) % 128 == 0){
0B00059C  2002      1181          move.l    D2,D0
0B00059E  D083      1182          add.l     D3,D0
0B0005A0  2F00      1183          move.l    D0,-(A7)
0B0005A2  4878 0080 1184          pea       128
0B0005A6  4EB9 0B00 1185          jsr       ULDIV
0B0005AA  102C      
0B0005AC  202F 0004 1186          move.l    4(A7),D0
0B0005B0  504F      1187          addq.w    #8,A7
0B0005B2  4A80      1188          tst.l     D0
0B0005B4  6602      1189          bne.s     PageWriteI2CInteraction_20
                    1190   ; break;
0B0005B6  6012      1191          bra.s     PageWriteI2CInteraction_19
                    1192   PageWriteI2CInteraction_20:
                    1193   ; }
                    1194   ; // check if need to switch blocks
                    1195   ; if(AddressFrom + i == 0xFFFF){
0B0005B8  2002      1196          move.l    D2,D0
0B0005BA  D083      1197          add.l     D3,D0
0B0005BC  0C80 0000 1198          cmp.l     #65535,D0
0B0005C0  FFFF      
0B0005C2  6602      1199          bne.s     PageWriteI2CInteraction_22
                    1200   ; break;
0B0005C4  6004      1201          bra.s     PageWriteI2CInteraction_19
                    1202   PageWriteI2CInteraction_22:
0B0005C6  5283      1203          addq.l    #1,D3
0B0005C8  60B0      1204          bra       PageWriteI2CInteraction_17
                    1205   PageWriteI2CInteraction_19:
                    1206   ; }
                    1207   ; }
                    1208   ; }
                    1209   ; I2C_CMD = I2C_CMD_Slave_Write_Stop;
0B0005CA  13FC 0051 1210          move.b    #81,4227080
0B0005CE  0040 8008 
                    1211   ; WaitTIP();
0B0005D2  4E92      1212          jsr       (A2)
                    1213   ; WaitACK();
0B0005D4  4E93      1214          jsr       (A3)
                    1215   ; do {
                    1216   PageWriteI2CInteraction_24:
                    1217   ; I2C_TX = controlByte;
0B0005D6  13C6 0040 1218          move.b    D6,4227078
0B0005DA  8006      
                    1219   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
0B0005DC  13FC 0091 1220          move.b    #145,4227080
0B0005E0  0040 8008 
                    1221   ; WaitTIP();
0B0005E4  4E92      1222          jsr       (A2)
0B0005E6  1039 0040 1223          move.b    4227080,D0
0B0005EA  8008      
0B0005EC  EE08      1224          lsr.b     #7,D0
0B0005EE  C03C 0001 1225          and.b     #1,D0
0B0005F2  66E2      1226          bne       PageWriteI2CInteraction_24
                    1227   ; } while (((I2C_STAT >> 7) & 0x01) != 0); // wait for acknowledgement from the slave
                    1228   ; AddressFrom += (i + 1);
0B0005F4  2003      1229          move.l    D3,D0
0B0005F6  5280      1230          addq.l    #1,D0
0B0005F8  D480      1231          add.l     D0,D2
0B0005FA  6000 FE86 1232          bra       PageWriteI2CInteraction_1
                    1233   PageWriteI2CInteraction_3:
                    1234   ; }
                    1235   ; // special case for end address being the first byte of the next/last page
                    1236   ; if (((AddressFrom + i) % 128 == 0) && (flag == 1)) {
0B0005FE  2002      1237          move.l    D2,D0
0B000600  D083      1238          add.l     D3,D0
0B000602  2F00      1239          move.l    D0,-(A7)
0B000604  4878 0080 1240          pea       128
0B000608  4EB9 0B00 1241          jsr       ULDIV
0B00060C  102C      
0B00060E  202F 0004 1242          move.l    4(A7),D0
0B000612  504F      1243          addq.w    #8,A7
0B000614  4A80      1244          tst.l     D0
0B000616  6600 00C6 1245          bne       PageWriteI2CInteraction_29
0B00061A  200D      1246          move.l    A5,D0
0B00061C  0C80 0000 1247          cmp.l     #1,D0
0B000620  0001      
0B000622  6600 00BA 1248          bne       PageWriteI2CInteraction_29
                    1249   ; if((AddressFrom + i) > 0xFFFF){
0B000626  2002      1250          move.l    D2,D0
0B000628  D083      1251          add.l     D3,D0
0B00062A  0C80 0000 1252          cmp.l     #65535,D0
0B00062E  FFFF      
0B000630  6300 0060 1253          bls       PageWriteI2CInteraction_28
                    1254   ; controlByte = EEPROM_Write_Block_1;
0B000634  1C3C 00A2 1255          move.b    #162,D6
                    1256   ; AddressFromMSB = (((AddressFrom + i) - 0x10000) >> 8) & 0xFF;
0B000638  2002      1257          move.l    D2,D0
0B00063A  D083      1258          add.l     D3,D0
0B00063C  0480 0001 1259          sub.l     #65536,D0
0B000640  0000      
0B000642  E088      1260          lsr.l     #8,D0
0B000644  C0BC 0000 1261          and.l     #255,D0
0B000648  00FF      
0B00064A  1A00      1262          move.b    D0,D5
                    1263   ; AddressFromLSB = ((AddressFrom + i) - 0x10000) & 0xFF;
0B00064C  2002      1264          move.l    D2,D0
0B00064E  D083      1265          add.l     D3,D0
0B000650  0480 0001 1266          sub.l     #65536,D0
0B000654  0000      
0B000656  C0BC 0000 1267          and.l     #255,D0
0B00065A  00FF      
0B00065C  1800      1268          move.b    D0,D4
                    1269   ; WriteI2CInteraction(1, (AddressFrom + i), AddressFromMSB, AddressFromLSB, data, 1);
0B00065E  4878 0001 1270          pea       1
0B000662  CEBC 0000 1271          and.l     #255,D7
0B000666  00FF      
0B000668  2F07      1272          move.l    D7,-(A7)
0B00066A  C8BC 0000 1273          and.l     #255,D4
0B00066E  00FF      
0B000670  2F04      1274          move.l    D4,-(A7)
0B000672  CABC 0000 1275          and.l     #255,D5
0B000676  00FF      
0B000678  2F05      1276          move.l    D5,-(A7)
0B00067A  2202      1277          move.l    D2,D1
0B00067C  D283      1278          add.l     D3,D1
0B00067E  2F01      1279          move.l    D1,-(A7)
0B000680  4878 0001 1280          pea       1
0B000684  4EB9 0B00 1281          jsr       _WriteI2CInteraction
0B000688  03A6      
0B00068A  DEFC 0018 1282          add.w     #24,A7
0B00068E  6000 004E 1283          bra       PageWriteI2CInteraction_29
                    1284   PageWriteI2CInteraction_28:
                    1285   ; }
                    1286   ; else {
                    1287   ; controlByte = EEPROM_Write_Block_0;
0B000692  1C3C 00A0 1288          move.b    #160,D6
                    1289   ; AddressFromMSB = ((AddressFrom + i) >> 8) & 0xFF;
0B000696  2002      1290          move.l    D2,D0
0B000698  D083      1291          add.l     D3,D0
0B00069A  E088      1292          lsr.l     #8,D0
0B00069C  C0BC 0000 1293          and.l     #255,D0
0B0006A0  00FF      
0B0006A2  1A00      1294          move.b    D0,D5
                    1295   ; AddressFromLSB = (AddressFrom + i) & 0xFF;
0B0006A4  2002      1296          move.l    D2,D0
0B0006A6  D083      1297          add.l     D3,D0
0B0006A8  C0BC 0000 1298          and.l     #255,D0
0B0006AC  00FF      
0B0006AE  1800      1299          move.b    D0,D4
                    1300   ; WriteI2CInteraction(0, (AddressFrom + i), AddressFromMSB, AddressFromLSB, data, 1);
0B0006B0  4878 0001 1301          pea       1
0B0006B4  CEBC 0000 1302          and.l     #255,D7
0B0006B8  00FF      
0B0006BA  2F07      1303          move.l    D7,-(A7)
0B0006BC  C8BC 0000 1304          and.l     #255,D4
0B0006C0  00FF      
0B0006C2  2F04      1305          move.l    D4,-(A7)
0B0006C4  CABC 0000 1306          and.l     #255,D5
0B0006C8  00FF      
0B0006CA  2F05      1307          move.l    D5,-(A7)
0B0006CC  2202      1308          move.l    D2,D1
0B0006CE  D283      1309          add.l     D3,D1
0B0006D0  2F01      1310          move.l    D1,-(A7)
0B0006D2  42A7      1311          clr.l     -(A7)
0B0006D4  4EB9 0B00 1312          jsr       _WriteI2CInteraction
0B0006D8  03A6      
0B0006DA  DEFC 0018 1313          add.w     #24,A7
                    1314   PageWriteI2CInteraction_29:
                    1315   ; }
                    1316   ; }
                    1317   ; printf("\r\nWrote [%x] from Address[%x] to Address[%x]", data, AddressFrom_Initial, AddressTo);
0B0006DE  2F0C      1318          move.l    A4,-(A7)
0B0006E0  2F2E FFFC 1319          move.l    -4(A6),-(A7)
0B0006E4  CEBC 0000 1320          and.l     #255,D7
0B0006E8  00FF      
0B0006EA  2F07      1321          move.l    D7,-(A7)
0B0006EC  4879 0B00 1322          pea       @mup_2.L
0B0006F0  1AE4      
0B0006F2  4EB9 0B00 1323          jsr       _printf
0B0006F6  110A      
0B0006F8  DEFC 0010 1324          add.w     #16,A7
0B0006FC  4CDF 3CFC 1325          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
0B000700  4E5E      1326          unlk      A6
0B000702  4E75      1327          rts
                    1328   ; }
                    1329   ; ///////////////////////////////////////////////
                    1330   ; // read a single byte to the EEPROM via I2C //
                    1331   ; ///////////////////////////////////////////////
                    1332   ; void ReadI2CByteInteraction(int block, unsigned int Address, unsigned char AddressMSB, unsigned char AddressLSB){
                    1333   _ReadI2CByteInteraction:
0B000704  4E56 FFFC 1334          link      A6,#-4
0B000708  48E7 3030 1335          movem.l   D2/D3/A2/A3,-(A7)
0B00070C  45F9 0B00 1336          lea       _WaitTIP.L,A2
0B000710  034A      
0B000712  47F9 0B00 1337          lea       _WaitACK.L,A3
0B000716  0370      
                    1338   ; unsigned char controleByte_ForWrite;
                    1339   ; unsigned char controlByte_ForRead;
                    1340   ; unsigned char readData;
                    1341   ; if(block == 1){
0B000718  202E 0008 1342          move.l    8(A6),D0
0B00071C  0C80 0000 1343          cmp.l     #1,D0
0B000720  0001      
0B000722  660A      1344          bne.s     ReadI2CByteInteraction_1
                    1345   ; controleByte_ForWrite= 162;
0B000724  163C 00A2 1346          move.b    #162,D3
                    1347   ; controlByte_ForRead = 163;
0B000728  143C 00A3 1348          move.b    #163,D2
0B00072C  6008      1349          bra.s     ReadI2CByteInteraction_2
                    1350   ReadI2CByteInteraction_1:
                    1351   ; }else{
                    1352   ; controleByte_ForWrite = 160;
0B00072E  163C 00A0 1353          move.b    #160,D3
                    1354   ; controlByte_ForRead = 161;
0B000732  143C 00A1 1355          move.b    #161,D2
                    1356   ReadI2CByteInteraction_2:
                    1357   ; }
                    1358   ; WaitTIP();
0B000736  4E92      1359          jsr       (A2)
                    1360   ; I2C_TX = controleByte_ForWrite;
0B000738  13C3 0040 1361          move.b    D3,4227078
0B00073C  8006      
                    1362   ; I2C_CMD = 145;
0B00073E  13FC 0091 1363          move.b    #145,4227080
0B000742  0040 8008 
                    1364   ; WaitTIP();
0B000746  4E92      1365          jsr       (A2)
                    1366   ; WaitACK();
0B000748  4E93      1367          jsr       (A3)
                    1368   ; I2C_TX = AddressMSB;
0B00074A  13EE 0013 1369          move.b    19(A6),4227078
0B00074E  0040 8006 
                    1370   ; I2C_CMD = 17;
0B000752  13FC 0011 1371          move.b    #17,4227080
0B000756  0040 8008 
                    1372   ; WaitTIP();
0B00075A  4E92      1373          jsr       (A2)
                    1374   ; WaitACK();
0B00075C  4E93      1375          jsr       (A3)
                    1376   ; I2C_TX = AddressLSB;
0B00075E  13EE 0017 1377          move.b    23(A6),4227078
0B000762  0040 8006 
                    1378   ; I2C_CMD = 17;
0B000766  13FC 0011 1379          move.b    #17,4227080
0B00076A  0040 8008 
                    1380   ; WaitTIP();
0B00076E  4E92      1381          jsr       (A2)
                    1382   ; WaitACK();
0B000770  4E93      1383          jsr       (A3)
                    1384   ; I2C_TX = controlByte_ForRead;
0B000772  13C2 0040 1385          move.b    D2,4227078
0B000776  8006      
                    1386   ; I2C_CMD = 145;
0B000778  13FC 0091 1387          move.b    #145,4227080
0B00077C  0040 8008 
                    1388   ; WaitTIP();
0B000780  4E92      1389          jsr       (A2)
                    1390   ; WaitACK();
0B000782  4E93      1391          jsr       (A3)
                    1392   ; I2C_CMD = 105;
0B000784  13FC 0069 1393          move.b    #105,4227080
0B000788  0040 8008 
                    1394   ; WaitTIP();
0B00078C  4E92      1395          jsr       (A2)
                    1396   ; while((I2C_STAT & 0x01) != 0x01) {
                    1397   ReadI2CByteInteraction_3:
0B00078E  1039 0040 1398          move.b    4227080,D0
0B000792  8008      
0B000794  C03C 0001 1399          and.b     #1,D0
0B000798  0C00 0001 1400          cmp.b     #1,D0
0B00079C  6702      1401          beq.s     ReadI2CByteInteraction_5
                    1402   ; }
0B00079E  60EE      1403          bra       ReadI2CByteInteraction_3
                    1404   ReadI2CByteInteraction_5:
                    1405   ; I2C_STAT = 0;
0B0007A0  4239 0040 1406          clr.b     4227080
0B0007A4  8008      
                    1407   ; readData = I2C_RX;
0B0007A6  1D79 0040 1408          move.b    4227078,-1(A6)
0B0007AA  8006 FFFF 
                    1409   ; printf("\r\nRead [%x] from Address[%x]", readData, Address);
0B0007AE  2F2E 000C 1410          move.l    12(A6),-(A7)
0B0007B2  122E FFFF 1411          move.b    -1(A6),D1
0B0007B6  C2BC 0000 1412          and.l     #255,D1
0B0007BA  00FF      
0B0007BC  2F01      1413          move.l    D1,-(A7)
0B0007BE  4879 0B00 1414          pea       @mup_3.L
0B0007C2  1B12      
0B0007C4  4EB9 0B00 1415          jsr       _printf
0B0007C8  110A      
0B0007CA  DEFC 000C 1416          add.w     #12,A7
                    1417   ; return;
0B0007CE  4CDF 0C0C 1418          movem.l   (A7)+,D2/D3/A2/A3
0B0007D2  4E5E      1419          unlk      A6
0B0007D4  4E75      1420          rts
                    1421   ; }
                    1422   ; //////////////////////////////////////////////////
                    1423   ; // read up to 128k bytes to the EEPROM via I2C //
                    1424   ; //////////////////////////////////////////////////
                    1425   ; void ReadI2CSequential(int block, int AddressTo, int AddressFrom,  unsigned int ChipAddress){
                    1426   _ReadI2CSequential:
0B0007D6  4E56 FFF8 1427          link      A6,#-8
0B0007DA  48E7 3F3C 1428          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
0B0007DE  45F9 0B00 1429          lea       _WaitTIP.L,A2
0B0007E2  034A      
0B0007E4  47F9 0B00 1430          lea       _WaitACK.L,A3
0B0007E8  0370      
0B0007EA  242E 0014 1431          move.l    20(A6),D2
                    1432   ; unsigned char controleWriteByte;
                    1433   ; unsigned char controlReadByte;
                    1434   ; unsigned char readData;
                    1435   ; unsigned char AddressLSB;
                    1436   ; unsigned char AddressMSB;
                    1437   ; int i;
                    1438   ; int size;
                    1439   ; int block_change_flag = 0;
0B0007EE  387C 0000 1440          move.w    #0,A4
                    1441   ; int block_address;
                    1442   ; size = AddressTo - AddressFrom;
0B0007F2  202E 000C 1443          move.l    12(A6),D0
0B0007F6  90AE 0010 1444          sub.l     16(A6),D0
0B0007FA  2D40 FFFC 1445          move.l    D0,-4(A6)
                    1446   ; AddressMSB = (ChipAddress >> 8) & 0xFF;
0B0007FE  2002      1447          move.l    D2,D0
0B000800  E088      1448          lsr.l     #8,D0
0B000802  C0BC 0000 1449          and.l     #255,D0
0B000806  00FF      
0B000808  1C00      1450          move.b    D0,D6
                    1451   ; AddressLSB = ChipAddress & 0xFF;
0B00080A  2002      1452          move.l    D2,D0
0B00080C  C0BC 0000 1453          and.l     #255,D0
0B000810  00FF      
0B000812  1A00      1454          move.b    D0,D5
                    1455   ; if(block == 1){
0B000814  202E 0008 1456          move.l    8(A6),D0
0B000818  0C80 0000 1457          cmp.l     #1,D0
0B00081C  0001      
0B00081E  662C      1458          bne.s     ReadI2CSequential_1
                    1459   ; controleWriteByte = EEPROM_Write_Block_1;
0B000820  183C 00A2 1460          move.b    #162,D4
                    1461   ; controlReadByte = EEPROM_Read_Block_1;
0B000824  163C 00A3 1462          move.b    #163,D3
                    1463   ; AddressMSB = ((ChipAddress-0x10000) >> 8) & 0xFF;
0B000828  2002      1464          move.l    D2,D0
0B00082A  0480 0001 1465          sub.l     #65536,D0
0B00082E  0000      
0B000830  E088      1466          lsr.l     #8,D0
0B000832  C0BC 0000 1467          and.l     #255,D0
0B000836  00FF      
0B000838  1C00      1468          move.b    D0,D6
                    1469   ; AddressLSB = (ChipAddress-0x10000) & 0xFF;
0B00083A  2002      1470          move.l    D2,D0
0B00083C  0480 0001 1471          sub.l     #65536,D0
0B000840  0000      
0B000842  C0BC 0000 1472          and.l     #255,D0
0B000846  00FF      
0B000848  1A00      1473          move.b    D0,D5
0B00084A  6008      1474          bra.s     ReadI2CSequential_2
                    1475   ReadI2CSequential_1:
                    1476   ; }else{
                    1477   ; controleWriteByte = EEPROM_Write_Block_0;
0B00084C  183C 00A0 1478          move.b    #160,D4
                    1479   ; controlReadByte = EEPROM_Read_Block_0;
0B000850  163C 00A1 1480          move.b    #161,D3
                    1481   ReadI2CSequential_2:
                    1482   ; }
                    1483   ; WaitTIP();
0B000854  4E92      1484          jsr       (A2)
                    1485   ; I2C_TX = controleWriteByte;
0B000856  13C4 0040 1486          move.b    D4,4227078
0B00085A  8006      
                    1487   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
0B00085C  13FC 0091 1488          move.b    #145,4227080
0B000860  0040 8008 
                    1489   ; WaitTIP();
0B000864  4E92      1490          jsr       (A2)
                    1491   ; WaitACK();
0B000866  4E93      1492          jsr       (A3)
                    1493   ; I2C_TX = AddressMSB;
0B000868  13C6 0040 1494          move.b    D6,4227078
0B00086C  8006      
                    1495   ; I2C_CMD = I2C_CMD_Slave_Write;
0B00086E  13FC 0011 1496          move.b    #17,4227080
0B000872  0040 8008 
                    1497   ; WaitTIP();
0B000876  4E92      1498          jsr       (A2)
                    1499   ; WaitACK();
0B000878  4E93      1500          jsr       (A3)
                    1501   ; I2C_TX = AddressLSB;
0B00087A  13C5 0040 1502          move.b    D5,4227078
0B00087E  8006      
                    1503   ; I2C_CMD = I2C_CMD_Slave_Write;
0B000880  13FC 0011 1504          move.b    #17,4227080
0B000884  0040 8008 
                    1505   ; WaitTIP();
0B000888  4E92      1506          jsr       (A2)
                    1507   ; WaitACK();
0B00088A  4E93      1508          jsr       (A3)
                    1509   ; I2C_TX = controlReadByte;
0B00088C  13C3 0040 1510          move.b    D3,4227078
0B000890  8006      
                    1511   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
0B000892  13FC 0091 1512          move.b    #145,4227080
0B000896  0040 8008 
                    1513   ; WaitTIP();
0B00089A  4E92      1514          jsr       (A2)
                    1515   ; WaitACK();
0B00089C  4E93      1516          jsr       (A3)
                    1517   ; block_address = ChipAddress;
0B00089E  2E02      1518          move.l    D2,D7
                    1519   ; for (i = 0; i < size; i++){
0B0008A0  3A7C 0000 1520          move.w    #0,A5
                    1521   ReadI2CSequential_3:
0B0008A4  200D      1522          move.l    A5,D0
0B0008A6  B0AE FFFC 1523          cmp.l     -4(A6),D0
0B0008AA  6C00 00E2 1524          bge       ReadI2CSequential_5
                    1525   ; if(block_address == 0x10000){ // if need to switch blocks 
0B0008AE  0C87 0001 1526          cmp.l     #65536,D7
0B0008B2  0000      
0B0008B4  6624      1527          bne.s     ReadI2CSequential_6
                    1528   ; I2C_CMD = I2C_CMD_Slave_Read_Ack;
0B0008B6  13FC 0029 1529          move.b    #41,4227080
0B0008BA  0040 8008 
                    1530   ; WaitTIP();
0B0008BE  4E92      1531          jsr       (A2)
                    1532   ; while(I2C_STAT & 0x01 == 0x00);
                    1533   ; readData = I2C_RX;
0B0008C0  1D79 0040 1534          move.b    4227078,-5(A6)
0B0008C4  8006 FFFB 
                    1535   ; I2C_CMD = I2C_CMD_Slave_Read_Stop; // instead of sending a stop command
0B0008C8  13FC 0049 1536          move.b    #73,4227080
0B0008CC  0040 8008 
                    1537   ; // printf("\r\nADDR: %x, DATA: %x\r\n",ChipAddress,readData);
                    1538   ; WaitTIP();
0B0008D0  4E92      1539          jsr       (A2)
                    1540   ; block_change_flag = 1;
0B0008D2  387C 0001 1541          move.w    #1,A4
0B0008D6  6000 004E 1542          bra       ReadI2CSequential_7
                    1543   ReadI2CSequential_6:
                    1544   ; } else {
                    1545   ; I2C_CMD = I2C_CMD_Slave_Read;
0B0008DA  13FC 0021 1546          move.b    #33,4227080
0B0008DE  0040 8008 
                    1547   ; WaitTIP();
0B0008E2  4E92      1548          jsr       (A2)
                    1549   ; while((I2C_STAT & 0x01) != 0x01) {
                    1550   ReadI2CSequential_11:
0B0008E4  1039 0040 1551          move.b    4227080,D0
0B0008E8  8008      
0B0008EA  C03C 0001 1552          and.b     #1,D0
0B0008EE  0C00 0001 1553          cmp.b     #1,D0
0B0008F2  6702      1554          beq.s     ReadI2CSequential_13
                    1555   ; }
0B0008F4  60EE      1556          bra       ReadI2CSequential_11
                    1557   ReadI2CSequential_13:
                    1558   ; I2C_STAT = 0;
0B0008F6  4239 0040 1559          clr.b     4227080
0B0008FA  8008      
                    1560   ; readData = I2C_RX;
0B0008FC  1D79 0040 1561          move.b    4227078,-5(A6)
0B000900  8006 FFFB 
                    1562   ; printf("\r\nRead [%x] from Address[%x]", readData, ChipAddress);
0B000904  2F02      1563          move.l    D2,-(A7)
0B000906  122E FFFB 1564          move.b    -5(A6),D1
0B00090A  C2BC 0000 1565          and.l     #255,D1
0B00090E  00FF      
0B000910  2F01      1566          move.l    D1,-(A7)
0B000912  4879 0B00 1567          pea       @mup_3.L
0B000916  1B12      
0B000918  4EB9 0B00 1568          jsr       _printf
0B00091C  110A      
0B00091E  DEFC 000C 1569          add.w     #12,A7
                    1570   ; ChipAddress++;
0B000922  5282      1571          addq.l    #1,D2
                    1572   ; block_address++;
0B000924  5287      1573          addq.l    #1,D7
                    1574   ReadI2CSequential_7:
                    1575   ; }
                    1576   ; if (block_change_flag) {
0B000926  200C      1577          move.l    A4,D0
0B000928  6700 005E 1578          beq       ReadI2CSequential_14
                    1579   ; controleWriteByte = EEPROM_Write_Block_1;
0B00092C  183C 00A2 1580          move.b    #162,D4
                    1581   ; controlReadByte = EEPROM_Read_Block_1;
0B000930  163C 00A3 1582          move.b    #163,D3
                    1583   ; AddressMSB = 0;
0B000934  4206      1584          clr.b     D6
                    1585   ; AddressLSB = 0;
0B000936  4205      1586          clr.b     D5
                    1587   ; WaitTIP();
0B000938  4E92      1588          jsr       (A2)
                    1589   ; I2C_TX = controleWriteByte;
0B00093A  13C4 0040 1590          move.b    D4,4227078
0B00093E  8006      
                    1591   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
0B000940  13FC 0091 1592          move.b    #145,4227080
0B000944  0040 8008 
                    1593   ; WaitTIP();
0B000948  4E92      1594          jsr       (A2)
                    1595   ; WaitACK();
0B00094A  4E93      1596          jsr       (A3)
                    1597   ; I2C_TX = AddressMSB;
0B00094C  13C6 0040 1598          move.b    D6,4227078
0B000950  8006      
                    1599   ; I2C_CMD = I2C_CMD_Slave_Write;
0B000952  13FC 0011 1600          move.b    #17,4227080
0B000956  0040 8008 
                    1601   ; WaitTIP();
0B00095A  4E92      1602          jsr       (A2)
                    1603   ; WaitACK();
0B00095C  4E93      1604          jsr       (A3)
                    1605   ; I2C_TX = AddressLSB;
0B00095E  13C5 0040 1606          move.b    D5,4227078
0B000962  8006      
                    1607   ; I2C_CMD = I2C_CMD_Slave_Write;
0B000964  13FC 0011 1608          move.b    #17,4227080
0B000968  0040 8008 
                    1609   ; WaitTIP();
0B00096C  4E92      1610          jsr       (A2)
                    1611   ; WaitACK();
0B00096E  4E93      1612          jsr       (A3)
                    1613   ; I2C_TX = controlReadByte;
0B000970  13C3 0040 1614          move.b    D3,4227078
0B000974  8006      
                    1615   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
0B000976  13FC 0091 1616          move.b    #145,4227080
0B00097A  0040 8008 
                    1617   ; WaitTIP();
0B00097E  4E92      1618          jsr       (A2)
                    1619   ; WaitACK();
0B000980  4E93      1620          jsr       (A3)
                    1621   ; block_change_flag = 0;
0B000982  387C 0000 1622          move.w    #0,A4
                    1623   ; block_address = 0;
0B000986  7E00      1624          moveq     #0,D7
                    1625   ReadI2CSequential_14:
0B000988  524D      1626          addq.w    #1,A5
0B00098A  6000 FF18 1627          bra       ReadI2CSequential_3
                    1628   ReadI2CSequential_5:
                    1629   ; }
                    1630   ; }
                    1631   ; I2C_CMD = I2C_CMD_Slave_Read_Ack;
0B00098E  13FC 0029 1632          move.b    #41,4227080
0B000992  0040 8008 
                    1633   ; WaitTIP();
0B000996  4E92      1634          jsr       (A2)
                    1635   ; while(I2C_STAT & 0x01 == 0x00);
                    1636   ; I2C_CMD = I2C_CMD_Slave_Read_Stop;
0B000998  13FC 0049 1637          move.b    #73,4227080
0B00099C  0040 8008 
                    1638   ; printf("\r\nBlock Read operation complete\r\n");
0B0009A0  4879 0B00 1639          pea       @mup_4.L
0B0009A4  1B30      
0B0009A6  4EB9 0B00 1640          jsr       _printf
0B0009AA  110A      
0B0009AC  584F      1641          addq.w    #4,A7
                    1642   ; return;
0B0009AE  4CDF 3CFC 1643          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
0B0009B2  4E5E      1644          unlk      A6
0B0009B4  4E75      1645          rts
                    1646   ; }
                    1647   ; ///////////////////////////////////////////////
                    1648   ; // generate a waveform (square wave) via DAC //
                    1649   ; ///////////////////////////////////////////////
                    1650   ; void DACWrite(void) {
                    1651   _DACWrite:
0B0009B6  48E7 3830 1652          movem.l   D2/D3/D4/A2/A3,-(A7)
0B0009BA  45F9 0B00 1653          lea       _WaitTIP.L,A2
0B0009BE  034A      
0B0009C0  47F9 0B00 1654          lea       _WaitACK.L,A3
0B0009C4  0370      
                    1655   ; int i;
                    1656   ; unsigned int delay = 0xFFFFF;
0B0009C6  283C 000F 1657          move.l    #1048575,D4
0B0009CA  FFFF      
                    1658   ; printf("\nI2C DAC Write: Please check LED\n");
0B0009CC  4879 0B00 1659          pea       @mup_5.L
0B0009D0  1B52      
0B0009D2  4EB9 0B00 1660          jsr       _printf
0B0009D6  110A      
0B0009D8  584F      1661          addq.w    #4,A7
                    1662   ; WaitTIP();
0B0009DA  4E92      1663          jsr       (A2)
                    1664   ; I2C_TX = ADC_DAC_Write_Address;
0B0009DC  13FC 0090 1665          move.b    #144,4227078
0B0009E0  0040 8006 
                    1666   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
0B0009E4  13FC 0091 1667          move.b    #145,4227080
0B0009E8  0040 8008 
                    1668   ; WaitTIP();
0B0009EC  4E92      1669          jsr       (A2)
                    1670   ; WaitACK();
0B0009EE  4E93      1671          jsr       (A3)
                    1672   ; I2C_TX = DAC_CMD_Enable;
0B0009F0  13FC 0040 1673          move.b    #64,4227078
0B0009F4  0040 8006 
                    1674   ; I2C_CMD = I2C_CMD_Slave_Write;
0B0009F8  13FC 0011 1675          move.b    #17,4227080
0B0009FC  0040 8008 
                    1676   ; WaitTIP();
0B000A00  4E92      1677          jsr       (A2)
                    1678   ; WaitACK();
0B000A02  4E93      1679          jsr       (A3)
                    1680   ; I2C_TX = 0xFF; 
0B000A04  13FC 00FF 1681          move.b    #255,4227078
0B000A08  0040 8006 
                    1682   ; I2C_CMD = I2C_CMD_Slave_Write;
0B000A0C  13FC 0011 1683          move.b    #17,4227080
0B000A10  0040 8008 
                    1684   ; WaitTIP();
0B000A14  4E92      1685          jsr       (A2)
                    1686   ; WaitACK();
0B000A16  4E93      1687          jsr       (A3)
                    1688   ; while(1) { // keep blinking the LED
                    1689   DACWrite_1:
                    1690   ; unsigned int val = 0xFF; // digital high
0B000A18  263C 0000 1691          move.l    #255,D3
0B000A1C  00FF      
                    1692   ; I2C_TX = val; 
0B000A1E  13C3 0040 1693          move.b    D3,4227078
0B000A22  8006      
                    1694   ; I2C_CMD = I2C_CMD_Slave_Write;
0B000A24  13FC 0011 1695          move.b    #17,4227080
0B000A28  0040 8008 
                    1696   ; WaitTIP();
0B000A2C  4E92      1697          jsr       (A2)
                    1698   ; WaitACK();
0B000A2E  4E93      1699          jsr       (A3)
                    1700   ; for(i = 0; i < delay; i++);
0B000A30  4282      1701          clr.l     D2
                    1702   DACWrite_4:
0B000A32  B484      1703          cmp.l     D4,D2
0B000A34  6404      1704          bhs.s     DACWrite_6
0B000A36  5282      1705          addq.l    #1,D2
0B000A38  60F8      1706          bra       DACWrite_4
                    1707   DACWrite_6:
                    1708   ; val = 0x00; // digital low
0B000A3A  4283      1709          clr.l     D3
                    1710   ; I2C_TX = val;
0B000A3C  13C3 0040 1711          move.b    D3,4227078
0B000A40  8006      
                    1712   ; I2C_CMD = I2C_CMD_Slave_Write;
0B000A42  13FC 0011 1713          move.b    #17,4227080
0B000A46  0040 8008 
                    1714   ; WaitTIP();
0B000A4A  4E92      1715          jsr       (A2)
                    1716   ; WaitACK();
0B000A4C  4E93      1717          jsr       (A3)
                    1718   ; for(i = 0; i < delay; i++);
0B000A4E  4282      1719          clr.l     D2
                    1720   DACWrite_7:
0B000A50  B484      1721          cmp.l     D4,D2
0B000A52  6404      1722          bhs.s     DACWrite_9
0B000A54  5282      1723          addq.l    #1,D2
0B000A56  60F8      1724          bra       DACWrite_7
                    1725   DACWrite_9:
0B000A58  60BE      1726          bra       DACWrite_1
                    1727   ; }
                    1728   ; }
                    1729   ; ///////////////////////////////////////////////
                    1730   ; // generate a waveform (square wave) via DAC //
                    1731   ; ///////////////////////////////////////////////
                    1732   ; char ADCRead(int arg){
                    1733   _ADCRead:
0B000A5A  4E56 FFFC 1734          link      A6,#-4
0B000A5E  48E7 3E38 1735          movem.l   D2/D3/D4/D5/D6/A2/A3/A4,-(A7)
0B000A62  45F9 0B00 1736          lea       _WaitTIP.L,A2
0B000A66  034A      
0B000A68  47F9 0B00 1737          lea       _printf.L,A3
0B000A6C  110A      
0B000A6E  262E 0008 1738          move.l    8(A6),D3
0B000A72  49F9 0B00 1739          lea       _WaitACK.L,A4
0B000A76  0370      
                    1740   ; unsigned char thermistor_value;
                    1741   ; unsigned char potentiometer_value;
                    1742   ; unsigned char photo_resistor_value;
                    1743   ; unsigned int delay = 0xFFFFF;
0B000A78  2D7C 000F 1744          move.l    #1048575,-4(A6)
0B000A7C  FFFF FFFC 
                    1745   ; unsigned char result;
                    1746   ; printf("I2C ADC Read:\n");
0B000A80  4879 0B00 1747          pea       @mup_6.L
0B000A84  1B74      
0B000A86  4E93      1748          jsr       (A3)
0B000A88  584F      1749          addq.w    #4,A7
                    1750   ; printf("\n==============================Measuring==============================\n");
0B000A8A  4879 0B00 1751          pea       @mup_7.L
0B000A8E  1B84      
0B000A90  4E93      1752          jsr       (A3)
0B000A92  584F      1753          addq.w    #4,A7
                    1754   ; WaitTIP();
0B000A94  4E92      1755          jsr       (A2)
                    1756   ; I2C_TX = ADC_DAC_Write_Address;
0B000A96  13FC 0090 1757          move.b    #144,4227078
0B000A9A  0040 8006 
                    1758   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
0B000A9E  13FC 0091 1759          move.b    #145,4227080
0B000AA2  0040 8008 
                    1760   ; WaitTIP();
0B000AA6  4E92      1761          jsr       (A2)
                    1762   ; WaitACK();
0B000AA8  4E94      1763          jsr       (A4)
                    1764   ; I2C_TX = ADC_CMD_Enable;
0B000AAA  13FC 0044 1765          move.b    #68,4227078
0B000AAE  0040 8006 
                    1766   ; I2C_CMD = I2C_CMD_Slave_Write;
0B000AB2  13FC 0011 1767          move.b    #17,4227080
0B000AB6  0040 8008 
                    1768   ; WaitTIP();
0B000ABA  4E92      1769          jsr       (A2)
                    1770   ; WaitACK();
0B000ABC  4E94      1771          jsr       (A4)
                    1772   ; I2C_TX = ADC_Read_Address;
0B000ABE  13FC 0091 1773          move.b    #145,4227078
0B000AC2  0040 8006 
                    1774   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
0B000AC6  13FC 0091 1775          move.b    #145,4227080
0B000ACA  0040 8008 
                    1776   ; WaitTIP();
0B000ACE  4E92      1777          jsr       (A2)
                    1778   ; WaitACK();
0B000AD0  4E94      1779          jsr       (A4)
                    1780   ; I2C_CMD = I2C_CMD_Slave_Read;
0B000AD2  13FC 0021 1781          move.b    #33,4227080
0B000AD6  0040 8008 
                    1782   ; WaitTIP();
0B000ADA  4E92      1783          jsr       (A2)
                    1784   ; // measure thermistor 
                    1785   ; I2C_CMD = I2C_CMD_Slave_Read;
0B000ADC  13FC 0021 1786          move.b    #33,4227080
0B000AE0  0040 8008 
                    1787   ; WaitTIP();
0B000AE4  4E92      1788          jsr       (A2)
                    1789   ; thermistor_value = I2C_RX;
0B000AE6  1C39 0040 1790          move.b    4227078,D6
0B000AEA  8006      
                    1791   ; // measure potentiometer 
                    1792   ; I2C_CMD = I2C_CMD_Slave_Read;
0B000AEC  13FC 0021 1793          move.b    #33,4227080
0B000AF0  0040 8008 
                    1794   ; WaitTIP();
0B000AF4  4E92      1795          jsr       (A2)
                    1796   ; potentiometer_value = I2C_RX;
0B000AF6  1A39 0040 1797          move.b    4227078,D5
0B000AFA  8006      
                    1798   ; // measure photo resistor 
                    1799   ; I2C_CMD = I2C_CMD_Slave_Read;
0B000AFC  13FC 0021 1800          move.b    #33,4227080
0B000B00  0040 8008 
                    1801   ; WaitTIP();
0B000B04  4E92      1802          jsr       (A2)
                    1803   ; photo_resistor_value = I2C_RX;
0B000B06  1839 0040 1804          move.b    4227078,D4
0B000B0A  8006      
                    1805   ; result = 0;
0B000B0C  4202      1806          clr.b     D2
                    1807   ; if (arg == 0) {
0B000B0E  4A83      1808          tst.l     D3
0B000B10  6618      1809          bne.s     ADCRead_1
                    1810   ; printf("Value of Thermistor: %d\n", thermistor_value);
0B000B12  CCBC 0000 1811          and.l     #255,D6
0B000B16  00FF      
0B000B18  2F06      1812          move.l    D6,-(A7)
0B000B1A  4879 0B00 1813          pea       @mup_8.L
0B000B1E  1BCC      
0B000B20  4E93      1814          jsr       (A3)
0B000B22  504F      1815          addq.w    #8,A7
                    1816   ; result = thermistor_value;
0B000B24  1406      1817          move.b    D6,D2
0B000B26  6000 0070 1818          bra       ADCRead_7
                    1819   ADCRead_1:
                    1820   ; } else if (arg == 1) {
0B000B2A  0C83 0000 1821          cmp.l     #1,D3
0B000B2E  0001      
0B000B30  6618      1822          bne.s     ADCRead_3
                    1823   ; printf("Value of Potentiometer: %d\n", potentiometer_value);
0B000B32  CABC 0000 1824          and.l     #255,D5
0B000B36  00FF      
0B000B38  2F05      1825          move.l    D5,-(A7)
0B000B3A  4879 0B00 1826          pea       @mup_9.L
0B000B3E  1BE6      
0B000B40  4E93      1827          jsr       (A3)
0B000B42  504F      1828          addq.w    #8,A7
                    1829   ; result = potentiometer_value;
0B000B44  1405      1830          move.b    D5,D2
0B000B46  6000 0050 1831          bra       ADCRead_7
                    1832   ADCRead_3:
                    1833   ; } else if (arg == 2) {
0B000B4A  0C83 0000 1834          cmp.l     #2,D3
0B000B4E  0002      
0B000B50  6616      1835          bne.s     ADCRead_5
                    1836   ; printf("Value of Photo-resister: %d\n", photo_resistor_value);
0B000B52  C8BC 0000 1837          and.l     #255,D4
0B000B56  00FF      
0B000B58  2F04      1838          move.l    D4,-(A7)
0B000B5A  4879 0B00 1839          pea       @mup_10.L
0B000B5E  1C02      
0B000B60  4E93      1840          jsr       (A3)
0B000B62  504F      1841          addq.w    #8,A7
                    1842   ; result = photo_resistor_value;
0B000B64  1404      1843          move.b    D4,D2
0B000B66  6030      1844          bra.s     ADCRead_7
                    1845   ADCRead_5:
                    1846   ; } else if (arg == 3) {
0B000B68  0C83 0000 1847          cmp.l     #3,D3
0B000B6C  0003      
0B000B6E  6628      1848          bne.s     ADCRead_7
                    1849   ; printf("Value of Thermistor: %d Potentiometer: %d Photo-resister: %d\n", thermistor_value, potentiometer_value, photo_resistor_value);
0B000B70  C8BC 0000 1850          and.l     #255,D4
0B000B74  00FF      
0B000B76  2F04      1851          move.l    D4,-(A7)
0B000B78  CABC 0000 1852          and.l     #255,D5
0B000B7C  00FF      
0B000B7E  2F05      1853          move.l    D5,-(A7)
0B000B80  CCBC 0000 1854          and.l     #255,D6
0B000B84  00FF      
0B000B86  2F06      1855          move.l    D6,-(A7)
0B000B88  4879 0B00 1856          pea       @mup_11.L
0B000B8C  1C20      
0B000B8E  4E93      1857          jsr       (A3)
0B000B90  DEFC 0010 1858          add.w     #16,A7
                    1859   ; result = 0xff;
0B000B94  143C 00FF 1860          move.b    #255,D2
                    1861   ADCRead_7:
                    1862   ; } 
                    1863   ; return result;
0B000B98  1002      1864          move.b    D2,D0
0B000B9A  4CDF 1C7C 1865          movem.l   (A7)+,D2/D3/D4/D5/D6/A2/A3/A4
0B000B9E  4E5E      1866          unlk      A6
0B000BA0  4E75      1867          rts
                    1868   ; }
                    1869   ; // initialisation for Can controller 0
                    1870   ; void Init_CanBus_Controller0(void)
                    1871   ; {
                    1872   _Init_CanBus_Controller0:
                    1873   ; // TODO - put your Canbus initialisation code for CanController 0 here
                    1874   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                    1875   ; /* define interrupt priority & control (level-activated, see chapter 4.2.5) */
                    1876   ; // PX0 = PRIORITY_HIGH; /* CAN HAS A HIGH PRIORITY INTERRUPT */
                    1877   ; // IT0 = INTLEVELACT; /* set interrupt0 to level activated */
                    1878   ; // /* enable the communication interface of the SJA1000 */
                    1879   ; // CS = ENABLE_N; /* Enable the SJA1000 interface */
                    1880   ; // /* disable interrupts, if used (not necessary after power-on) */
                    1881   ; // EA = DISABLE; /* disable all interrupts */
                    1882   ; // SJAIntEn = DISABLE; /* disable external interrupt from SJA1000 */
                    1883   ; // /* set reset mode/request (Note: after power-on SJA1000 is in BasicCAN mode)
                    1884   ; // leave loop after a time out and signal an error */
                    1885   ; while ((Can0_ModeControlReg & RM_RR_Bit) == ClrByte){
                    1886   Init_CanBus_Controller0_1:
0B000BA2  1039 0050 1887          move.b    5242880,D0
0B000BA6  0000      
0B000BA8  C03C 0001 1888          and.b     #1,D0
0B000BAC  6612      1889          bne.s     Init_CanBus_Controller0_3
                    1890   ; /* other bits than the reset mode/request bit are unchanged */
                    1891   ; Can0_ModeControlReg = Can0_ModeControlReg | RM_RR_Bit;
0B000BAE  1039 0050 1892          move.b    5242880,D0
0B000BB2  0000      
0B000BB4  803C 0001 1893          or.b      #1,D0
0B000BB8  13C0 0050 1894          move.b    D0,5242880
0B000BBC  0000      
0B000BBE  60E2      1895          bra       Init_CanBus_Controller0_1
                    1896   Init_CanBus_Controller0_3:
                    1897   ; }
                    1898   ; // Set clock divide register to use pelican mode and bypass CAN input comparator (possible only in reset mode)
                    1899   ; Can0_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
0B000BC0  13FC 00C0 1900          move.b    #192,5242942
0B000BC4  0050 003E 
                    1901   ; /* disable CAN interrupts, if required (always necessary after power-on)
                    1902   ; (write to SJA1000 Interrupt Enable / Control Register) */
                    1903   ; Can0_InterruptEnReg = ClrIntEnSJA;
0B000BC8  4239 0050 1904          clr.b     5242888
0B000BCC  0008      
                    1905   ; /* define acceptance code and mask */
                    1906   ; Can0_AcceptCode0Reg = ClrByte;
0B000BCE  4239 0050 1907          clr.b     5242912
0B000BD2  0020      
                    1908   ; Can0_AcceptCode1Reg = ClrByte;
0B000BD4  4239 0050 1909          clr.b     5242914
0B000BD8  0022      
                    1910   ; Can0_AcceptCode2Reg = ClrByte;
0B000BDA  4239 0050 1911          clr.b     5242916
0B000BDE  0024      
                    1912   ; Can0_AcceptCode3Reg = ClrByte;
0B000BE0  4239 0050 1913          clr.b     5242918
0B000BE4  0026      
                    1914   ; Can0_AcceptMask0Reg = DontCare; /* every identifier is accepted */
0B000BE6  13FC 00FF 1915          move.b    #255,5242920
0B000BEA  0050 0028 
                    1916   ; Can0_AcceptMask1Reg = DontCare; /* every identifier is accepted */
0B000BEE  13FC 00FF 1917          move.b    #255,5242922
0B000BF2  0050 002A 
                    1918   ; Can0_AcceptMask2Reg = DontCare; /* every identifier is accepted */
0B000BF6  13FC 00FF 1919          move.b    #255,5242924
0B000BFA  0050 002C 
                    1920   ; Can0_AcceptMask3Reg = DontCare; /* every identifier is accepted */
0B000BFE  13FC 00FF 1921          move.b    #255,5242926
0B000C02  0050 002E 
                    1922   ; /* configure bus timing */
                    1923   ; /* bit-rate = 100 kbit/s @ 25 MHz, the bus is sampled once */
                    1924   ; Can0_BusTiming0Reg = BTR0;
0B000C06  13FC 0004 1925          move.b    #4,5242892
0B000C0A  0050 000C 
                    1926   ; Can0_BusTiming1Reg = BTR1;
0B000C0E  13FC 007F 1927          move.b    #127,5242894
0B000C12  0050 000E 
                    1928   ; /* configure CAN outputs: float on TX1, Push/Pull on TX0, normal output mode */
                    1929   ; Can0_OutControlReg = Tx0Float | Tx0PshPull | NormalMode;
0B000C16  13FC 001A 1930          move.b    #26,5242896
0B000C1A  0050 0010 
                    1931   ; // Set mode control to clr
                    1932   ; do {
                    1933   Init_CanBus_Controller0_4:
                    1934   ; Can0_ModeControlReg = ClrByte;
0B000C1E  4239 0050 1935          clr.b     5242880
0B000C22  0000      
0B000C24  1039 0050 1936          move.b    5242880,D0
0B000C28  0000      
0B000C2A  C03C 0001 1937          and.b     #1,D0
0B000C2E  66EE      1938          bne       Init_CanBus_Controller0_4
0B000C30  4E75      1939          rts
                    1940   ; } while ((Can0_ModeControlReg & RM_RR_Bit) != ClrByte);
                    1941   ; }
                    1942   ; // initialisation for Can controller 1
                    1943   ; void Init_CanBus_Controller1(void)
                    1944   ; {
                    1945   _Init_CanBus_Controller1:
                    1946   ; // TODO - put your Canbus initialisation code for CanController 1 here
                    1947   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                    1948   ; while ((Can1_ModeControlReg & RM_RR_Bit) == ClrByte){
                    1949   Init_CanBus_Controller1_1:
0B000C32  1039 0050 1950          move.b    5243392,D0
0B000C36  0200      
0B000C38  C03C 0001 1951          and.b     #1,D0
0B000C3C  6612      1952          bne.s     Init_CanBus_Controller1_3
                    1953   ; /* other bits than the reset mode/request bit are unchanged */
                    1954   ; Can1_ModeControlReg = Can1_ModeControlReg | RM_RR_Bit;
0B000C3E  1039 0050 1955          move.b    5243392,D0
0B000C42  0200      
0B000C44  803C 0001 1956          or.b      #1,D0
0B000C48  13C0 0050 1957          move.b    D0,5243392
0B000C4C  0200      
0B000C4E  60E2      1958          bra       Init_CanBus_Controller1_1
                    1959   Init_CanBus_Controller1_3:
                    1960   ; }
                    1961   ; // Set clock divide register to use pelican mode and bypass CAN input comparator (possible only in reset mode)
                    1962   ; Can1_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
0B000C50  13FC 00C0 1963          move.b    #192,5243454
0B000C54  0050 023E 
                    1964   ; /* disable CAN interrupts, if required (always necessary after power-on)
                    1965   ; (write to SJA1000 Interrupt Enable / Control Register) */
                    1966   ; Can1_InterruptEnReg = ClrIntEnSJA;
0B000C58  4239 0050 1967          clr.b     5243400
0B000C5C  0208      
                    1968   ; /* define acceptance code and mask */
                    1969   ; Can1_AcceptCode0Reg = ClrByte;
0B000C5E  4239 0050 1970          clr.b     5243424
0B000C62  0220      
                    1971   ; Can1_AcceptCode1Reg = ClrByte;
0B000C64  4239 0050 1972          clr.b     5243426
0B000C68  0222      
                    1973   ; Can1_AcceptCode2Reg = ClrByte;
0B000C6A  4239 0050 1974          clr.b     5243428
0B000C6E  0224      
                    1975   ; Can1_AcceptCode3Reg = ClrByte;
0B000C70  4239 0050 1976          clr.b     5243430
0B000C74  0226      
                    1977   ; Can1_AcceptMask0Reg = DontCare; /* every identifier is accepted */
0B000C76  13FC 00FF 1978          move.b    #255,5243432
0B000C7A  0050 0228 
                    1979   ; Can1_AcceptMask1Reg = DontCare; /* every identifier is accepted */
0B000C7E  13FC 00FF 1980          move.b    #255,5243434
0B000C82  0050 022A 
                    1981   ; Can1_AcceptMask2Reg = DontCare; /* every identifier is accepted */
0B000C86  13FC 00FF 1982          move.b    #255,5243436
0B000C8A  0050 022C 
                    1983   ; Can1_AcceptMask3Reg = DontCare; /* every identifier is accepted */
0B000C8E  13FC 00FF 1984          move.b    #255,5243438
0B000C92  0050 022E 
                    1985   ; /* configure bus timing */
                    1986   ; /* bit-rate = 100 kbit/s @ 25 MHz, the bus is sampled once */
                    1987   ; Can1_BusTiming0Reg = BTR0;
0B000C96  13FC 0004 1988          move.b    #4,5243404
0B000C9A  0050 020C 
                    1989   ; Can1_BusTiming1Reg = BTR1;
0B000C9E  13FC 007F 1990          move.b    #127,5243406
0B000CA2  0050 020E 
                    1991   ; /* configure CAN outputs: float on TX1, Push/Pull on TX0, normal output mode */
                    1992   ; Can1_OutControlReg = Tx0Float | Tx0PshPull | NormalMode;
0B000CA6  13FC 001A 1993          move.b    #26,5243408
0B000CAA  0050 0210 
                    1994   ; // Set mode control to clr
                    1995   ; do {
                    1996   Init_CanBus_Controller1_4:
                    1997   ; Can1_ModeControlReg = ClrByte;
0B000CAE  4239 0050 1998          clr.b     5243392
0B000CB2  0200      
0B000CB4  1039 0050 1999          move.b    5243392,D0
0B000CB8  0200      
0B000CBA  C03C 0001 2000          and.b     #1,D0
0B000CBE  66EE      2001          bne       Init_CanBus_Controller1_4
0B000CC0  4E75      2002          rts
                    2003   ; } while ((Can1_ModeControlReg & RM_RR_Bit) != ClrByte);
                    2004   ; }
                    2005   ; // Transmit for sending a message via Can controller 0
                    2006   ; void CanBus0_Transmit(int id, char data)
                    2007   ; {
                    2008   _CanBus0_Transmit:
0B000CC2  4E56 0000 2009          link      A6,#0
                    2010   ; // TODO - put your Canbus transmit code for CanController 0 here
                    2011   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                    2012   ; /* wait until the Transmit Buffer is released */
                    2013   ; do
                    2014   ; {
                    2015   CanBus0_Transmit_1:
                    2016   ; /* start a polling timer and run some tasks while waiting
                    2017   ; break the loop and signal an error if time too long */
                    2018   ; } while((Can0_StatusReg & TBS_Bit ) != TBS_Bit );
0B000CC6  1039 0050 2019          move.b    5242884,D0
0B000CCA  0004      
0B000CCC  C03C 0004 2020          and.b     #4,D0
0B000CD0  0C00 0004 2021          cmp.b     #4,D0
0B000CD4  66F0      2022          bne       CanBus0_Transmit_1
                    2023   ; /* Transmit Buffer is released, a message may be written into the buffer */
                    2024   ; /* in this example a Standard Frame message shall be transmitted */
                    2025   ; Can0_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
0B000CD6  13FC 0008 2026          move.b    #8,5242912
0B000CDA  0050 0020 
                    2027   ; Can0_TxBuffer1 = 0xA5; /* ID1 = A5, (1010 0101) */
0B000CDE  13FC 00A5 2028          move.b    #165,5242914
0B000CE2  0050 0022 
                    2029   ; Can0_TxBuffer2 = 0x20; /* ID2 = 20, (0010 0000) */
0B000CE6  13FC 0020 2030          move.b    #32,5242916
0B000CEA  0050 0024 
                    2031   ; Can0_TxBuffer3 = id; 
0B000CEE  202E 0008 2032          move.l    8(A6),D0
0B000CF2  13C0 0050 2033          move.b    D0,5242918
0B000CF6  0026      
                    2034   ; Can0_TxBuffer4 = data; 
0B000CF8  13EE 000F 2035          move.b    15(A6),5242920
0B000CFC  0050 0028 
                    2036   ; /* Start the transmission */
                    2037   ; Can0_CommandReg = TR_Bit ; /* Set Transmission Request bit */
0B000D00  13FC 0001 2038          move.b    #1,5242882
0B000D04  0050 0002 
0B000D08  4E5E      2039          unlk      A6
0B000D0A  4E75      2040          rts
                    2041   ; }
                    2042   ; // Transmit for sending a message via Can controller 1
                    2043   ; void CanBus1_Transmit(int id, char data)
                    2044   ; {
                    2045   _CanBus1_Transmit:
0B000D0C  4E56 0000 2046          link      A6,#0
                    2047   ; // TODO - put your Canbus transmit code for CanController 1 here
                    2048   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                    2049   ; /* wait until the Transmit Buffer is released */
                    2050   ; do
                    2051   ; {
                    2052   CanBus1_Transmit_1:
                    2053   ; /* start a polling timer and run some tasks while waiting
                    2054   ; break the loop and signal an error if time too long */
                    2055   ; } while((Can1_StatusReg & TBS_Bit ) != TBS_Bit );
0B000D10  1039 0050 2056          move.b    5243396,D0
0B000D14  0204      
0B000D16  C03C 0004 2057          and.b     #4,D0
0B000D1A  0C00 0004 2058          cmp.b     #4,D0
0B000D1E  66F0      2059          bne       CanBus1_Transmit_1
                    2060   ; /* Transmit Buffer is released, a message may be written into the buffer */
                    2061   ; /* in this example a Standard Frame message shall be transmitted */
                    2062   ; Can1_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
0B000D20  13FC 0008 2063          move.b    #8,5243424
0B000D24  0050 0220 
                    2064   ; Can1_TxBuffer1 = 0xA5; /* ID1 = A5, (1010 0101) */
0B000D28  13FC 00A5 2065          move.b    #165,5243426
0B000D2C  0050 0222 
                    2066   ; Can1_TxBuffer2 = 0x20; /* ID2 = 20, (0010 0000) */
0B000D30  13FC 0020 2067          move.b    #32,5243428
0B000D34  0050 0224 
                    2068   ; Can1_TxBuffer3 = 0x32; /* data1 = 51 */
0B000D38  13FC 0032 2069          move.b    #50,5243430
0B000D3C  0050 0226 
                    2070   ; Can1_TxBuffer4 = 0x42; /* data2 = 52*/
0B000D40  13FC 0042 2071          move.b    #66,5243432
0B000D44  0050 0228 
                    2072   ; Can1_TxBuffer10 = 0x12; /* data8 = 58 */
0B000D48  13FC 0012 2073          move.b    #18,5243444
0B000D4C  0050 0234 
                    2074   ; /* Start the transmission */
                    2075   ; Can1_CommandReg = TR_Bit ; /* Set Transmission Request bit */
0B000D50  13FC 0001 2076          move.b    #1,5243394
0B000D54  0050 0202 
0B000D58  4E5E      2077          unlk      A6
0B000D5A  4E75      2078          rts
                    2079   ; }
                    2080   ; // Receive for reading a received message via Can controller 0
                    2081   ; void CanBus0_Receive(void)
                    2082   ; {
                    2083   _CanBus0_Receive:
0B000D5C  4E56 FFF4 2084          link      A6,#-12
0B000D60  2F0A      2085          move.l    A2,-(A7)
0B000D62  45EE FFF6 2086          lea       -10(A6),A2
                    2087   ; // TODO - put your Canbus receive code for CanController 0 here
                    2088   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                    2089   ; unsigned char numArray[2];
                    2090   ; unsigned char dataArray[10];
                    2091   ; do{ }while((Can0_StatusReg & RBS_Bit) != RBS_Bit);
                    2092   CanBus0_Receive_1:
0B000D66  1039 0050 2093          move.b    5242884,D0
0B000D6A  0004      
0B000D6C  C03C 0001 2094          and.b     #1,D0
0B000D70  0C00 0001 2095          cmp.b     #1,D0
0B000D74  66F0      2096          bne       CanBus0_Receive_1
                    2097   ; numArray[0] = Can0_RxBuffer1 & 0xff;
0B000D76  1039 0050 2098          move.b    5242914,D0
0B000D7A  0022      
0B000D7C  C07C 00FF 2099          and.w     #255,D0
0B000D80  C07C 00FF 2100          and.w     #255,D0
0B000D84  1D40 FFF4 2101          move.b    D0,-12+0(A6)
                    2102   ; numArray[1] = Can0_RxBuffer2 & 0xff;
0B000D88  1039 0050 2103          move.b    5242916,D0
0B000D8C  0024      
0B000D8E  C07C 00FF 2104          and.w     #255,D0
0B000D92  C07C 00FF 2105          and.w     #255,D0
0B000D96  1D40 FFF5 2106          move.b    D0,-12+1(A6)
                    2107   ; //data bits
                    2108   ; dataArray[0] = Can0_RxBuffer3;
0B000D9A  14B9 0050 2109          move.b    5242918,(A2)
0B000D9E  0026      
                    2110   ; dataArray[1] = Can0_RxBuffer4;
0B000DA0  1579 0050 2111          move.b    5242920,1(A2)
0B000DA4  0028 0001 
                    2112   ; Can0_CommandReg = RRB_Bit;
0B000DA8  13FC 0004 2113          move.b    #4,5242882
0B000DAC  0050 0002 
                    2114   ; printf("Can0 recieve data at index 0: %d\n", dataArray[0]);
0B000DB0  1212      2115          move.b    (A2),D1
0B000DB2  C2BC 0000 2116          and.l     #255,D1
0B000DB6  00FF      
0B000DB8  2F01      2117          move.l    D1,-(A7)
0B000DBA  4879 0B00 2118          pea       @mup_12.L
0B000DBE  1C5E      
0B000DC0  4EB9 0B00 2119          jsr       _printf
0B000DC4  110A      
0B000DC6  504F      2120          addq.w    #8,A7
                    2121   ; printf("Can0 recieve data at index 1: %d\n", dataArray[1]);
0B000DC8  122A 0001 2122          move.b    1(A2),D1
0B000DCC  C2BC 0000 2123          and.l     #255,D1
0B000DD0  00FF      
0B000DD2  2F01      2124          move.l    D1,-(A7)
0B000DD4  4879 0B00 2125          pea       @mup_13.L
0B000DD8  1C80      
0B000DDA  4EB9 0B00 2126          jsr       _printf
0B000DDE  110A      
0B000DE0  504F      2127          addq.w    #8,A7
0B000DE2  245F      2128          move.l    (A7)+,A2
0B000DE4  4E5E      2129          unlk      A6
0B000DE6  4E75      2130          rts
                    2131   ; }
                    2132   ; // Receive for reading a received message via Can controller 1
                    2133   ; void CanBus1_Receive(void)
                    2134   ; {
                    2135   _CanBus1_Receive:
0B000DE8  4E56 FFF4 2136          link      A6,#-12
0B000DEC  2F0A      2137          move.l    A2,-(A7)
0B000DEE  45EE FFF6 2138          lea       -10(A6),A2
                    2139   ; // TODO - put your Canbus receive code for CanController 0 here
                    2140   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                    2141   ; unsigned char numArray[2];
                    2142   ; unsigned char dataArray[10];
                    2143   ; do{ }while((Can1_StatusReg & RBS_Bit) != RBS_Bit);
                    2144   CanBus1_Receive_1:
0B000DF2  1039 0050 2145          move.b    5243396,D0
0B000DF6  0204      
0B000DF8  C03C 0001 2146          and.b     #1,D0
0B000DFC  0C00 0001 2147          cmp.b     #1,D0
0B000E00  66F0      2148          bne       CanBus1_Receive_1
                    2149   ; numArray[0] = Can1_RxBuffer1 & 0xff;
0B000E02  1039 0050 2150          move.b    5243426,D0
0B000E06  0222      
0B000E08  C07C 00FF 2151          and.w     #255,D0
0B000E0C  C07C 00FF 2152          and.w     #255,D0
0B000E10  1D40 FFF4 2153          move.b    D0,-12+0(A6)
                    2154   ; numArray[1] = Can1_RxBuffer2 & 0xff;
0B000E14  1039 0050 2155          move.b    5243428,D0
0B000E18  0224      
0B000E1A  C07C 00FF 2156          and.w     #255,D0
0B000E1E  C07C 00FF 2157          and.w     #255,D0
0B000E22  1D40 FFF5 2158          move.b    D0,-12+1(A6)
                    2159   ; //data bits
                    2160   ; dataArray[0] = Can1_RxBuffer3;
0B000E26  14B9 0050 2161          move.b    5243430,(A2)
0B000E2A  0226      
                    2162   ; dataArray[1] = Can1_RxBuffer4;
0B000E2C  1579 0050 2163          move.b    5243432,1(A2)
0B000E30  0228 0001 
                    2164   ; Can1_CommandReg = RRB_Bit;
0B000E34  13FC 0004 2165          move.b    #4,5243394
0B000E38  0050 0202 
                    2166   ; printf("Can1 recieve data at index 0: %d\n", dataArray[0]);
0B000E3C  1212      2167          move.b    (A2),D1
0B000E3E  C2BC 0000 2168          and.l     #255,D1
0B000E42  00FF      
0B000E44  2F01      2169          move.l    D1,-(A7)
0B000E46  4879 0B00 2170          pea       @mup_14.L
0B000E4A  1CA2      
0B000E4C  4EB9 0B00 2171          jsr       _printf
0B000E50  110A      
0B000E52  504F      2172          addq.w    #8,A7
                    2173   ; printf("Can1 recieve data at index 1: %d\n", dataArray[1]);
0B000E54  122A 0001 2174          move.b    1(A2),D1
0B000E58  C2BC 0000 2175          and.l     #255,D1
0B000E5C  00FF      
0B000E5E  2F01      2176          move.l    D1,-(A7)
0B000E60  4879 0B00 2177          pea       @mup_15.L
0B000E64  1CC4      
0B000E66  4EB9 0B00 2178          jsr       _printf
0B000E6A  110A      
0B000E6C  504F      2179          addq.w    #8,A7
0B000E6E  245F      2180          move.l    (A7)+,A2
0B000E70  4E5E      2181          unlk      A6
0B000E72  4E75      2182          rts
                    2183   ; }
                    2184   ; void CanBusTest(void)
                    2185   ; {
                    2186   _CanBusTest:
0B000E74  48E7 2020 2187          movem.l   D2/A2,-(A7)
0B000E78  45F9 0B00 2188          lea       _printf.L,A2
0B000E7C  110A      
                    2189   ; int i;
                    2190   ; // initialise the two Can controllers
                    2191   ; Init_CanBus_Controller0();
0B000E7E  4EB9 0B00 2192          jsr       _Init_CanBus_Controller0
0B000E82  0BA2      
                    2193   ; Init_CanBus_Controller1();
0B000E84  4EB9 0B00 2194          jsr       _Init_CanBus_Controller1
0B000E88  0C32      
                    2195   ; printf("\r\n\r\n---- CANBUS Test ----\r\n") ;
0B000E8A  4879 0B00 2196          pea       @mup_16.L
0B000E8E  1CE6      
0B000E90  4E92      2197          jsr       (A2)
0B000E92  584F      2198          addq.w    #4,A7
                    2199   ; // simple application to alternately transmit and receive messages from each of two nodes
                    2200   ; while (1) {
                    2201   CanBusTest_1:
                    2202   ; for (i = 0; i < 500; i++) {
0B000E94  4282      2203          clr.l     D2
                    2204   CanBusTest_4:
0B000E96  0C82 0000 2205          cmp.l     #500,D2
0B000E9A  01F4      
0B000E9C  6C0A      2206          bge.s     CanBusTest_6
                    2207   ; Wait1ms();
0B000E9E  4EB9 0B00 2208          jsr       _Wait1ms
0B000EA2  0192      
0B000EA4  5282      2209          addq.l    #1,D2
0B000EA6  60EE      2210          bra       CanBusTest_4
                    2211   CanBusTest_6:
                    2212   ; }
                    2213   ; CanBus0_Transmit(1, 0x10) ;       // transmit a message via Controller 0
0B000EA8  4878 0010 2214          pea       16
0B000EAC  4878 0001 2215          pea       1
0B000EB0  4EB9 0B00 2216          jsr       _CanBus0_Transmit
0B000EB4  0CC2      
0B000EB6  504F      2217          addq.w    #8,A7
                    2218   ; CanBus1_Receive() ;        // receive a message via Controller 1 (and display it)
0B000EB8  4EB9 0B00 2219          jsr       _CanBus1_Receive
0B000EBC  0DE8      
                    2220   ; printf("\r\n") ;
0B000EBE  4879 0B00 2221          pea       @mup_17.L
0B000EC2  1D02      
0B000EC4  4E92      2222          jsr       (A2)
0B000EC6  584F      2223          addq.w    #4,A7
                    2224   ; for (i = 0; i < 500; i++) {
0B000EC8  4282      2225          clr.l     D2
                    2226   CanBusTest_7:
0B000ECA  0C82 0000 2227          cmp.l     #500,D2
0B000ECE  01F4      
0B000ED0  6C0A      2228          bge.s     CanBusTest_9
                    2229   ; Wait1ms();
0B000ED2  4EB9 0B00 2230          jsr       _Wait1ms
0B000ED6  0192      
0B000ED8  5282      2231          addq.l    #1,D2
0B000EDA  60EE      2232          bra       CanBusTest_7
                    2233   CanBusTest_9:
                    2234   ; }
                    2235   ; CanBus1_Transmit(1, 0x11) ;        // transmit a message via Controller 1
0B000EDC  4878 0011 2236          pea       17
0B000EE0  4878 0001 2237          pea       1
0B000EE4  4EB9 0B00 2238          jsr       _CanBus1_Transmit
0B000EE8  0D0C      
0B000EEA  504F      2239          addq.w    #8,A7
                    2240   ; CanBus0_Receive() ;         // receive a message via Controller 0 (and display it)
0B000EEC  4EB9 0B00 2241          jsr       _CanBus0_Receive
0B000EF0  0D5C      
                    2242   ; printf("\r\n") ;
0B000EF2  4879 0B00 2243          pea       @mup_17.L
0B000EF6  1D02      
0B000EF8  4E92      2244          jsr       (A2)
0B000EFA  584F      2245          addq.w    #4,A7
0B000EFC  6096      2246          bra       CanBusTest_1
                    2247   ; }
                    2248   ; }
                    2249   ; void main()
                    2250   ; {
                    2251   _main:
0B000EFE  4E56 FF58 2252          link      A6,#-168
0B000F02  48E7 2020 2253          movem.l   D2/A2,-(A7)
0B000F06  45F9 0B00 2254          lea       _InstallExceptionHandler.L,A2
0B000F0A  031A      
                    2255   ; unsigned int row, i=0, count=0, counter1=1;
0B000F0C  4282      2256          clr.l     D2
0B000F0E  42AE FF5C 2257          clr.l     -164(A6)
0B000F12  2D7C 0000 2258          move.l    #1,-160(A6)
0B000F16  0001 FF60 
                    2259   ; char c, text[150] ;
                    2260   ; int PassFailFlag = 1 ;
0B000F1A  2D7C 0000 2261          move.l    #1,-4(A6)
0B000F1E  0001 FFFC 
                    2262   ; i = x = y = z = PortA_Count =0;
0B000F22  42B9 0B00 2263          clr.l     _PortA_Count.L
0B000F26  1D44      
0B000F28  42B9 0B00 2264          clr.l     _z.L
0B000F2C  1D40      
0B000F2E  42B9 0B00 2265          clr.l     _y.L
0B000F32  1D3C      
0B000F34  42B9 0B00 2266          clr.l     _x.L
0B000F38  1D38      
0B000F3A  4282      2267          clr.l     D2
                    2268   ; Timer1Count = Timer2Count = Timer3Count = Timer4Count = 0;
0B000F3C  4239 0B00 2269          clr.b     _Timer4Count.L
0B000F40  1D4E      
0B000F42  4239 0B00 2270          clr.b     _Timer3Count.L
0B000F46  1D4C      
0B000F48  4239 0B00 2271          clr.b     _Timer2Count.L
0B000F4C  1D4A      
0B000F4E  4239 0B00 2272          clr.b     _Timer1Count.L
0B000F52  1D48      
                    2273   ; InstallExceptionHandler(PIA_ISR, 25) ;          // install interrupt handler for PIAs 1 and 2 on level 1 IRQ
0B000F54  4878 0019 2274          pea       25
0B000F58  4879 0B00 2275          pea       _PIA_ISR.L
0B000F5C  018C      
0B000F5E  4E92      2276          jsr       (A2)
0B000F60  504F      2277          addq.w    #8,A7
                    2278   ; InstallExceptionHandler(ACIA_ISR, 26) ;		    // install interrupt handler for ACIA on level 2 IRQ
0B000F62  4878 001A 2279          pea       26
0B000F66  4879 0B00 2280          pea       _ACIA_ISR.L
0B000F6A  018A      
0B000F6C  4E92      2281          jsr       (A2)
0B000F6E  504F      2282          addq.w    #8,A7
                    2283   ; InstallExceptionHandler(Timer_ISR, 27) ;		// install interrupt handler for Timers 1-4 on level 3 IRQ
0B000F70  4878 001B 2284          pea       27
0B000F74  4879 0B00 2285          pea       _Timer_ISR.L
0B000F78  003E      
0B000F7A  4E92      2286          jsr       (A2)
0B000F7C  504F      2287          addq.w    #8,A7
                    2288   ; InstallExceptionHandler(Key2PressISR, 28) ;	    // install interrupt handler for Key Press 2 on DE1 board for level 4 IRQ
0B000F7E  4878 001C 2289          pea       28
0B000F82  4879 0B00 2290          pea       _Key2PressISR.L
0B000F86  018E      
0B000F88  4E92      2291          jsr       (A2)
0B000F8A  504F      2292          addq.w    #8,A7
                    2293   ; InstallExceptionHandler(Key1PressISR, 29) ;	    // install interrupt handler for Key Press 1 on DE1 board for level 5 IRQ
0B000F8C  4878 001D 2294          pea       29
0B000F90  4879 0B00 2295          pea       _Key1PressISR.L
0B000F94  0190      
0B000F96  4E92      2296          jsr       (A2)
0B000F98  504F      2297          addq.w    #8,A7
                    2298   ; InstallExceptionHandler(Timer_ISR, 30);
0B000F9A  4878 001E 2299          pea       30
0B000F9E  4879 0B00 2300          pea       _Timer_ISR.L
0B000FA2  003E      
0B000FA4  4E92      2301          jsr       (A2)
0B000FA6  504F      2302          addq.w    #8,A7
                    2303   ; Timer1Data = 0x25;		// program time delay into timers 1-4
0B000FA8  13FC 0025 2304          move.b    #37,4194352
0B000FAC  0040 0030 
                    2305   ; Timer2Data = 0x20;
0B000FB0  13FC 0020 2306          move.b    #32,4194356
0B000FB4  0040 0034 
                    2307   ; Timer3Data = 0x15;
0B000FB8  13FC 0015 2308          move.b    #21,4194360
0B000FBC  0040 0038 
                    2309   ; Timer4Data = 0x25;
0B000FC0  13FC 0025 2310          move.b    #37,4194364
0B000FC4  0040 003C 
                    2311   ; Timer1Control = 3;		// write 3 to control register to Bit0 = 1 (enable interrupt from timers) 1 - 4 and allow them to count Bit 1 = 1
0B000FC8  13FC 0003 2312          move.b    #3,4194354
0B000FCC  0040 0032 
                    2313   ; Timer2Control = 3;
0B000FD0  13FC 0003 2314          move.b    #3,4194358
0B000FD4  0040 0036 
                    2315   ; Timer3Control = 3;
0B000FD8  13FC 0003 2316          move.b    #3,4194362
0B000FDC  0040 003A 
                    2317   ; Timer4Control = 3;
0B000FE0  13FC 0003 2318          move.b    #3,4194366
0B000FE4  0040 003E 
                    2319   ; Init_LCD();             // initialise the LCD display to use a parallel data interface and 2 lines of display
0B000FE8  4EB9 0B00 2320          jsr       _Init_LCD
0B000FEC  01C0      
                    2321   ; Init_RS232() ;          // initialise the RS232 port for use with hyper terminal
0B000FEE  4EB9 0B00 2322          jsr       _Init_RS232
0B000FF2  01DE      
                    2323   ; /*************************************************************************************************
                    2324   ; **  Test of scanf function
                    2325   ; *************************************************************************************************/
                    2326   ; // scanflush() ;                       // flush any text that may have been typed ahead
                    2327   ; // printf("\r\nEnter Integer: ") ;
                    2328   ; // scanf("%d", &i) ;
                    2329   ; // printf("You entered %d", i) ;
                    2330   ; // sprintf(text, "Hello CPEN 412 Student") ;
                    2331   ; // LCDLine1Message(text) ;
                    2332   ; // printf("\r\nHello CPEN 412 Student\r\nYour LEDs should be Flashing") ;
                    2333   ; // printf("\r\nYour LCD should be displaying") ;
                    2334   ; // while(1)
                    2335   ; //     ;
                    2336   ; // programs should NOT exit as there is nothing to Exit TO !!!!!!
                    2337   ; // There is no OS - just press the reset button to end program and call debug
                    2338   ; /*************************************************************************************************
                    2339   ; **  Test of SPI function
                    2340   ; *************************************************************************************************/
                    2341   ; printf("User program here \r\n");
0B000FF4  4879 0B00 2342          pea       @mup_18.L
0B000FF8  1D06      
0B000FFA  4EB9 0B00 2343          jsr       _printf
0B000FFE  110A      
0B001000  584F      2344          addq.w    #4,A7
                    2345   ; while(1) {
                    2346   main_1:
                    2347   ; CanBus1_Receive() ;        // receive a message via Controller 1 (and display it)
0B001002  4EB9 0B00 2348          jsr       _CanBus1_Receive
0B001006  0DE8      
                    2349   ; for (i = 0; i < 500; i++) {
0B001008  4282      2350          clr.l     D2
                    2351   main_4:
0B00100A  0C82 0000 2352          cmp.l     #500,D2
0B00100E  01F4      
0B001010  640A      2353          bhs.s     main_6
                    2354   ; Wait1ms();
0B001012  4EB9 0B00 2355          jsr       _Wait1ms
0B001016  0192      
0B001018  5282      2356          addq.l    #1,D2
0B00101A  60EE      2357          bra       main_4
                    2358   main_6:
                    2359   ; }
                    2360   ; printf("\r\n") ;
0B00101C  4879 0B00 2361          pea       @mup_17.L
0B001020  1D02      
0B001022  4EB9 0B00 2362          jsr       _printf
0B001026  110A      
0B001028  584F      2363          addq.w    #4,A7
0B00102A  60D6      2364          bra       main_1
                    2365   ; };
                    2366   ; }
                    2367   ULDIV:
0B00102C  4E56 0000 2368          link    A6,#0
0B001030  48E7 C000 2369          movem.l D0/D1,-(A7)
0B001034  222E 0008 2370          move.l  8(A6),D1
0B001038  202E 000C 2371          move.l  12(A6),D0
0B00103C  6036      2372          bra.s   ldiv_3
                    2373   LDIV:
0B00103E  4E56 0000 2374          link    A6,#0
0B001042  48E7 C000 2375          movem.l D0/D1,-(A7)
0B001046  222E 0008 2376          move.l  8(A6),D1
0B00104A  202E 000C 2377          move.l  12(A6),D0
0B00104E  4A80      2378          tst.l   D0
0B001050  6A0E      2379          bpl.s   ldiv_1
0B001052  4480      2380          neg.l   D0
0B001054  4A81      2381          tst.l   D1
0B001056  6A14      2382          bpl.s   ldiv_2
0B001058  4481      2383          neg.l   D1
0B00105A  612A      2384          bsr.s   dodiv
0B00105C  4481      2385          neg.l   D1
0B00105E  6016      2386          bra.s   ldiv_4
                    2387   ldiv_1:
0B001060  4A81      2388          tst.l   D1
0B001062  6A10      2389          bpl.s   ldiv_3
0B001064  4481      2390          neg.l   D1
0B001066  611E      2391          bsr.s   dodiv
0B001068  4480      2392          neg.l   D0
0B00106A  600A      2393          bra.s   ldiv_4
                    2394   ldiv_2:
0B00106C  6118      2395          bsr.s   dodiv
0B00106E  4480      2396          neg.l   D0
0B001070  4481      2397          neg.l   D1
0B001072  6002      2398          bra.s   ldiv_4
                    2399   ldiv_3:
0B001074  6110      2400          bsr.s   dodiv
                    2401   ldiv_4:
0B001076  2D40 0008 2402          move.l  D0,8(A6)
0B00107A  2D41 000C 2403          move.l  D1,12(A6)
0B00107E  4CDF 0003 2404          movem.l (A7)+,D0/D1
0B001082  4E5E      2405          unlk    A6
0B001084  4E75      2406          rts
                    2407   dodiv:
0B001086  0C81 0000 2408          cmpi.l  #$FFFF,D1
0B00108A  FFFF      
0B00108C  6236      2409          bhi.s   dodiv_2
0B00108E  0C80 0000 2410          cmpi.l  #$FFFF,D0
0B001092  FFFF      
0B001094  6210      2411          bhi.s   dodiv_1
0B001096  80C1      2412          divu    D1,D0
0B001098  2200      2413          move.l  D0,D1
0B00109A  4241      2414          clr.w   D1
0B00109C  4841      2415          swap    D1
0B00109E  0280 0000 2416          andi.l  #$FFFF,D0
0B0010A2  FFFF      
0B0010A4  4E75      2417          rts
                    2418   dodiv_1:
0B0010A6  48A7 A000 2419          movem.w D0/D2,-(A7)
0B0010AA  4240      2420          clr.w   D0
0B0010AC  4840      2421          swap    D0
0B0010AE  80C1      2422          divu    D1,D0
0B0010B0  3400      2423          move.w  D0,D2
0B0010B2  301F      2424          move.w  (A7)+,D0
0B0010B4  80C1      2425          divu    D1,D0
0B0010B6  4840      2426          swap    D0
0B0010B8  4281      2427          clr.l   D1
0B0010BA  3200      2428          move.w  D0,D1
0B0010BC  3002      2429          move.w  D2,D0
0B0010BE  4840      2430          swap    D0
0B0010C0  341F      2431          move.w  (A7)+,D2
0B0010C2  4E75      2432          rts
                    2433   dodiv_2:
0B0010C4  48E7 3800 2434          movem.l D2/D3/D4,-(A7)
0B0010C8  2401      2435          move.l  D1,D2
0B0010CA  4242      2436          clr.w   D2
0B0010CC  4842      2437          swap    D2
0B0010CE  5282      2438          addq.l  #1,D2
0B0010D0  2600      2439          move.l  D0,D3
0B0010D2  2801      2440          move.l  D1,D4
0B0010D4  2202      2441          move.l  D2,D1
0B0010D6  61CE      2442          bsr.s   dodiv_1
0B0010D8  2204      2443          move.l  D4,D1
0B0010DA  82C2      2444          divu    D2,D1
0B0010DC  80C1      2445          divu    D1,D0
0B0010DE  0280 0000 2446          andi.l  #$FFFF,D0
0B0010E2  FFFF      
                    2447   dodiv_3:
0B0010E4  2204      2448          move.l  D4,D1
0B0010E6  2404      2449          move.l  D4,D2
0B0010E8  4842      2450          swap    D2
0B0010EA  C2C0      2451          mulu    D0,D1
0B0010EC  C4C0      2452          mulu    D0,D2
0B0010EE  4842      2453          swap    D2
0B0010F0  D282      2454          add.l   D2,D1
0B0010F2  9283      2455          sub.l   D3,D1
0B0010F4  620A      2456          bhi.s   dodiv_4
0B0010F6  4481      2457          neg.l   D1
0B0010F8  B881      2458          cmp.l   D1,D4
0B0010FA  6208      2459          bhi.s   dodiv_5
0B0010FC  5280      2460          addq.l  #1,D0
0B0010FE  60E4      2461          bra.s   dodiv_3
                    2462   dodiv_4:
0B001100  5380      2463          subq.l  #1,D0
0B001102  60E0      2464          bra.s   dodiv_3
                    2465   dodiv_5:
0B001104  4CDF 001C 2466          movem.l (A7)+,D2/D3/D4
0B001108  4E75      2467          rts
                    2468   _printf:
0B00110A  4E56 FFFC 2469          link      A6,#-4
0B00110E  48E7 2000 2470          movem.l   D2,-(A7)
0B001112  41EE 0008 2471          lea       8(A6),A0
0B001116  5848      2472          addq.w    #4,A0
0B001118  2408      2473          move.l    A0,D2
0B00111A  2F02      2474          move.l    D2,-(A7)
0B00111C  2F2E 0008 2475          move.l    8(A6),-(A7)
0B001120  42A7      2476          clr.l     -(A7)
0B001122  6100 00CA 2477          bsr       _vsprintf
0B001126  DEFC 000C 2478          add.w     #12,A7
0B00112A  2D40 FFFC 2479          move.l    D0,-4(A6)
0B00112E  4282      2480          clr.l     D2
0B001130  202E FFFC 2481          move.l    -4(A6),D0
0B001134  4CDF 0004 2482          movem.l   (A7)+,D2
0B001138  4E5E      2483          unlk      A6
0B00113A  4E75      2484          rts
                    2485   @vsprintf_copy:
0B00113C  4E56 0000 2486          link      A6,#0
0B001140  206E 0008 2487          move.l    8(A6),A0
0B001144  4A90      2488          tst.l     (A0)
0B001146  6710      2489          beq.s     @vsprintf_copy_1
0B001148  202E 000C 2490          move.l    12(A6),D0
0B00114C  206E 0008 2491          move.l    8(A6),A0
0B001150  2250      2492          move.l    (A0),A1
0B001152  5290      2493          addq.l    #1,(A0)
0B001154  1280      2494          move.b    D0,(A1)
0B001156  600A      2495          bra.s     @vsprintf_copy_2
                    2496   @vsprintf_copy_1:
0B001158  2F2E 000C 2497          move.l    12(A6),-(A7)
0B00115C  6100 08FE 2498          bsr       _putch
0B001160  584F      2499          addq.w    #4,A7
                    2500   @vsprintf_copy_2:
0B001162  4E5E      2501          unlk      A6
0B001164  4E75      2502          rts
                    2503   @vsprintf_getval:
0B001166  4E56 0000 2504          link      A6,#0
0B00116A  48E7 3000 2505          movem.l   D2/D3,-(A7)
0B00116E  242E 0008 2506          move.l    8(A6),D2
0B001172  4283      2507          clr.l     D3
0B001174  2042      2508          move.l    D2,A0
0B001176  2050      2509          move.l    (A0),A0
0B001178  1010      2510          move.b    (A0),D0
0B00117A  4880      2511          ext.w     D0
0B00117C  48C0      2512          ext.l     D0
0B00117E  0C80 0000 2513          cmp.l     #42,D0
0B001182  002A      
0B001184  6612      2514          bne.s     @vsprintf_getval_1
0B001186  206E 000C 2515          move.l    12(A6),A0
0B00118A  2250      2516          move.l    (A0),A1
0B00118C  5890      2517          addq.l    #4,(A0)
0B00118E  2611      2518          move.l    (A1),D3
0B001190  2042      2519          move.l    D2,A0
0B001192  5290      2520          addq.l    #1,(A0)
0B001194  6000 004E 2521          bra       @vsprintf_getval_5
                    2522   @vsprintf_getval_1:
0B001198  2042      2523          move.l    D2,A0
0B00119A  2050      2524          move.l    (A0),A0
0B00119C  1010      2525          move.b    (A0),D0
0B00119E  4880      2526          ext.w     D0
0B0011A0  48C0      2527          ext.l     D0
0B0011A2  0C80 0000 2528          cmp.l     #48,D0
0B0011A6  0030      
0B0011A8  6D00 003A 2529          blt       @vsprintf_getval_5
0B0011AC  2042      2530          move.l    D2,A0
0B0011AE  2050      2531          move.l    (A0),A0
0B0011B0  1010      2532          move.b    (A0),D0
0B0011B2  4880      2533          ext.w     D0
0B0011B4  48C0      2534          ext.l     D0
0B0011B6  0C80 0000 2535          cmp.l     #57,D0
0B0011BA  0039      
0B0011BC  6E26      2536          bgt.s     @vsprintf_getval_5
0B0011BE  2F03      2537          move.l    D3,-(A7)
0B0011C0  4878 000A 2538          pea       10
0B0011C4  6100 07F6 2539          bsr       LMUL
0B0011C8  2017      2540          move.l    (A7),D0
0B0011CA  504F      2541          addq.w    #8,A7
0B0011CC  2042      2542          move.l    D2,A0
0B0011CE  2250      2543          move.l    (A0),A1
0B0011D0  5290      2544          addq.l    #1,(A0)
0B0011D2  1211      2545          move.b    (A1),D1
0B0011D4  4881      2546          ext.w     D1
0B0011D6  48C1      2547          ext.l     D1
0B0011D8  D081      2548          add.l     D1,D0
0B0011DA  0480 0000 2549          sub.l     #48,D0
0B0011DE  0030      
0B0011E0  2600      2550          move.l    D0,D3
0B0011E2  60B4      2551          bra       @vsprintf_getval_1
                    2552   @vsprintf_getval_5:
0B0011E4  2003      2553          move.l    D3,D0
0B0011E6  4CDF 000C 2554          movem.l   (A7)+,D2/D3
0B0011EA  4E5E      2555          unlk      A6
0B0011EC  4E75      2556          rts
                    2557   _vsprintf:
0B0011EE  4E56 FFCC 2558          link      A6,#-52
0B0011F2  48E7 3F3C 2559          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
0B0011F6  45EE 0008 2560          lea       8(A6),A2
0B0011FA  47F9 0B00 2561          lea       @vsprintf_copy,A3
0B0011FE  113C      
0B001200  49F9 0B00 2562          lea       _ultoa,A4
0B001204  1948      
0B001206  4286      2563          clr.l     D6
                    2564   vsprintf_1:
0B001208  206E 000C 2565          move.l    12(A6),A0
0B00120C  4A10      2566          tst.b     (A0)
0B00120E  6700 0624 2567          beq       vsprintf_3
0B001212  206E 000C 2568          move.l    12(A6),A0
0B001216  1010      2569          move.b    (A0),D0
0B001218  4880      2570          ext.w     D0
0B00121A  48C0      2571          ext.l     D0
0B00121C  0C80 0000 2572          cmp.l     #37,D0
0B001220  0025      
0B001222  671C      2573          beq.s     vsprintf_4
0B001224  206E 000C 2574          move.l    12(A6),A0
0B001228  52AE 000C 2575          addq.l    #1,12(A6)
0B00122C  1210      2576          move.b    (A0),D1
0B00122E  4881      2577          ext.w     D1
0B001230  48C1      2578          ext.l     D1
0B001232  2F01      2579          move.l    D1,-(A7)
0B001234  2F0A      2580          move.l    A2,-(A7)
0B001236  4E93      2581          jsr       (A3)
0B001238  504F      2582          addq.w    #8,A7
0B00123A  5286      2583          addq.l    #1,D6
0B00123C  6000 05F2 2584          bra       vsprintf_2
                    2585   vsprintf_4:
0B001240  52AE 000C 2586          addq.l    #1,12(A6)
0B001244  422E FFD3 2587          clr.b     -45(A6)
0B001248  422E FFD2 2588          clr.b     -46(A6)
0B00124C  422E FFD0 2589          clr.b     -48(A6)
0B001250  422E FFCF 2590          clr.b     -49(A6)
0B001254  422E FFCE 2591          clr.b     -50(A6)
0B001258  422E FFCD 2592          clr.b     -51(A6)
0B00125C  42AE FFFC 2593          clr.l     -4(A6)
0B001260  7AFF      2594          moveq     #-1,D5
0B001262  41EE FFDC 2595          lea       -36(A6),A0
0B001266  2608      2596          move.l    A0,D3
0B001268  2408      2597          move.l    A0,D2
                    2598   vsprintf_6:
0B00126A  206E 000C 2599          move.l    12(A6),A0
0B00126E  1010      2600          move.b    (A0),D0
0B001270  4880      2601          ext.w     D0
0B001272  48C0      2602          ext.l     D0
0B001274  0C80 0000 2603          cmp.l     #43,D0
0B001278  002B      
0B00127A  6730      2604          beq.s     vsprintf_12
0B00127C  6E18      2605          bgt.s     vsprintf_15
0B00127E  0C80 0000 2606          cmp.l     #35,D0
0B001282  0023      
0B001284  6700 003E 2607          beq       vsprintf_14
0B001288  6E00 0046 2608          bgt       vsprintf_9
0B00128C  0C80 0000 2609          cmp.l     #32,D0
0B001290  0020      
0B001292  6724      2610          beq.s     vsprintf_13
0B001294  603A      2611          bra.s     vsprintf_9
                    2612   vsprintf_15:
0B001296  0C80 0000 2613          cmp.l     #45,D0
0B00129A  002D      
0B00129C  6702      2614          beq.s     vsprintf_11
0B00129E  6030      2615          bra.s     vsprintf_9
                    2616   vsprintf_11:
0B0012A0  1D7C 0001 2617          move.b    #1,-51(A6)
0B0012A4  FFCD      
0B0012A6  52AE 000C 2618          addq.l    #1,12(A6)
0B0012AA  6026      2619          bra.s     vsprintf_7
                    2620   vsprintf_12:
0B0012AC  1D7C 0001 2621          move.b    #1,-50(A6)
0B0012B0  FFCE      
0B0012B2  52AE 000C 2622          addq.l    #1,12(A6)
0B0012B6  601A      2623          bra.s     vsprintf_7
                    2624   vsprintf_13:
0B0012B8  1D7C 0001 2625          move.b    #1,-49(A6)
0B0012BC  FFCF      
0B0012BE  52AE 000C 2626          addq.l    #1,12(A6)
0B0012C2  600E      2627          bra.s     vsprintf_7
                    2628   vsprintf_14:
0B0012C4  1D7C 0001 2629          move.b    #1,-48(A6)
0B0012C8  FFD0      
0B0012CA  52AE 000C 2630          addq.l    #1,12(A6)
0B0012CE  6002      2631          bra.s     vsprintf_7
                    2632   vsprintf_9:
0B0012D0  6002      2633          bra.s     vsprintf_8
                    2634   vsprintf_7:
0B0012D2  6096      2635          bra       vsprintf_6
                    2636   vsprintf_8:
0B0012D4  206E 000C 2637          move.l    12(A6),A0
0B0012D8  1010      2638          move.b    (A0),D0
0B0012DA  4880      2639          ext.w     D0
0B0012DC  48C0      2640          ext.l     D0
0B0012DE  0C80 0000 2641          cmp.l     #48,D0
0B0012E2  0030      
0B0012E4  660A      2642          bne.s     vsprintf_16
0B0012E6  52AE 000C 2643          addq.l    #1,12(A6)
0B0012EA  1D7C 0001 2644          move.b    #1,-46(A6)
0B0012EE  FFD2      
                    2645   vsprintf_16:
0B0012F0  486E 0010 2646          pea       16(A6)
0B0012F4  486E 000C 2647          pea       12(A6)
0B0012F8  6100 FE6C 2648          bsr       @vsprintf_getval
0B0012FC  504F      2649          addq.w    #8,A7
0B0012FE  2A40      2650          move.l    D0,A5
0B001300  206E 000C 2651          move.l    12(A6),A0
0B001304  1010      2652          move.b    (A0),D0
0B001306  4880      2653          ext.w     D0
0B001308  48C0      2654          ext.l     D0
0B00130A  0C80 0000 2655          cmp.l     #46,D0
0B00130E  002E      
0B001310  6614      2656          bne.s     vsprintf_18
0B001312  52AE 000C 2657          addq.l    #1,12(A6)
0B001316  486E 0010 2658          pea       16(A6)
0B00131A  486E 000C 2659          pea       12(A6)
0B00131E  6100 FE46 2660          bsr       @vsprintf_getval
0B001322  504F      2661          addq.w    #8,A7
0B001324  2A00      2662          move.l    D0,D5
                    2663   vsprintf_18:
0B001326  206E 000C 2664          move.l    12(A6),A0
0B00132A  1010      2665          move.b    (A0),D0
0B00132C  4880      2666          ext.w     D0
0B00132E  48C0      2667          ext.l     D0
0B001330  0C80 0000 2668          cmp.l     #108,D0
0B001334  006C      
0B001336  660A      2669          bne.s     vsprintf_20
0B001338  52AE 000C 2670          addq.l    #1,12(A6)
0B00133C  1D7C 0001 2671          move.b    #1,-45(A6)
0B001340  FFD3      
                    2672   vsprintf_20:
0B001342  206E 000C 2673          move.l    12(A6),A0
0B001346  1010      2674          move.b    (A0),D0
0B001348  4880      2675          ext.w     D0
0B00134A  48C0      2676          ext.l     D0
0B00134C  0C80 0000 2677          cmp.l     #111,D0
0B001350  006F      
0B001352  6700 00D4 2678          beq       vsprintf_27
0B001356  6E34      2679          bgt.s     vsprintf_33
0B001358  0C80 0000 2680          cmp.l     #100,D0
0B00135C  0064      
0B00135E  6700 0054 2681          beq       vsprintf_24
0B001362  6E1C      2682          bgt.s     vsprintf_34
0B001364  0C80 0000 2683          cmp.l     #99,D0
0B001368  0063      
0B00136A  6700 012C 2684          beq       vsprintf_30
0B00136E  6E00 016A 2685          bgt       vsprintf_22
0B001372  0C80 0000 2686          cmp.l     #88,D0
0B001376  0058      
0B001378  6700 00E6 2687          beq       vsprintf_28
0B00137C  6000 015C 2688          bra       vsprintf_22
                    2689   vsprintf_34:
0B001380  0C80 0000 2690          cmp.l     #105,D0
0B001384  0069      
0B001386  672C      2691          beq.s     vsprintf_24
0B001388  6000 0150 2692          bra       vsprintf_22
                    2693   vsprintf_33:
0B00138C  0C80 0000 2694          cmp.l     #117,D0
0B001390  0075      
0B001392  6700 005C 2695          beq       vsprintf_26
0B001396  6E0E      2696          bgt.s     vsprintf_35
0B001398  0C80 0000 2697          cmp.l     #115,D0
0B00139C  0073      
0B00139E  6700 011C 2698          beq       vsprintf_31
0B0013A2  6000 0136 2699          bra       vsprintf_22
                    2700   vsprintf_35:
0B0013A6  0C80 0000 2701          cmp.l     #120,D0
0B0013AA  0078      
0B0013AC  6700 00B2 2702          beq       vsprintf_28
0B0013B0  6000 0128 2703          bra       vsprintf_22
                    2704   vsprintf_24:
0B0013B4  4A2E FFD3 2705          tst.b     -45(A6)
0B0013B8  671A      2706          beq.s     vsprintf_36
0B0013BA  4878 000A 2707          pea       10
0B0013BE  2F03      2708          move.l    D3,-(A7)
0B0013C0  206E 0010 2709          move.l    16(A6),A0
0B0013C4  58AE 0010 2710          addq.l    #4,16(A6)
0B0013C8  2F10      2711          move.l    (A0),-(A7)
0B0013CA  6100 04F8 2712          bsr       _ltoa
0B0013CE  DEFC 000C 2713          add.w     #12,A7
0B0013D2  6018      2714          bra.s     vsprintf_37
                    2715   vsprintf_36:
0B0013D4  4878 000A 2716          pea       10
0B0013D8  2F03      2717          move.l    D3,-(A7)
0B0013DA  206E 0010 2718          move.l    16(A6),A0
0B0013DE  58AE 0010 2719          addq.l    #4,16(A6)
0B0013E2  2F10      2720          move.l    (A0),-(A7)
0B0013E4  6100 04DE 2721          bsr       _ltoa
0B0013E8  DEFC 000C 2722          add.w     #12,A7
                    2723   vsprintf_37:
0B0013EC  6000 00FA 2724          bra       vsprintf_23
                    2725   vsprintf_26:
0B0013F0  4A2E FFD3 2726          tst.b     -45(A6)
0B0013F4  6718      2727          beq.s     vsprintf_38
0B0013F6  4878 000A 2728          pea       10
0B0013FA  2F03      2729          move.l    D3,-(A7)
0B0013FC  206E 0010 2730          move.l    16(A6),A0
0B001400  58AE 0010 2731          addq.l    #4,16(A6)
0B001404  2F10      2732          move.l    (A0),-(A7)
0B001406  4E94      2733          jsr       (A4)
0B001408  DEFC 000C 2734          add.w     #12,A7
0B00140C  6016      2735          bra.s     vsprintf_39
                    2736   vsprintf_38:
0B00140E  4878 000A 2737          pea       10
0B001412  2F03      2738          move.l    D3,-(A7)
0B001414  206E 0010 2739          move.l    16(A6),A0
0B001418  58AE 0010 2740          addq.l    #4,16(A6)
0B00141C  2F10      2741          move.l    (A0),-(A7)
0B00141E  4E94      2742          jsr       (A4)
0B001420  DEFC 000C 2743          add.w     #12,A7
                    2744   vsprintf_39:
0B001424  6000 00C2 2745          bra       vsprintf_23
                    2746   vsprintf_27:
0B001428  4A2E FFD3 2747          tst.b     -45(A6)
0B00142C  6718      2748          beq.s     vsprintf_40
0B00142E  4878 0008 2749          pea       8
0B001432  2F03      2750          move.l    D3,-(A7)
0B001434  206E 0010 2751          move.l    16(A6),A0
0B001438  58AE 0010 2752          addq.l    #4,16(A6)
0B00143C  2F10      2753          move.l    (A0),-(A7)
0B00143E  4E94      2754          jsr       (A4)
0B001440  DEFC 000C 2755          add.w     #12,A7
0B001444  6016      2756          bra.s     vsprintf_41
                    2757   vsprintf_40:
0B001446  4878 0008 2758          pea       8
0B00144A  2F03      2759          move.l    D3,-(A7)
0B00144C  206E 0010 2760          move.l    16(A6),A0
0B001450  58AE 0010 2761          addq.l    #4,16(A6)
0B001454  2F10      2762          move.l    (A0),-(A7)
0B001456  4E94      2763          jsr       (A4)
0B001458  DEFC 000C 2764          add.w     #12,A7
                    2765   vsprintf_41:
0B00145C  6000 008A 2766          bra       vsprintf_23
                    2767   vsprintf_28:
0B001460  4A2E FFD3 2768          tst.b     -45(A6)
0B001464  6718      2769          beq.s     vsprintf_42
0B001466  4878 0010 2770          pea       16
0B00146A  2F03      2771          move.l    D3,-(A7)
0B00146C  206E 0010 2772          move.l    16(A6),A0
0B001470  58AE 0010 2773          addq.l    #4,16(A6)
0B001474  2F10      2774          move.l    (A0),-(A7)
0B001476  4E94      2775          jsr       (A4)
0B001478  DEFC 000C 2776          add.w     #12,A7
0B00147C  6016      2777          bra.s     vsprintf_43
                    2778   vsprintf_42:
0B00147E  4878 0010 2779          pea       16
0B001482  2F03      2780          move.l    D3,-(A7)
0B001484  206E 0010 2781          move.l    16(A6),A0
0B001488  58AE 0010 2782          addq.l    #4,16(A6)
0B00148C  2F10      2783          move.l    (A0),-(A7)
0B00148E  4E94      2784          jsr       (A4)
0B001490  DEFC 000C 2785          add.w     #12,A7
                    2786   vsprintf_43:
0B001494  6000 0052 2787          bra       vsprintf_23
                    2788   vsprintf_30:
0B001498  206E 0010 2789          move.l    16(A6),A0
0B00149C  58AE 0010 2790          addq.l    #4,16(A6)
0B0014A0  2010      2791          move.l    (A0),D0
0B0014A2  2042      2792          move.l    D2,A0
0B0014A4  5282      2793          addq.l    #1,D2
0B0014A6  1080      2794          move.b    D0,(A0)
0B0014A8  2042      2795          move.l    D2,A0
0B0014AA  4210      2796          clr.b     (A0)
0B0014AC  200D      2797          move.l    A5,D0
0B0014AE  6704      2798          beq.s     vsprintf_44
0B0014B0  200D      2799          move.l    A5,D0
0B0014B2  6002      2800          bra.s     vsprintf_45
                    2801   vsprintf_44:
0B0014B4  7001      2802          moveq     #1,D0
                    2803   vsprintf_45:
0B0014B6  2A00      2804          move.l    D0,D5
0B0014B8  6000 002E 2805          bra       vsprintf_23
                    2806   vsprintf_31:
0B0014BC  206E 0010 2807          move.l    16(A6),A0
0B0014C0  58AE 0010 2808          addq.l    #4,16(A6)
0B0014C4  2610      2809          move.l    (A0),D3
0B0014C6  0C85 FFFF 2810          cmp.l     #-1,D5
0B0014CA  FFFF      
0B0014CC  660A      2811          bne.s     vsprintf_46
0B0014CE  2F03      2812          move.l    D3,-(A7)
0B0014D0  6100 0578 2813          bsr       _strlen
0B0014D4  584F      2814          addq.w    #4,A7
0B0014D6  2A00      2815          move.l    D0,D5
                    2816   vsprintf_46:
0B0014D8  600E      2817          bra.s     vsprintf_23
                    2818   vsprintf_22:
0B0014DA  206E 000C 2819          move.l    12(A6),A0
0B0014DE  2242      2820          move.l    D2,A1
0B0014E0  5282      2821          addq.l    #1,D2
0B0014E2  1290      2822          move.b    (A0),(A1)
0B0014E4  2042      2823          move.l    D2,A0
0B0014E6  4210      2824          clr.b     (A0)
                    2825   vsprintf_23:
0B0014E8  2F03      2826          move.l    D3,-(A7)
0B0014EA  6100 055E 2827          bsr       _strlen
0B0014EE  584F      2828          addq.w    #4,A7
0B0014F0  1800      2829          move.b    D0,D4
0B0014F2  206E 000C 2830          move.l    12(A6),A0
0B0014F6  1010      2831          move.b    (A0),D0
0B0014F8  4880      2832          ext.w     D0
0B0014FA  48C0      2833          ext.l     D0
0B0014FC  0C80 0000 2834          cmp.l     #115,D0
0B001500  0073      
0B001502  6618      2835          bne.s     vsprintf_48
0B001504  0C85 0000 2836          cmp.l     #0,D5
0B001508  0000      
0B00150A  6D10      2837          blt.s     vsprintf_48
0B00150C  4884      2838          ext.w     D4
0B00150E  48C4      2839          ext.l     D4
0B001510  B885      2840          cmp.l     D5,D4
0B001512  6F04      2841          ble.s     vsprintf_50
0B001514  1005      2842          move.b    D5,D0
0B001516  6002      2843          bra.s     vsprintf_51
                    2844   vsprintf_50:
0B001518  1004      2845          move.b    D4,D0
                    2846   vsprintf_51:
0B00151A  1800      2847          move.b    D0,D4
                    2848   vsprintf_48:
0B00151C  206E 000C 2849          move.l    12(A6),A0
0B001520  1010      2850          move.b    (A0),D0
0B001522  4880      2851          ext.w     D0
0B001524  48C0      2852          ext.l     D0
0B001526  0C80 0000 2853          cmp.l     #88,D0
0B00152A  0058      
0B00152C  6600 0026 2854          bne       vsprintf_56
0B001530  41EE FFDC 2855          lea       -36(A6),A0
0B001534  2408      2856          move.l    A0,D2
                    2857   vsprintf_54:
0B001536  2042      2858          move.l    D2,A0
0B001538  4A10      2859          tst.b     (A0)
0B00153A  6718      2860          beq.s     vsprintf_56
0B00153C  2042      2861          move.l    D2,A0
0B00153E  1210      2862          move.b    (A0),D1
0B001540  4881      2863          ext.w     D1
0B001542  48C1      2864          ext.l     D1
0B001544  2F01      2865          move.l    D1,-(A7)
0B001546  6100 0544 2866          bsr       _toupper
0B00154A  584F      2867          addq.w    #4,A7
0B00154C  2042      2868          move.l    D2,A0
0B00154E  1080      2869          move.b    D0,(A0)
0B001550  5282      2870          addq.l    #1,D2
0B001552  60E2      2871          bra       vsprintf_54
                    2872   vsprintf_56:
0B001554  7E00      2873          moveq     #0,D7
0B001556  41EE FFD4 2874          lea       -44(A6),A0
0B00155A  2408      2875          move.l    A0,D2
0B00155C  206E 000C 2876          move.l    12(A6),A0
0B001560  1010      2877          move.b    (A0),D0
0B001562  4880      2878          ext.w     D0
0B001564  48C0      2879          ext.l     D0
0B001566  0C80 0000 2880          cmp.l     #100,D0
0B00156A  0064      
0B00156C  6714      2881          beq.s     vsprintf_59
0B00156E  206E 000C 2882          move.l    12(A6),A0
0B001572  1010      2883          move.b    (A0),D0
0B001574  4880      2884          ext.w     D0
0B001576  48C0      2885          ext.l     D0
0B001578  0C80 0000 2886          cmp.l     #105,D0
0B00157C  0069      
0B00157E  6600 0076 2887          bne       vsprintf_65
                    2888   vsprintf_59:
0B001582  4A2E FFCE 2889          tst.b     -50(A6)
0B001586  6612      2890          bne.s     vsprintf_62
0B001588  2043      2891          move.l    D3,A0
0B00158A  1010      2892          move.b    (A0),D0
0B00158C  4880      2893          ext.w     D0
0B00158E  48C0      2894          ext.l     D0
0B001590  0C80 0000 2895          cmp.l     #45,D0
0B001594  002D      
0B001596  6600 002E 2896          bne       vsprintf_60
                    2897   vsprintf_62:
0B00159A  2043      2898          move.l    D3,A0
0B00159C  1010      2899          move.b    (A0),D0
0B00159E  4880      2900          ext.w     D0
0B0015A0  48C0      2901          ext.l     D0
0B0015A2  0C80 0000 2902          cmp.l     #45,D0
0B0015A6  002D      
0B0015A8  660E      2903          bne.s     vsprintf_63
0B0015AA  2043      2904          move.l    D3,A0
0B0015AC  5283      2905          addq.l    #1,D3
0B0015AE  2242      2906          move.l    D2,A1
0B0015B0  5282      2907          addq.l    #1,D2
0B0015B2  1290      2908          move.b    (A0),(A1)
0B0015B4  5304      2909          subq.b    #1,D4
0B0015B6  6008      2910          bra.s     vsprintf_64
                    2911   vsprintf_63:
0B0015B8  2042      2912          move.l    D2,A0
0B0015BA  5282      2913          addq.l    #1,D2
0B0015BC  10BC 002B 2914          move.b    #43,(A0)
                    2915   vsprintf_64:
0B0015C0  5287      2916          addq.l    #1,D7
0B0015C2  6000 0032 2917          bra       vsprintf_65
                    2918   vsprintf_60:
0B0015C6  4A2E FFCF 2919          tst.b     -49(A6)
0B0015CA  6700 002A 2920          beq       vsprintf_65
0B0015CE  2043      2921          move.l    D3,A0
0B0015D0  1010      2922          move.b    (A0),D0
0B0015D2  4880      2923          ext.w     D0
0B0015D4  48C0      2924          ext.l     D0
0B0015D6  0C80 0000 2925          cmp.l     #45,D0
0B0015DA  002D      
0B0015DC  660E      2926          bne.s     vsprintf_67
0B0015DE  2043      2927          move.l    D3,A0
0B0015E0  5283      2928          addq.l    #1,D3
0B0015E2  2242      2929          move.l    D2,A1
0B0015E4  5282      2930          addq.l    #1,D2
0B0015E6  1290      2931          move.b    (A0),(A1)
0B0015E8  5304      2932          subq.b    #1,D4
0B0015EA  6008      2933          bra.s     vsprintf_68
                    2934   vsprintf_67:
0B0015EC  2042      2935          move.l    D2,A0
0B0015EE  5282      2936          addq.l    #1,D2
0B0015F0  10BC 0020 2937          move.b    #32,(A0)
                    2938   vsprintf_68:
0B0015F4  5287      2939          addq.l    #1,D7
                    2940   vsprintf_65:
0B0015F6  4A2E FFD0 2941          tst.b     -48(A6)
0B0015FA  6700 0066 2942          beq       vsprintf_77
0B0015FE  206E 000C 2943          move.l    12(A6),A0
0B001602  1010      2944          move.b    (A0),D0
0B001604  4880      2945          ext.w     D0
0B001606  48C0      2946          ext.l     D0
0B001608  0C80 0000 2947          cmp.l     #111,D0
0B00160C  006F      
0B00160E  671A      2948          beq.s     vsprintf_73
0B001610  6E0C      2949          bgt.s     vsprintf_76
0B001612  0C80 0000 2950          cmp.l     #88,D0
0B001616  0058      
0B001618  6710      2951          beq.s     vsprintf_73
0B00161A  6000 0046 2952          bra       vsprintf_77
                    2953   vsprintf_76:
0B00161E  0C80 0000 2954          cmp.l     #120,D0
0B001622  0078      
0B001624  6704      2955          beq.s     vsprintf_73
0B001626  6000 003A 2956          bra       vsprintf_77
                    2957   vsprintf_73:
0B00162A  2042      2958          move.l    D2,A0
0B00162C  5282      2959          addq.l    #1,D2
0B00162E  10BC 0030 2960          move.b    #48,(A0)
0B001632  5287      2961          addq.l    #1,D7
0B001634  206E 000C 2962          move.l    12(A6),A0
0B001638  1010      2963          move.b    (A0),D0
0B00163A  4880      2964          ext.w     D0
0B00163C  48C0      2965          ext.l     D0
0B00163E  0C80 0000 2966          cmp.l     #120,D0
0B001642  0078      
0B001644  6712      2967          beq.s     vsprintf_79
0B001646  206E 000C 2968          move.l    12(A6),A0
0B00164A  1010      2969          move.b    (A0),D0
0B00164C  4880      2970          ext.w     D0
0B00164E  48C0      2971          ext.l     D0
0B001650  0C80 0000 2972          cmp.l     #88,D0
0B001654  0058      
0B001656  660A      2973          bne.s     vsprintf_77
                    2974   vsprintf_79:
0B001658  2042      2975          move.l    D2,A0
0B00165A  5282      2976          addq.l    #1,D2
0B00165C  10BC 0078 2977          move.b    #120,(A0)
0B001660  5287      2978          addq.l    #1,D7
                    2979   vsprintf_77:
0B001662  2042      2980          move.l    D2,A0
0B001664  4210      2981          clr.b     (A0)
0B001666  206E 000C 2982          move.l    12(A6),A0
0B00166A  1010      2983          move.b    (A0),D0
0B00166C  4880      2984          ext.w     D0
0B00166E  48C0      2985          ext.l     D0
0B001670  0C80 0000 2986          cmp.l     #105,D0
0B001674  0069      
0B001676  6700 0076 2987          beq       vsprintf_82
0B00167A  6E42      2988          bgt.s     vsprintf_93
0B00167C  0C80 0000 2989          cmp.l     #99,D0
0B001680  0063      
0B001682  6700 0084 2990          beq       vsprintf_96
0B001686  6E1C      2991          bgt.s     vsprintf_94
0B001688  0C80 0000 2992          cmp.l     #88,D0
0B00168C  0058      
0B00168E  6700 005E 2993          beq       vsprintf_82
0B001692  6E00 0184 2994          bgt       vsprintf_80
0B001696  0C80 0000 2995          cmp.l     #69,D0
0B00169A  0045      
0B00169C  6700 0050 2996          beq       vsprintf_82
0B0016A0  6000 0176 2997          bra       vsprintf_80
                    2998   vsprintf_94:
0B0016A4  0C80 0000 2999          cmp.l     #101,D0
0B0016A8  0065      
0B0016AA  6700 0042 3000          beq       vsprintf_82
0B0016AE  6E00 0168 3001          bgt       vsprintf_80
0B0016B2  0C80 0000 3002          cmp.l     #100,D0
0B0016B6  0064      
0B0016B8  6734      3003          beq.s     vsprintf_82
0B0016BA  6000 015C 3004          bra       vsprintf_80
                    3005   vsprintf_93:
0B0016BE  0C80 0000 3006          cmp.l     #117,D0
0B0016C2  0075      
0B0016C4  6728      3007          beq.s     vsprintf_82
0B0016C6  6E1A      3008          bgt.s     vsprintf_95
0B0016C8  0C80 0000 3009          cmp.l     #115,D0
0B0016CC  0073      
0B0016CE  6700 0038 3010          beq       vsprintf_96
0B0016D2  6E00 0144 3011          bgt       vsprintf_80
0B0016D6  0C80 0000 3012          cmp.l     #111,D0
0B0016DA  006F      
0B0016DC  6710      3013          beq.s     vsprintf_82
0B0016DE  6000 0138 3014          bra       vsprintf_80
                    3015   vsprintf_95:
0B0016E2  0C80 0000 3016          cmp.l     #120,D0
0B0016E6  0078      
0B0016E8  6704      3017          beq.s     vsprintf_82
0B0016EA  6000 012C 3018          bra       vsprintf_80
                    3019   vsprintf_82:
0B0016EE  4A2E FFD2 3020          tst.b     -46(A6)
0B0016F2  6714      3021          beq.s     vsprintf_96
0B0016F4  4A2E FFCD 3022          tst.b     -51(A6)
0B0016F8  660E      3023          bne.s     vsprintf_96
0B0016FA  200D      3024          move.l    A5,D0
0B0016FC  9087      3025          sub.l     D7,D0
0B0016FE  4884      3026          ext.w     D4
0B001700  48C4      3027          ext.l     D4
0B001702  9084      3028          sub.l     D4,D0
0B001704  2D40 FFFC 3029          move.l    D0,-4(A6)
                    3030   vsprintf_96:
0B001708  202E FFFC 3031          move.l    -4(A6),D0
0B00170C  0C80 0000 3032          cmp.l     #0,D0
0B001710  0000      
0B001712  6C04      3033          bge.s     vsprintf_98
0B001714  42AE FFFC 3034          clr.l     -4(A6)
                    3035   vsprintf_98:
0B001718  4A2E FFCD 3036          tst.b     -51(A6)
0B00171C  6600 0030 3037          bne       vsprintf_104
0B001720  4884      3038          ext.w     D4
0B001722  48C4      3039          ext.l     D4
0B001724  2004      3040          move.l    D4,D0
0B001726  D0AE FFFC 3041          add.l     -4(A6),D0
0B00172A  D087      3042          add.l     D7,D0
0B00172C  1D40 FFD1 3043          move.b    D0,-47(A6)
                    3044   vsprintf_102:
0B001730  102E FFD1 3045          move.b    -47(A6),D0
0B001734  4880      3046          ext.w     D0
0B001736  48C0      3047          ext.l     D0
0B001738  220D      3048          move.l    A5,D1
0B00173A  534D      3049          subq.w    #1,A5
0B00173C  B081      3050          cmp.l     D1,D0
0B00173E  6C0E      3051          bge.s     vsprintf_104
0B001740  4878 0020 3052          pea       32
0B001744  2F0A      3053          move.l    A2,-(A7)
0B001746  4E93      3054          jsr       (A3)
0B001748  504F      3055          addq.w    #8,A7
0B00174A  5286      3056          addq.l    #1,D6
0B00174C  60E2      3057          bra       vsprintf_102
                    3058   vsprintf_104:
0B00174E  41EE FFD4 3059          lea       -44(A6),A0
0B001752  2408      3060          move.l    A0,D2
                    3061   vsprintf_105:
0B001754  2042      3062          move.l    D2,A0
0B001756  4A10      3063          tst.b     (A0)
0B001758  6716      3064          beq.s     vsprintf_107
0B00175A  2042      3065          move.l    D2,A0
0B00175C  5282      3066          addq.l    #1,D2
0B00175E  1210      3067          move.b    (A0),D1
0B001760  4881      3068          ext.w     D1
0B001762  48C1      3069          ext.l     D1
0B001764  2F01      3070          move.l    D1,-(A7)
0B001766  2F0A      3071          move.l    A2,-(A7)
0B001768  4E93      3072          jsr       (A3)
0B00176A  504F      3073          addq.w    #8,A7
0B00176C  5286      3074          addq.l    #1,D6
0B00176E  60E4      3075          bra       vsprintf_105
                    3076   vsprintf_107:
0B001770  202E FFFC 3077          move.l    -4(A6),D0
0B001774  1D40 FFD1 3078          move.b    D0,-47(A6)
                    3079   vsprintf_108:
0B001778  102E FFD1 3080          move.b    -47(A6),D0
0B00177C  532E FFD1 3081          subq.b    #1,-47(A6)
0B001780  4A00      3082          tst.b     D0
0B001782  670E      3083          beq.s     vsprintf_110
0B001784  4878 0030 3084          pea       48
0B001788  2F0A      3085          move.l    A2,-(A7)
0B00178A  4E93      3086          jsr       (A3)
0B00178C  504F      3087          addq.w    #8,A7
0B00178E  5286      3088          addq.l    #1,D6
0B001790  60E6      3089          bra       vsprintf_108
                    3090   vsprintf_110:
0B001792  2043      3091          move.l    D3,A0
0B001794  4A10      3092          tst.b     (A0)
0B001796  6700 0048 3093          beq       vsprintf_113
0B00179A  206E 000C 3094          move.l    12(A6),A0
0B00179E  1010      3095          move.b    (A0),D0
0B0017A0  4880      3096          ext.w     D0
0B0017A2  48C0      3097          ext.l     D0
0B0017A4  0C80 0000 3098          cmp.l     #115,D0
0B0017A8  0073      
0B0017AA  670C      3099          beq.s     vsprintf_116
0B0017AC  6E18      3100          bgt.s     vsprintf_119
0B0017AE  0C80 0000 3101          cmp.l     #99,D0
0B0017B2  0063      
0B0017B4  6702      3102          beq.s     vsprintf_116
0B0017B6  600E      3103          bra.s     vsprintf_119
                    3104   vsprintf_116:
0B0017B8  2005      3105          move.l    D5,D0
0B0017BA  5385      3106          subq.l    #1,D5
0B0017BC  0C80 0000 3107          cmp.l     #0,D0
0B0017C0  0000      
0B0017C2  6E02      3108          bgt.s     vsprintf_119
0B0017C4  6016      3109          bra.s     vsprintf_115
                    3110   vsprintf_119:
0B0017C6  2043      3111          move.l    D3,A0
0B0017C8  5283      3112          addq.l    #1,D3
0B0017CA  1210      3113          move.b    (A0),D1
0B0017CC  4881      3114          ext.w     D1
0B0017CE  48C1      3115          ext.l     D1
0B0017D0  2F01      3116          move.l    D1,-(A7)
0B0017D2  2F0A      3117          move.l    A2,-(A7)
0B0017D4  4E93      3118          jsr       (A3)
0B0017D6  504F      3119          addq.w    #8,A7
0B0017D8  5286      3120          addq.l    #1,D6
0B0017DA  6002      3121          bra.s     vsprintf_112
                    3122   vsprintf_115:
0B0017DC  6002      3123          bra.s     vsprintf_113
                    3124   vsprintf_112:
0B0017DE  60B2      3125          bra       vsprintf_110
                    3126   vsprintf_113:
0B0017E0  4A2E FFCD 3127          tst.b     -51(A6)
0B0017E4  6700 0030 3128          beq       vsprintf_125
0B0017E8  4884      3129          ext.w     D4
0B0017EA  48C4      3130          ext.l     D4
0B0017EC  2004      3131          move.l    D4,D0
0B0017EE  D0AE FFFC 3132          add.l     -4(A6),D0
0B0017F2  D087      3133          add.l     D7,D0
0B0017F4  1D40 FFD1 3134          move.b    D0,-47(A6)
                    3135   vsprintf_123:
0B0017F8  102E FFD1 3136          move.b    -47(A6),D0
0B0017FC  4880      3137          ext.w     D0
0B0017FE  48C0      3138          ext.l     D0
0B001800  220D      3139          move.l    A5,D1
0B001802  534D      3140          subq.w    #1,A5
0B001804  B081      3141          cmp.l     D1,D0
0B001806  6C0E      3142          bge.s     vsprintf_125
0B001808  4878 0020 3143          pea       32
0B00180C  2F0A      3144          move.l    A2,-(A7)
0B00180E  4E93      3145          jsr       (A3)
0B001810  504F      3146          addq.w    #8,A7
0B001812  5386      3147          subq.l    #1,D6
0B001814  60E2      3148          bra       vsprintf_123
                    3149   vsprintf_125:
0B001816  6014      3150          bra.s     vsprintf_81
                    3151   vsprintf_80:
0B001818  206E 000C 3152          move.l    12(A6),A0
0B00181C  1210      3153          move.b    (A0),D1
0B00181E  4881      3154          ext.w     D1
0B001820  48C1      3155          ext.l     D1
0B001822  2F01      3156          move.l    D1,-(A7)
0B001824  2F0A      3157          move.l    A2,-(A7)
0B001826  4E93      3158          jsr       (A3)
0B001828  504F      3159          addq.w    #8,A7
0B00182A  5286      3160          addq.l    #1,D6
                    3161   vsprintf_81:
0B00182C  52AE 000C 3162          addq.l    #1,12(A6)
                    3163   vsprintf_2:
0B001830  6000 F9D6 3164          bra       vsprintf_1
                    3165   vsprintf_3:
0B001834  4A92      3166          tst.l     (A2)
0B001836  6710      3167          beq.s     vsprintf_126
0B001838  4201      3168          clr.b     D1
0B00183A  C2BC 0000 3169          and.l     #255,D1
0B00183E  00FF      
0B001840  2F01      3170          move.l    D1,-(A7)
0B001842  2F0A      3171          move.l    A2,-(A7)
0B001844  4E93      3172          jsr       (A3)
0B001846  504F      3173          addq.w    #8,A7
                    3174   vsprintf_126:
0B001848  2006      3175          move.l    D6,D0
0B00184A  4CDF 3CFC 3176          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
0B00184E  4E5E      3177          unlk      A6
0B001850  4E75      3178          rts
                    3179   @itoa_convert:
0B001852  4E56 0000 3180          link      A6,#0
0B001856  48E7 3C00 3181          movem.l   D2/D3/D4/D5,-(A7)
0B00185A  242E 0008 3182          move.l    8(A6),D2
0B00185E  262E 0010 3183          move.l    16(A6),D3
0B001862  2A2E 000C 3184          move.l    12(A6),D5
0B001866  2F05      3185          move.l    D5,-(A7)
0B001868  2F03      3186          move.l    D3,-(A7)
0B00186A  6100 F7C0 3187          bsr       ULDIV
0B00186E  202F 0004 3188          move.l    4(A7),D0
0B001872  504F      3189          addq.w    #8,A7
0B001874  2800      3190          move.l    D0,D4
0B001876  BA83      3191          cmp.l     D3,D5
0B001878  651A      3192          blo.s     @itoa_convert_1
0B00187A  2F03      3193          move.l    D3,-(A7)
0B00187C  2F05      3194          move.l    D5,-(A7)
0B00187E  2F03      3195          move.l    D3,-(A7)
0B001880  6100 F7AA 3196          bsr       ULDIV
0B001884  2217      3197          move.l    (A7),D1
0B001886  504F      3198          addq.w    #8,A7
0B001888  2F01      3199          move.l    D1,-(A7)
0B00188A  2F02      3200          move.l    D2,-(A7)
0B00188C  61C4      3201          bsr       @itoa_convert
0B00188E  DEFC 000C 3202          add.w     #12,A7
0B001892  2400      3203          move.l    D0,D2
                    3204   @itoa_convert_1:
0B001894  0C84 0000 3205          cmp.l     #9,D4
0B001898  0009      
0B00189A  6E0A      3206          bgt.s     @itoa_convert_3
0B00189C  2004      3207          move.l    D4,D0
0B00189E  0680 0000 3208          add.l     #48,D0
0B0018A2  0030      
0B0018A4  600E      3209          bra.s     @itoa_convert_4
                    3210   @itoa_convert_3:
0B0018A6  2004      3211          move.l    D4,D0
0B0018A8  0680 0000 3212          add.l     #97,D0
0B0018AC  0061      
0B0018AE  0480 0000 3213          sub.l     #10,D0
0B0018B2  000A      
                    3214   @itoa_convert_4:
0B0018B4  2042      3215          move.l    D2,A0
0B0018B6  1080      3216          move.b    D0,(A0)
0B0018B8  2002      3217          move.l    D2,D0
0B0018BA  5280      3218          addq.l    #1,D0
0B0018BC  4CDF 003C 3219          movem.l   (A7)+,D2/D3/D4/D5
0B0018C0  4E5E      3220          unlk      A6
0B0018C2  4E75      3221          rts
                    3222   _ltoa:
0B0018C4  4E56 0000 3223          link      A6,#0
0B0018C8  48E7 3C00 3224          movem.l   D2/D3/D4/D5,-(A7)
0B0018CC  242E 0008 3225          move.l    8(A6),D2
0B0018D0  262E 000C 3226          move.l    12(A6),D3
0B0018D4  2A2E 0010 3227          move.l    16(A6),D5
0B0018D8  2803      3228          move.l    D3,D4
0B0018DA  0C85 0000 3229          cmp.l     #2,D5
0B0018DE  0002      
0B0018E0  6D08      3230          blt.s     ltoa_3
0B0018E2  0C85 0000 3231          cmp.l     #36,D5
0B0018E6  0024      
0B0018E8  6F06      3232          ble.s     ltoa_1
                    3233   ltoa_3:
0B0018EA  2003      3234          move.l    D3,D0
0B0018EC  6000 0052 3235          bra       ltoa_4
                    3236   ltoa_1:
0B0018F0  0C85 0000 3237          cmp.l     #10,D5
0B0018F4  000A      
0B0018F6  6600 0032 3238          bne       ltoa_5
0B0018FA  0C82 0000 3239          cmp.l     #0,D2
0B0018FE  0000      
0B001900  6C28      3240          bge.s     ltoa_5
0B001902  2002      3241          move.l    D2,D0
0B001904  4480      3242          neg.l     D0
0B001906  2400      3243          move.l    D0,D2
0B001908  0C82 0000 3244          cmp.l     #0,D2
0B00190C  0000      
0B00190E  6C12      3245          bge.s     ltoa_7
0B001910  4879 0B00 3246          pea       @itoa_1
0B001914  1D28      
0B001916  2F03      3247          move.l    D3,-(A7)
0B001918  6100 019E 3248          bsr       _strcpy
0B00191C  504F      3249          addq.w    #8,A7
0B00191E  2003      3250          move.l    D3,D0
0B001920  601E      3251          bra.s     ltoa_4
                    3252   ltoa_7:
0B001922  2044      3253          move.l    D4,A0
0B001924  5284      3254          addq.l    #1,D4
0B001926  10BC 002D 3255          move.b    #45,(A0)
                    3256   ltoa_5:
0B00192A  2F05      3257          move.l    D5,-(A7)
0B00192C  2F02      3258          move.l    D2,-(A7)
0B00192E  2F04      3259          move.l    D4,-(A7)
0B001930  6100 FF20 3260          bsr       @itoa_convert
0B001934  DEFC 000C 3261          add.w     #12,A7
0B001938  2800      3262          move.l    D0,D4
0B00193A  2044      3263          move.l    D4,A0
0B00193C  4210      3264          clr.b     (A0)
0B00193E  2003      3265          move.l    D3,D0
                    3266   ltoa_4:
0B001940  4CDF 003C 3267          movem.l   (A7)+,D2/D3/D4/D5
0B001944  4E5E      3268          unlk      A6
0B001946  4E75      3269          rts
                    3270   _ultoa:
0B001948  4E56 0000 3271          link      A6,#0
0B00194C  48E7 3800 3272          movem.l   D2/D3/D4,-(A7)
0B001950  262E 0010 3273          move.l    16(A6),D3
0B001954  282E 000C 3274          move.l    12(A6),D4
0B001958  2404      3275          move.l    D4,D2
0B00195A  0C83 0000 3276          cmp.l     #2,D3
0B00195E  0002      
0B001960  6D08      3277          blt.s     ultoa_3
0B001962  0C83 0000 3278          cmp.l     #36,D3
0B001966  0024      
0B001968  6F04      3279          ble.s     ultoa_1
                    3280   ultoa_3:
0B00196A  2004      3281          move.l    D4,D0
0B00196C  6018      3282          bra.s     ultoa_4
                    3283   ultoa_1:
0B00196E  2F03      3284          move.l    D3,-(A7)
0B001970  2F2E 0008 3285          move.l    8(A6),-(A7)
0B001974  2F02      3286          move.l    D2,-(A7)
0B001976  6100 FEDA 3287          bsr       @itoa_convert
0B00197A  DEFC 000C 3288          add.w     #12,A7
0B00197E  2400      3289          move.l    D0,D2
0B001980  2042      3290          move.l    D2,A0
0B001982  4210      3291          clr.b     (A0)
0B001984  2004      3292          move.l    D4,D0
                    3293   ultoa_4:
0B001986  4CDF 001C 3294          movem.l   (A7)+,D2/D3/D4
0B00198A  4E5E      3295          unlk      A6
0B00198C  4E75      3296          rts
                    3297   _itoa:
0B00198E  4E56 0000 3298          link      A6,#0
0B001992  2F2E 0010 3299          move.l    16(A6),-(A7)
0B001996  2F2E 000C 3300          move.l    12(A6),-(A7)
0B00199A  2F2E 0008 3301          move.l    8(A6),-(A7)
0B00199E  6100 FF24 3302          bsr       _ltoa
0B0019A2  DEFC 000C 3303          add.w     #12,A7
0B0019A6  4E5E      3304          unlk      A6
0B0019A8  4E75      3305          rts
                    3306   ULMUL:
0B0019AA  4E56 0000 3307          link    A6,#0
0B0019AE  48E7 C000 3308          movem.l D0/D1,-(A7)
0B0019B2  222E 0008 3309          move.l  8(A6),D1
0B0019B6  202E 000C 3310          move.l  12(A6),D0
0B0019BA  602C      3311          bra.s   lmul_3
                    3312   LMUL:
0B0019BC  4E56 0000 3313          link    A6,#0
0B0019C0  48E7 C000 3314          movem.l D0/D1,-(A7)
0B0019C4  222E 0008 3315          move.l  8(A6),D1
0B0019C8  202E 000C 3316          move.l  12(A6),D0
0B0019CC  4A80      3317          tst.l   D0
0B0019CE  6A0A      3318          bpl.s   lmul_1
0B0019D0  4480      3319          neg.l   D0
0B0019D2  4A81      3320          tst.l   D1
0B0019D4  6A0A      3321          bpl.s   lmul_2
0B0019D6  4481      3322          neg.l   D1
0B0019D8  600E      3323          bra.s   lmul_3
                    3324   lmul_1:
0B0019DA  4A81      3325          tst.l   D1
0B0019DC  6A0A      3326          bpl.s   lmul_3
0B0019DE  4481      3327          neg.l   D1
                    3328   lmul_2:
0B0019E0  6114      3329          bsr.s   domul
0B0019E2  4481      3330          neg.l   D1
0B0019E4  4080      3331          negx.l  D0
0B0019E6  6002      3332          bra.s   lmul_4
                    3333   lmul_3:
0B0019E8  610C      3334          bsr.s   domul
                    3335   lmul_4:
0B0019EA  2D41 0008 3336          move.l  D1,8(A6)
0B0019EE  4CDF 0003 3337          movem.l (A7)+,D0/D1
0B0019F2  4E5E      3338          unlk    A6
0B0019F4  4E75      3339          rts
                    3340   domul:
0B0019F6  0C81 0000 3341          cmpi.l  #$FFFF,D1
0B0019FA  FFFF      
0B0019FC  620C      3342          bhi.s   domul_1
0B0019FE  0C80 0000 3343          cmpi.l  #$FFFF,D0
0B001A02  FFFF      
0B001A04  620E      3344          bhi.s   domul_2
0B001A06  C2C0      3345          mulu    D0,D1
0B001A08  4E75      3346          rts
                    3347   domul_1:
0B001A0A  0C80 0000 3348          cmpi.l  #$FFFF,D0
0B001A0E  FFFF      
0B001A10  6218      3349          bhi.s   domul_4
0B001A12  6002      3350          bra.s   domul_3
                    3351   domul_2
0B001A14  C141      3352          exg     D0,D1
                    3353   domul_3:
0B001A16  2F02      3354          move.l  D2,-(A7)
0B001A18  2401      3355          move.l  D1,D2
0B001A1A  4842      3356          swap    D2
0B001A1C  C2C0      3357          mulu    D0,D1
0B001A1E  C4C0      3358          mulu    D0,D2
0B001A20  4842      3359          swap    D2
0B001A22  4242      3360          clr.w   D2
0B001A24  D282      3361          add.l   D2,D1
0B001A26  241F      3362          move.l  (A7)+,D2
0B001A28  4E75      3363          rts
                    3364   domul_4:
0B001A2A  48E7 3000 3365          movem.l D2/D3,-(A7)
0B001A2E  2401      3366          move.l  D1,D2
0B001A30  2601      3367          move.l  D1,D3
0B001A32  C2C0      3368          mulu    D0,D1
0B001A34  4842      3369          swap    D2
0B001A36  C4C0      3370          mulu    D0,D2
0B001A38  4840      3371          swap    D0
0B001A3A  C6C0      3372          mulu    D0,D3
0B001A3C  D483      3373          add.l   D3,D2
0B001A3E  4842      3374          swap    D2
0B001A40  4242      3375          clr.w   D2
0B001A42  D282      3376          add.l   D2,D1
0B001A44  4CDF 000C 3377          movem.l (A7)+,D2/D3
0B001A48  4E75      3378          rts
                    3379   _strlen:
0B001A4A  206F 0004 3380          move.l    (4,A7),A0
0B001A4E  2248      3381          move.l    A0,A1
                    3382   strlen_1:
0B001A50  4A19      3383          tst.b     (A1)+
0B001A52  66FC      3384          bne       strlen_1
0B001A54  2009      3385          move.l    A1,D0
0B001A56  9088      3386          sub.l     A0,D0
0B001A58  5380      3387          subq.l    #1,D0
0B001A5A  4E75      3388          rts
                    3389   _putch:
0B001A5C  4E56 0000 3390          link      A6,#0
0B001A60  48E7 2000 3391          movem.l   D2,-(A7)
0B001A64  242E 0008 3392          move.l    8(A6),D2
0B001A68  0C82 0000 3393          cmp.l     #10,D2
0B001A6C  000A      
0B001A6E  660A      3394          bne.s     putch_1
0B001A70  4878 000D 3395          pea       13
0B001A74  6100 E77A 3396          bsr       __putch
0B001A78  584F      3397          addq.w    #4,A7
                    3398   putch_1:
0B001A7A  2F02      3399          move.l    D2,-(A7)
0B001A7C  6100 E772 3400          bsr       __putch
0B001A80  584F      3401          addq.w    #4,A7
0B001A82  2002      3402          move.l    D2,D0
0B001A84  4CDF 0004 3403          movem.l   (A7)+,D2
0B001A88  4E5E      3404          unlk      A6
0B001A8A  4E75      3405          rts
                    3406   _toupper:
0B001A8C  4E56 0000 3407          link      A6,#0
0B001A90  48E7 2000 3408          movem.l   D2,-(A7)
0B001A94  242E 0008 3409          move.l    8(A6),D2
0B001A98  0C82 0000 3410          cmp.l     #97,D2
0B001A9C  0061      
0B001A9E  6D0E      3411          blt.s     toupper_1
0B001AA0  0C82 0000 3412          cmp.l     #122,D2
0B001AA4  007A      
0B001AA6  6E06      3413          bgt.s     toupper_1
0B001AA8  C4BC 0000 3414          and.l     #95,D2
0B001AAC  005F      
                    3415   toupper_1:
0B001AAE  2002      3416          move.l    D2,D0
0B001AB0  4CDF 0004 3417          movem.l   (A7)+,D2
0B001AB4  4E5E      3418          unlk      A6
0B001AB6  4E75      3419          rts
                    3420   _strcpy:
0B001AB8  206F 0004 3421          move.l    (4,A7),A0
0B001ABC  226F 0008 3422          move.l    (8,A7),A1
0B001AC0  2008      3423          move.l    A0,D0
                    3424   strcpy_1:
0B001AC2  10D9      3425          move.b    (A1)+,(A0)+
0B001AC4  66FC      3426          bne       strcpy_1
0B001AC6  4E75      3427          rts
                    3428          section   const
0B001AC8            3429                   align
                    3430   
                    3431   
                    3432   @mup_1:
0B001AC8  0D0A 5772 3433          dc.b      13,10,87,114,111,116,101,32,91,37,120,93,32
0B001ACC  6F74 6520 
0B001AD0  5B25 785D 
0B001AD4  20        
0B001AD5  746F 2041 3434          dc.b      116,111,32,65,100,100,114,101,115,115,91,37
0B001AD9  6464 7265 
0B001ADD  7373 5B25 
0B001AE1  785D 00   3435          dc.b      120,93,0
                    3436   @mup_2:
0B001AE4  0D0A 5772 3437          dc.b      13,10,87,114,111,116,101,32,91,37,120,93,32
0B001AE8  6F74 6520 
0B001AEC  5B25 785D 
0B001AF0  20        
0B001AF1  6672 6F6D 3438          dc.b      102,114,111,109,32,65,100,100,114,101,115,115
0B001AF5  2041 6464 
0B001AF9  7265 7373 
0B001AFD  5B25 785D 3439          dc.b      91,37,120,93,32,116,111,32,65,100,100,114,101
0B001B01  2074 6F20 
0B001B05  4164 6472 
0B001B09  65        
0B001B0A  7373 5B25 3440          dc.b      115,115,91,37,120,93,0
0B001B0E  785D 00   
                    3441   @mup_3:
0B001B12  0D0A 5265 3442          dc.b      13,10,82,101,97,100,32,91,37,120,93,32,102,114
0B001B16  6164 205B 
0B001B1A  2578 5D20 
0B001B1E  6672      
0B001B20  6F6D 2041 3443          dc.b      111,109,32,65,100,100,114,101,115,115,91,37
0B001B24  6464 7265 
0B001B28  7373 5B25 
0B001B2C  785D 00   3444          dc.b      120,93,0
                    3445   @mup_4:
0B001B30  0D0A 426C 3446          dc.b      13,10,66,108,111,99,107,32,82,101,97,100,32
0B001B34  6F63 6B20 
0B001B38  5265 6164 
0B001B3C  20        
0B001B3D  6F70 6572 3447          dc.b      111,112,101,114,97,116,105,111,110,32,99,111
0B001B41  6174 696F 
0B001B45  6E20 636F 
0B001B49  6D70 6C65 3448          dc.b      109,112,108,101,116,101,13,10,0
0B001B4D  7465 0D0A 
0B001B51  00        
                    3449   @mup_5:
0B001B52  0A49 3243 3450          dc.b      10,73,50,67,32,68,65,67,32,87,114,105,116,101
0B001B56  2044 4143 
0B001B5A  2057 7269 
0B001B5E  7465      
0B001B60  3A20 506C 3451          dc.b      58,32,80,108,101,97,115,101,32,99,104,101,99
0B001B64  6561 7365 
0B001B68  2063 6865 
0B001B6C  63        
0B001B6D  6B20 4C45 3452          dc.b      107,32,76,69,68,10,0
0B001B71  440A 00   
                    3453   @mup_6:
0B001B74  4932 4320 3454          dc.b      73,50,67,32,65,68,67,32,82,101,97,100,58,10
0B001B78  4144 4320 
0B001B7C  5265 6164 
0B001B80  3A0A      
0B001B82  00        3455          dc.b      0
                    3456   @mup_7:
0B001B84  0A3D 3D3D 3457          dc.b      10,61,61,61,61,61,61,61,61,61,61,61,61,61,61
0B001B88  3D3D 3D3D 
0B001B8C  3D3D 3D3D 
0B001B90  3D3D 3D   
0B001B93  3D3D 3D3D 3458          dc.b      61,61,61,61,61,61,61,61,61,61,61,61,61,61,61
0B001B97  3D3D 3D3D 
0B001B9B  3D3D 3D3D 
0B001B9F  3D3D 3D   
0B001BA2  3D4D 6561 3459          dc.b      61,77,101,97,115,117,114,105,110,103,61,61,61
0B001BA6  7375 7269 
0B001BAA  6E67 3D3D 
0B001BAE  3D        
0B001BAF  3D3D 3D3D 3460          dc.b      61,61,61,61,61,61,61,61,61,61,61,61,61,61,61
0B001BB3  3D3D 3D3D 
0B001BB7  3D3D 3D3D 
0B001BBB  3D3D 3D   
0B001BBE  3D3D 3D3D 3461          dc.b      61,61,61,61,61,61,61,61,61,61,61,61,10,0
0B001BC2  3D3D 3D3D 
0B001BC6  3D3D 3D3D 
0B001BCA  0A00      
                    3462   @mup_8:
0B001BCC  5661 6C75 3463          dc.b      86,97,108,117,101,32,111,102,32,84,104,101,114
0B001BD0  6520 6F66 
0B001BD4  2054 6865 
0B001BD8  72        
0B001BD9  6D69 7374 3464          dc.b      109,105,115,116,111,114,58,32,37,100,10,0
0B001BDD  6F72 3A20 
0B001BE1  2564 0A00 
                    3465   @mup_9:
0B001BE6  5661 6C75 3466          dc.b      86,97,108,117,101,32,111,102,32,80,111,116,101
0B001BEA  6520 6F66 
0B001BEE  2050 6F74 
0B001BF2  65        
0B001BF3  6E74 696F 3467          dc.b      110,116,105,111,109,101,116,101,114,58,32,37
0B001BF7  6D65 7465 
0B001BFB  723A 2025 
0B001BFF  640A 00   3468          dc.b      100,10,0
                    3469   @mup_10:
0B001C02  5661 6C75 3470          dc.b      86,97,108,117,101,32,111,102,32,80,104,111,116
0B001C06  6520 6F66 
0B001C0A  2050 686F 
0B001C0E  74        
0B001C0F  6F2D 7265 3471          dc.b      111,45,114,101,115,105,115,116,101,114,58,32
0B001C13  7369 7374 
0B001C17  6572 3A20 
0B001C1B  2564 0A00 3472          dc.b      37,100,10,0
                    3473   @mup_11:
0B001C20  5661 6C75 3474          dc.b      86,97,108,117,101,32,111,102,32,84,104,101,114
0B001C24  6520 6F66 
0B001C28  2054 6865 
0B001C2C  72        
0B001C2D  6D69 7374 3475          dc.b      109,105,115,116,111,114,58,32,37,100,32,80,111
0B001C31  6F72 3A20 
0B001C35  2564 2050 
0B001C39  6F        
0B001C3A  7465 6E74 3476          dc.b      116,101,110,116,105,111,109,101,116,101,114
0B001C3E  696F 6D65 
0B001C42  7465 72   
0B001C45  3A20 2564 3477          dc.b      58,32,37,100,32,80,104,111,116,111,45,114,101
0B001C49  2050 686F 
0B001C4D  746F 2D72 
0B001C51  65        
0B001C52  7369 7374 3478          dc.b      115,105,115,116,101,114,58,32,37,100,10,0
0B001C56  6572 3A20 
0B001C5A  2564 0A00 
                    3479   @mup_12:
0B001C5E  4361 6E30 3480          dc.b      67,97,110,48,32,114,101,99,105,101,118,101,32
0B001C62  2072 6563 
0B001C66  6965 7665 
0B001C6A  20        
0B001C6B  6461 7461 3481          dc.b      100,97,116,97,32,97,116,32,105,110,100,101,120
0B001C6F  2061 7420 
0B001C73  696E 6465 
0B001C77  78        
0B001C78  2030 3A20 3482          dc.b      32,48,58,32,37,100,10,0
0B001C7C  2564 0A00 
                    3483   @mup_13:
0B001C80  4361 6E30 3484          dc.b      67,97,110,48,32,114,101,99,105,101,118,101,32
0B001C84  2072 6563 
0B001C88  6965 7665 
0B001C8C  20        
0B001C8D  6461 7461 3485          dc.b      100,97,116,97,32,97,116,32,105,110,100,101,120
0B001C91  2061 7420 
0B001C95  696E 6465 
0B001C99  78        
0B001C9A  2031 3A20 3486          dc.b      32,49,58,32,37,100,10,0
0B001C9E  2564 0A00 
                    3487   @mup_14:
0B001CA2  4361 6E31 3488          dc.b      67,97,110,49,32,114,101,99,105,101,118,101,32
0B001CA6  2072 6563 
0B001CAA  6965 7665 
0B001CAE  20        
0B001CAF  6461 7461 3489          dc.b      100,97,116,97,32,97,116,32,105,110,100,101,120
0B001CB3  2061 7420 
0B001CB7  696E 6465 
0B001CBB  78        
0B001CBC  2030 3A20 3490          dc.b      32,48,58,32,37,100,10,0
0B001CC0  2564 0A00 
                    3491   @mup_15:
0B001CC4  4361 6E31 3492          dc.b      67,97,110,49,32,114,101,99,105,101,118,101,32
0B001CC8  2072 6563 
0B001CCC  6965 7665 
0B001CD0  20        
0B001CD1  6461 7461 3493          dc.b      100,97,116,97,32,97,116,32,105,110,100,101,120
0B001CD5  2061 7420 
0B001CD9  696E 6465 
0B001CDD  78        
0B001CDE  2031 3A20 3494          dc.b      32,49,58,32,37,100,10,0
0B001CE2  2564 0A00 
                    3495   @mup_16:
0B001CE6  0D0A 0D0A 3496          dc.b      13,10,13,10,45,45,45,45,32,67,65,78,66,85,83
0B001CEA  2D2D 2D2D 
0B001CEE  2043 414E 
0B001CF2  4255 53   
0B001CF5  2054 6573 3497          dc.b      32,84,101,115,116,32,45,45,45,45,13,10,0
0B001CF9  7420 2D2D 
0B001CFD  2D2D 0D0A 
0B001D01  00        
                    3498   @mup_17:
0B001D02  0D0A 00   3499          dc.b      13,10,0
                    3500   @mup_18:
0B001D06  5573 6572 3501          dc.b      85,115,101,114,32,112,114,111,103,114,97,109
0B001D0A  2070 726F 
0B001D0E  6772 616D 
0B001D12  2068 6572 3502          dc.b      32,104,101,114,101,32,13,10,0
0B001D16  6520 0D0A 
0B001D1A  00        
                    3503          section   data
0B001D1C            3504                   align
                    3505   
                    3506   *********************************************************************************************************************************************************
                    3507   * Section for Initialised Data (in theory should be copied to Ram at startup) but is part of program code as we copy whole program to ram at startup
                    3508   ********************************************************************************************************************************************************
                    3509   
          0B00 1D1C 3510   DataStart       equ       *
0B001D1C            3511   __ungetbuf:     ds.l      1                    ungetbuffer for stdio functions
0B001D20            3512   __allocp:       ds.l      1                    start of free memory block list
0B001D24            3513   __heap:         ds.l      1                    begin of free memory
                    3514   
                    3515   
                    3516   @itoa_1:
0B001D28  2D32 3134 3517          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
0B001D2C  3734 3833 
0B001D30  3634 3800 
                    3518          section   bss
0B001D34            3519                   align
                    3520   
          0B00 1D34 3521   DataEnd         equ       *                    this label will equate to the address of the last byte of global variable in it
          0000 0018 3522   DataLength      equ       DataEnd-DataStart    length of data needed to copy to Ram on bootup
                    3523   
                    3524   *********************************************************************************************************
                    3525   * Section for uninitialised Data which is set to zero, i.e. we should set this space to zero at starup
                    3526   *********************************************************************************************************
          0B00 1D34 3527   BssStart       equ       *
                    3528   
                    3529   _i:
0B001D34            3530          ds.b      4
                    3531   _x:
0B001D38            3532          ds.b      4
                    3533   _y:
0B001D3C            3534          ds.b      4
                    3535   _z:
0B001D40            3536          ds.b      4
                    3537   _PortA_Count:
0B001D44            3538          ds.b      4
                    3539   _Timer1Count:
0B001D48            3540          ds.b      1
                    3541   _Timer2Count:
0B001D4A            3542          ds.b      1
                    3543   _Timer3Count:
0B001D4C            3544          ds.b      1
                    3545   _Timer4Count:
0B001D4E            3546          ds.b      1
                    3547          section   heap
0B001D50            3548                  align
                    3549   
          0B00 1D50 3550   BssEnd         equ       *
          0000 001C 3551   BssLength      equ       BssEnd-BssStart       length of zeroed data needed to copy to Ram on bootup
                    3552   
                    3553   *********************************************************************************************************
                    3554   * Section for Heap
                    3555   *********************************************************************************************************
                    3556   
          0B00 1D50 3557   heap           equ       *
0B001D50            3558                  align
          0B00 0000

Assembly errors: 0
