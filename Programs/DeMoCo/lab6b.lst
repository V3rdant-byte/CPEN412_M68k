680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 10 Apr 2024      Time: 02:51:13          Source: D:\CPEN412\M68K\PROGRAMS\DEMOCO\LAB6B.SRC

                       1          section   code
                       2   ; for initial stack use $08040000 if your system uses SRAM for main memory (top of 256kbyte SRAM space)
                       3   ; When your system is converted to use DRAM for main memory set this constant to $0C000000 (top of 64MByte DRAM space
                       4   
                       5   ;StackPointerVal     equ $08040000      when using sram
          0C00 0000    6   StackPointerVal     equ $0C000000      when using dram
                       7   
                       8   ; define RamVectorTable as $0803000 if your system uses SRAM for main memory
                       9   ; When your system is converted to use DRAM for main memory define RamVectorTable constant as $0B000000 (top of 64MByte DRAM space)
                      10   
                      11   ;RamVectorTable      equ $08030000      when using sram
          0B00 0000   12   RamVectorTable      equ $0B000000      when using dram
                      13   
                      14   
                      15   
                      16   ; CSTART.ASM  -  C startup-code for Debug Monitor
00000000              17                   align
                      18   
00000000              19                   org $00000000          ;start of rom based vector table, 68k hard wired to expect this at $0
                      20   
00000000  0C00 0000   21   InitialSP       dc.l StackPointerVal   ;initial supervisor state stack pointer(stack decrements first before being used)
00000004  0000 0400   22   InitialPC       dc.l start             ;address of 1st instruction of program after a reset
00000008  0000 0802   23   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 0814   24   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 0826   25   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0838   26   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 084A   27   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 085C   28   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 086E   29   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0880   30   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0892   31   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 08A4   32   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 08B6   33   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 08B6   34   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 08B6   35   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 08B6   36   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 08B6   37   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 08B6   38   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 08B6   39   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 08B6   40   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 08B6   41   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 08B6   42   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 08B6   43   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 08B6   44   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 08B6   45   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      46   *
                      47   *
00000064  0000 049A   48   Level1IRQ       dc.l Level1RamISR
00000068  0000 04AC   49   Level2IRQ       dc.l Level2RamISR
0000006C  0000 04BE   50   Level3IRQ       dc.l Level3RamISR
00000070  0000 04D0   51   Level4IRQ       dc.l Level4RamISR
00000074  0000 04E2   52   Level5IRQ       dc.l Level5RamISR
00000078  0000 05EC   53   Level6IRQ       dc.l Level6RamISR
0000007C  0000 05FE   54   Level7IRQ       dc.l Level7RamISR
                      55   *
                      56   *
00000080  0000 0610   57   Trap0           dc.l Trap0RamISR        ; User installed trap handler
00000084  0000 0622   58   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 0634   59   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 0646   60   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 0658   61   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 066A   62   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 067C   63   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 068E   64   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 06A0   65   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 06B2   66   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 06C4   67   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 06D6   68   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 06E8   69   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 06FA   70   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 070C   71   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 07FC   72   Trap15          dc.l Trap15RamISR       ; User installed trap handler
                      73   
                      74   *
                      75   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                      76   *
                      77   
00000400              78                   org       $00000400
                      79   
00000400  46FC 2700   80   start:          move.w     #$2700,SR             set interrupts to disable until later
                      81   
                      82   *************************************************************************************
                      83   ** add some 68000 instruction to read and write to memory, IO etc. This doesn't do anything
                      84   ** important, it just creates read and write bus cycles to specific addresses which
                      85   ** help with debugging hardware in Quartus simulations
                      86   **************************************************************************************
                      87   
                      88                   ; perform some dummy read/write of 32 bit values to memory to see waveforms during a simulation
                      89   
00000404  23FC 1122   90                   move.l     #$11223344,$08060000 write 32 bits, to memory
00000408  3344 0806 
0000040C  0000      
0000040E  2039 0806   91                   move.l     $08060000,d0         read 32 bits back
00000412  0000      
00000414  13FC 0000   92                   move.b     #$00,$00400000         write to the output ports
00000418  0040 0000 
0000041C  13FC 0000   93                   move.b     #$00,$00400002         write to the output ports
00000420  0040 0002 
00000424  13FC 0000   94                   move.b     #$00,$00400004         write to the output ports
00000428  0040 0004 
0000042C  13FC 0000   95                   move.b     #$00,$00400006         write to the output ports
00000430  0040 0006 
00000434  13FC 0000   96                   move.b     #$00,$00400008         write to the output ports
00000438  0040 0008 
0000043C  13FC 0000   97                   move.b     #$00,$00400010         write to the hex display ports
00000440  0040 0010 
00000444  13FC 0000   98                   move.b     #$00,$00400012         write to the hex display ports
00000448  0040 0012 
0000044C  13FC 0000   99                   move.b     #$00,$00400014         write to the hex display ports
00000450  0040 0014 
00000454  13FC 0000  100                   move.b     #0,$00400020         write to the LCD
00000458  0040 0020 
0000045C  13FC 0000  101                   move.b     #0,$00400022         write to the LCD
00000460  0040 0022 
00000464  13FC 0000  102                   move.b     #0,$00400030         write to the Timer1 Data
00000468  0040 0030 
0000046C  13FC 0000  103                   move.b     #0,$00400032         write to the Timer1 Control
00000470  0040 0032 
                     104   
                     105                   ; some important initialisation do not modify
00000474  23FC FFFF  106                   move.l    #-1,__ungetbuf  ; unget-buffer for keyboard input
00000478  FFFF 0B00 
0000047C  00C0      
0000047E  23FC 0000  107                   move.l    #0,__allocp     ; pointer to allocated memory for malloc-function
00000482  0000 0B00 
00000486  00C4      
00000488  23FC 0B00  108                   move.l    #heap,__heap    ; pointer to free memory
0000048C  0548 0B00 
00000490  00C4      
                     109   
                     110   
00000492  4EB9 0000  111   mainloop        jsr       _main
00000496  34CC      
00000498  60F8       112                   bra       mainloop
                     113   
                     114   *********************************************************************************************************
                     115   * Code to call Ram Based Interrupt handler and other exeception handler code
                     116   *********************************************************************************************************
0000049A  48E7 FFFE  117   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000049E  2079 0B00  118                   move.l    VL1IRQ,a0               get ram based address into a0
000004A2  0064      
000004A4  4E90       119                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004A6  4CDF 7FFF  120                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004AA  4E73       121                   rte
000004AC  48E7 FFFE  122   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B0  2079 0B00  123                   move.l    VL2IRQ,a0               get ram based address into a0
000004B4  0068      
000004B6  4E90       124                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004B8  4CDF 7FFF  125                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004BC  4E73       126                   rte
000004BE  48E7 FFFE  127   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C2  2079 0B00  128                   move.l    VL3IRQ,a0               get ram based address into a0
000004C6  006C      
000004C8  4E90       129                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004CA  4CDF 7FFF  130                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004CE  4E73       131                   rte
000004D0  48E7 FFFE  132   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004D4  2079 0B00  133                   move.l    VL4IRQ,a0               get ram based address into a0
000004D8  0070      
000004DA  4E90       134                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004DC  4CDF 7FFF  135                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E0  4E73       136                   rte
                     137   
                     138   * Trace trap Handler
                     139   
                     140   Level5RamISR
                     141   *
                     142   **         Copy 68000 registers from debug monitor Variables,
                     143   *
                     144   *
000004E2  23FC 0000  145                   move.l    #1,_Trace              switch on Trace Mode
000004E6  0001 0B00 
000004EA  00D8      
000004EC  13FC 0000  146                   move.b    #$0,$0040000A          turn off a trace exception so we don't when generate a trace when disassembling instruction in the register dump (disassembling causes access to use program)
000004F0  0040 000A 
000004F4  33DF 0B00  147                   move.w    (sp)+,_SR              get at the users status register pointed to by stack pointer and copy
000004F8  012C      
000004FA  23DF 0B00  148                   move.l    (sp)+,_PC              get at the users program counter and copy
000004FE  0120      
                     149   *
00000500  23CF 0B00  150                   move.l    SP,_SSP                copy system stack pointer to debug monitor variable
00000504  0124      
00000506  23C0 0B00  151                   move.l    d0,_d0
0000050A  00E4      
0000050C  23C1 0B00  152                   move.l    d1,_d1
00000510  00E8      
00000512  23C2 0B00  153                   move.l    d2,_d2
00000516  00EC      
00000518  23C3 0B00  154                   move.l    d3,_d3
0000051C  00F0      
0000051E  23C4 0B00  155                   move.l    d4,_d4
00000522  00F4      
00000524  23C5 0B00  156                   move.l    d5,_d5
00000528  00F8      
0000052A  23C6 0B00  157                   move.l    d6,_d6
0000052E  00FC      
00000530  23C7 0B00  158                   move.l    d7,_d7
00000534  0100      
                     159   *
00000536  23C8 0B00  160                   move.l    a0,_a0
0000053A  0104      
0000053C  23C9 0B00  161                   move.l    a1,_a1
00000540  0108      
00000542  23CA 0B00  162                   move.l    a2,_a2
00000546  010C      
00000548  23CB 0B00  163                   move.l    a3,_a3
0000054C  0110      
0000054E  23CC 0B00  164                   move.l    a4,_a4
00000552  0114      
00000554  23CD 0B00  165                   move.l    a5,_a5
00000558  0118      
0000055A  23CE 0B00  166                   move.l    a6,_a6
0000055E  011C      
00000560  4E68       167                   move.l    usp,a0
00000562  23C8 0B00  168                   move.l    a0,_USP
00000566  0128      
                     169   *
00000568  2079 0B00  170                   move.l    VL5IRQ,a0              get ram based address into a0, trace exception for next instruction will be generated in Menu SPACE command
0000056C  0074      
0000056E  4E90       171                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     172   
                     173   ** After trace, reload 68000 registers with new values before continuing
                     174   
00000570  2039 0B00  175                   move.l   _d0,d0
00000574  00E4      
00000576  2239 0B00  176                   move.l   _d1,d1
0000057A  00E8      
0000057C  2439 0B00  177                   move.l   _d2,d2
00000580  00EC      
00000582  2639 0B00  178                   move.l   _d3,d3
00000586  00F0      
00000588  2839 0B00  179                   move.l   _d4,d4
0000058C  00F4      
0000058E  2A39 0B00  180                   move.l   _d5,d5
00000592  00F8      
00000594  2C39 0B00  181                   move.l   _d6,d6
00000598  00FC      
0000059A  2E39 0B00  182                   move.l   _d7,d7
0000059E  0100      
                     183   
000005A0  2079 0B00  184                   move.l   _USP,a0
000005A4  0128      
000005A6  4E60       185                   move.l   a0,USP                     load user stack pointer
000005A8  2079 0B00  186                   move.l   _a0,a0
000005AC  0104      
000005AE  2279 0B00  187                   move.l   _a1,a1
000005B2  0108      
000005B4  2479 0B00  188                   move.l   _a2,a2
000005B8  010C      
000005BA  2679 0B00  189                   move.l   _a3,a3
000005BE  0110      
000005C0  2879 0B00  190                   move.l   _a4,a4
000005C4  0114      
000005C6  2A79 0B00  191                   move.l   _a5,a5
000005CA  0118      
000005CC  2C79 0B00  192                   move.l   _a6,a6
000005D0  011C      
                     193   
000005D2  2E79 0B00  194                   move.l   _SSP,sp
000005D6  0124      
000005D8  2F39 0B00  195                   move.l   _PC,-(sp)
000005DC  0120      
000005DE  3F39 0B00  196                   move.w   _SR,-(sp)
000005E2  012C      
000005E4  11F8 0074  197                   move.b    $00000074,$0	          read trace exception vector after accessing disassembly to reset the trace request causes by disassembling program above
000005E8  0000      
000005EA  4E73       198                   rte
                     199   
                     200   * address trap handler
                     201   
000005EC  48E7 FFFE  202   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005F0  2079 0B00  203                   move.l    VL6IRQ,a0               get ram based address into a0
000005F4  0078      
000005F6  4E90       204                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000005F8  4CDF 7FFF  205                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005FC  4E73       206                   rte
                     207   
000005FE  48E7 FFFE  208   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000602  2079 0B00  209                   move.l    VL7IRQ,a0               get ram based address into a0
00000606  007C      
00000608  4E90       210                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000060A  4CDF 7FFF  211                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000060E  4E73       212                   rte
                     213   
                     214   
                     215   ********************************************************************************************************
                     216   * Ram based Trap handler and other exeception handler code
                     217   *********************************************************************************************************
                     218   
00000610  48E7 FFFE  219   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000614  2079 0B00  220                   move.l    VTrap0,a0                get ram based address into a0
00000618  0080      
0000061A  4E90       221                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000061C  4CDF 7FFF  222                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000620  4E73       223                   rte
                     224   
00000622  48E7 FFFE  225   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000626  2079 0B00  226                   move.l    VTrap1,a0                get ram based address into a0
0000062A  0084      
0000062C  4E90       227                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000062E  4CDF 7FFF  228                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000632  4E73       229                   rte
                     230   
00000634  48E7 FFFE  231   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000638  2079 0B00  232                   move.l    VTrap2,a0                get ram based address into a0
0000063C  0088      
0000063E  4E90       233                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000640  4CDF 7FFF  234                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000644  4E73       235                   rte
                     236   
00000646  48E7 FFFE  237   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000064A  2079 0B00  238                   move.l    VTrap3,a0                get ram based address into a0
0000064E  008C      
00000650  4E90       239                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000652  4CDF 7FFF  240                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000656  4E73       241                   rte
                     242   
00000658  48E7 FFFE  243   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000065C  2079 0B00  244                   move.l    VTrap4,a0                get ram based address into a0
00000660  0090      
00000662  4E90       245                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000664  4CDF 7FFF  246                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000668  4E73       247                   rte
                     248   
0000066A  48E7 FFFE  249   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000066E  2079 0B00  250                   move.l    VTrap5,a0                get ram based address into a0
00000672  0094      
00000674  4E90       251                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000676  4CDF 7FFF  252                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000067A  4E73       253                   rte
                     254   
0000067C  48E7 FFFE  255   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000680  2079 0B00  256                   move.l    VTrap6,a0                get ram based address into a0
00000684  0098      
00000686  4E90       257                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000688  4CDF 7FFF  258                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000068C  4E73       259                   rte
                     260   
0000068E  48E7 FFFE  261   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000692  2079 0B00  262                   move.l    VTrap7,a0                get ram based address into a0
00000696  009C      
00000698  4E90       263                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000069A  4CDF 7FFF  264                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000069E  4E73       265                   rte
                     266   
000006A0  48E7 FFFE  267   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006A4  2079 0B00  268                   move.l    VTrap8,a0                get ram based address into a0
000006A8  00A0      
000006AA  4E90       269                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006AC  4CDF 7FFF  270                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006B0  4E73       271                   rte
                     272   
000006B2  48E7 FFFE  273   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006B6  2079 0B00  274                   move.l    VTrap9,a0                get ram based address into a0
000006BA  00A4      
000006BC  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006BE  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006C2  4E73       277                   rte
                     278   
000006C4  48E7 FFFE  279   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006C8  2079 0B00  280                   move.l    VTrap10,a0                get ram based address into a0
000006CC  00A8      
000006CE  4E90       281                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006D0  4CDF 7FFF  282                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006D4  4E73       283                   rte
                     284   
000006D6  48E7 FFFE  285   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006DA  2079 0B00  286                   move.l    VTrap11,a0                get ram based address into a0
000006DE  00AC      
000006E0  4E90       287                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006E2  4CDF 7FFF  288                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006E6  4E73       289                   rte
                     290   
000006E8  48E7 FFFE  291   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006EC  2079 0B00  292                   move.l    VTrap12,a0                get ram based address into a0
000006F0  00B0      
000006F2  4E90       293                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006F4  4CDF 7FFF  294                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006F8  4E73       295                   rte
                     296   
000006FA  48E7 FFFE  297   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006FE  2079 0B00  298                   move.l    VTrap13,a0                get ram based address into a0
00000702  00B4      
00000704  4E90       299                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000706  4CDF 7FFF  300                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000070A  4E73       301                   rte
                     302   
                     303   Trap14RamISR    ;Break Point Handler
                     304   *
                     305   **         Copy 68000 registers from debug monitor Variables
                     306   *
0000070C  23FC 0000  307                   move.l    #1,_Trace      switch on Trace Mode
00000710  0001 0B00 
00000714  00D8      
00000716  33DF 0B00  308                   move.w    (sp)+,_SR       get at the users status register pointed to by stack pointer and copy
0000071A  012C      
0000071C  23DF 0B00  309                   move.l    (sp)+,_PC      get at the users program counter and copy
00000720  0120      
                     310   *
00000722  23C0 0B00  311                   move.l    d0,_d0
00000726  00E4      
00000728  23C1 0B00  312                   move.l    d1,_d1
0000072C  00E8      
0000072E  23C2 0B00  313                   move.l    d2,_d2
00000732  00EC      
00000734  23C3 0B00  314                   move.l    d3,_d3
00000738  00F0      
0000073A  23C4 0B00  315                   move.l    d4,_d4
0000073E  00F4      
00000740  23C5 0B00  316                   move.l    d5,_d5
00000744  00F8      
00000746  23C6 0B00  317                   move.l    d6,_d6
0000074A  00FC      
0000074C  23C7 0B00  318                   move.l    d7,_d7
00000750  0100      
                     319   *
00000752  23C8 0B00  320                   move.l    a0,_a0
00000756  0104      
00000758  23C9 0B00  321                   move.l    a1,_a1
0000075C  0108      
0000075E  23CA 0B00  322                   move.l    a2,_a2
00000762  010C      
00000764  23CB 0B00  323                   move.l    a3,_a3
00000768  0110      
0000076A  23CC 0B00  324                   move.l    a4,_a4
0000076E  0114      
00000770  23CD 0B00  325                   move.l    a5,_a5
00000774  0118      
00000776  23CE 0B00  326                   move.l    a6,_a6
0000077A  011C      
0000077C  4E68       327                   move.l    USP,a0
0000077E  23C8 0B00  328                   move.l    a0,_USP
00000782  0128      
                     329   *
00000784  2079 0B00  330                   move.l    VTrap14,a0             get ram based address into a0
00000788  00B8      
0000078A  4E90       331                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     332   
                     333   ** After breakpoint reload 68000 registers with new values before continuing
                     334   
                     335   *                move.b    #$ff,$0040000A     generate a trace exception for the next instruction
0000078C  2039 0B00  336                   move.l   _d0,d0
00000790  00E4      
00000792  2239 0B00  337                   move.l   _d1,d1
00000796  00E8      
00000798  2439 0B00  338                   move.l   _d2,d2
0000079C  00EC      
0000079E  2639 0B00  339                   move.l   _d3,d3
000007A2  00F0      
000007A4  2839 0B00  340                   move.l   _d4,d4
000007A8  00F4      
000007AA  2A39 0B00  341                   move.l   _d5,d5
000007AE  00F8      
000007B0  2C39 0B00  342                   move.l   _d6,d6
000007B4  00FC      
000007B6  2E39 0B00  343                   move.l   _d7,d7
000007BA  0100      
                     344   
000007BC  2079 0B00  345                   move.l   _USP,a0
000007C0  0128      
000007C2  4E60       346                   move.l   a0,USP        load user stack pointer A7
000007C4  2079 0B00  347                   move.l   _a0,a0
000007C8  0104      
000007CA  2279 0B00  348                   move.l   _a1,a1
000007CE  0108      
000007D0  2479 0B00  349                   move.l   _a2,a2
000007D4  010C      
000007D6  2679 0B00  350                   move.l   _a3,a3
000007DA  0110      
000007DC  2879 0B00  351                   move.l   _a4,a4
000007E0  0114      
000007E2  2A79 0B00  352                   move.l   _a5,a5
000007E6  0118      
000007E8  2C79 0B00  353                   move.l   _a6,a6
000007EC  011C      
                     354   
000007EE  2F39 0B00  355                   move.l   _PC,-(sp)
000007F2  0120      
000007F4  3F39 0B00  356                   move.w   _SR,-(sp)
000007F8  012C      
000007FA  4E73       357                   rte
                     358   
000007FC  4EF9 0000  359   Trap15RamISR    jmp     _CallDebugMonitor
00000800  2356      
                     360   *                movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                     361   *                move.l    VTrap15,a0                get ram based address into a0
                     362   *                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                     363   *                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                     364   *                rte
                     365   
                     366   *********************************************************************************************************
                     367   *Default exception handler for everything without a specific handler
                     368   *********************************************************************************************************
                     369   
                     370   *
                     371   **              Jump here for each unhandled exception
                     372   **              If you need to, MAKE SURE YOU SAVE ALL IMPORTANT REGISTERS AND RESTORE THEM BEFORE RETURNING (IF APPROPRIATE)
                     373   *
                     374   
00000802  48E7 FFFE  375   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000806  2079 0B00  376                   move.l    VBusError,a0            get ram based address into a0
0000080A  0008      
0000080C  4E90       377                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000080E  4CDF 7FFF  378                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000812  4E73       379                   rte
00000814  48E7 FFFE  380   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000818  2079 0B00  381                   move.l    VAddressError,a0        get ram based address into a0
0000081C  000C      
0000081E  4E90       382                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000820  4CDF 7FFF  383                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000824  4E73       384                   rte
00000826  48E7 FFFE  385   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000082A  2079 0B00  386                   move.l    VIllegalInstr,a0        get ram based address into a0
0000082E  0010      
00000830  4E90       387                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000832  4CDF 7FFF  388                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000836  4E73       389                   rte
00000838  48E7 FFFE  390   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000083C  2079 0B00  391                   move.l    VDividebyZero,a0        get ram based address into a0
00000840  0014      
00000842  4E90       392                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000844  4CDF 7FFF  393                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000848  4E73       394                   rte
0000084A  48E7 FFFE  395   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000084E  2079 0B00  396                   move.l    VCheck,a0               get ram based address into a0
00000852  0018      
00000854  4E90       397                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000856  4CDF 7FFF  398                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000085A  4E73       399                   rte
0000085C  48E7 FFFE  400   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000860  2079 0B00  401                   move.l    VTrapV,a0               get ram based address into a0
00000864  001C      
00000866  4E90       402                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000868  4CDF 7FFF  403                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000086C  4E73       404                   rte
0000086E  48E7 FFFE  405   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000872  2079 0B00  406                   move.l    VPrivilege,a0           get ram based address into a0
00000876  0020      
00000878  4E90       407                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000087A  4CDF 7FFF  408                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000087E  4E73       409                   rte
00000880  48E7 FFFE  410   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000884  2079 0B00  411                   move.l    VTrace,a0               get ram based address into a0
00000888  0024      
0000088A  4E90       412                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000088C  4CDF 7FFF  413                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000890  4E73       414                   rte
00000892  48E7 FFFE  415   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000896  2079 0B00  416                   move.l    VLine1010emul,a0        get ram based address into a0
0000089A  0028      
0000089C  4E90       417                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000089E  4CDF 7FFF  418                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008A2  4E73       419                   rte
000008A4  48E7 FFFE  420   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000008A8  2079 0B00  421                   move.l    VLine1111emul,a0        get ram based address into a0
000008AC  002C      
000008AE  4E90       422                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000008B0  4CDF 7FFF  423                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008B4  4E73       424                   rte
                     425   E_Unnas1
                     426   E_Unnas2
                     427   E_Unnas3
                     428   E_UnitI
                     429   E_Unnas4
                     430   E_Unnas5
                     431   E_Unnas6
                     432   E_Unnas7
                     433   E_Unnas8
                     434   E_Unnas9
                     435   E_Unnas10
                     436   E_Unnas11
                     437   E_Spuri
000008B6  60FE       438   _stop            bra _stop                         stop
                     439   ***************************************************************************************************
                     440   * Go() function in debug monitor
                     441   ***************************************************************************************************
                     442   _go
000008B8  2E79 0B00  443                   move.l   _SSP,a7        load system stack pointer (remember we are in supervisor mode when running this so a7 is the System stack pointer)
000008BC  0124      
000008BE  2F39 0B00  444                   move.l   _PC,-(sp)      copy debug monitor PC variable to the stack
000008C2  0120      
000008C4  3F39 0B00  445                   move.w   _SR,-(sp)      copy debug monitor status reg to the stack
000008C8  012C      
                     446   
000008CA  1038 0078  447                   move.b   $00000078,d0  remove any spurious address exception arising after power on
000008CE  2039 0B00  448                   move.l   _d0,d0
000008D2  00E4      
000008D4  2239 0B00  449                   move.l   _d1,d1
000008D8  00E8      
000008DA  2439 0B00  450                   move.l   _d2,d2
000008DE  00EC      
000008E0  2639 0B00  451                   move.l   _d3,d3
000008E4  00F0      
000008E6  2839 0B00  452                   move.l   _d4,d4
000008EA  00F4      
000008EC  2A39 0B00  453                   move.l   _d5,d5
000008F0  00F8      
000008F2  2C39 0B00  454                   move.l   _d6,d6
000008F6  00FC      
000008F8  2E39 0B00  455                   move.l   _d7,d7
000008FC  0100      
                     456   
000008FE  2079 0B00  457                   move.l   _USP,a0
00000902  0128      
00000904  4E60       458                   move.l   a0,USP        load user stack pointer (remember we are in supervisor mode when running this, so a7 is the System stack pointer)
00000906  2079 0B00  459                   move.l   _a0,a0
0000090A  0104      
0000090C  2279 0B00  460                   move.l   _a1,a1
00000910  0108      
00000912  2479 0B00  461                   move.l   _a2,a2
00000916  010C      
00000918  2679 0B00  462                   move.l   _a3,a3
0000091C  0110      
0000091E  2879 0B00  463                   move.l   _a4,a4
00000922  0114      
00000924  2A79 0B00  464                   move.l   _a5,a5
00000928  0118      
0000092A  2C79 0B00  465                   move.l   _a6,a6
0000092E  011C      
00000930  4E73       466                   rte                    load the status reg and PC from the stack and commence running
                     467                                          *used to be rte but this didn't load the status byte
                     468   
                     469   ; D:\CPEN412\M68K\PROGRAMS\DEMOCO\LAB6B.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     470   ; #include "DM.h"
                     471   ; #include "canbus.H"
                     472   ; // use 08030000 for a system running from sram or 0B000000 for system running from dram
                     473   ; //#define StartOfExceptionVectorTable 0x08030000
                     474   ; #define StartOfExceptionVectorTable 0x0B000000
                     475   ; // use 0C000000 for dram or hex 08040000 for sram
                     476   ; //#define TopOfStack 0x08040000
                     477   ; #define TopOfStack 0x0C000000
                     478   ; /*************************************************************
                     479   ; ** SPI Controller registers
                     480   ; **************************************************************/
                     481   ; // SPI Registers
                     482   ; #define SPI_Control         (*(volatile unsigned char *)(0x00408020))
                     483   ; #define SPI_Status          (*(volatile unsigned char *)(0x00408022))
                     484   ; #define SPI_Data            (*(volatile unsigned char *)(0x00408024))
                     485   ; #define SPI_Ext             (*(volatile unsigned char *)(0x00408026))
                     486   ; #define SPI_CS              (*(volatile unsigned char *)(0x00408028))
                     487   ; // these two macros enable or disable the flash memory chip enable off SSN_O[7..0]
                     488   ; // in this case we assume there is only 1 device connected to SSN_O[0] so we can
                     489   ; // write hex FE to the SPI_CS to enable it (the enable on the flash chip is active low)
                     490   ; // and write FF to disable it
                     491   ; #define   Enable_SPI_CS()             SPI_CS = 0xFE
                     492   ; #define   Disable_SPI_CS()            SPI_CS = 0xFF
                     493   ; /* DO NOT INITIALISE GLOBAL VARIABLES - DO IT in MAIN() */
                     494   ; unsigned int i, x, y, z, PortA_Count;
                     495   ; int     Trace, GoFlag, Echo;                       // used in tracing/single stepping
                     496   ; // 68000 register dump and preintialise value (these can be changed by the user program when it is running, e.g. stack pointer, registers etc
                     497   ; unsigned int d0, d1, d2, d3, d4, d5, d6, d7;
                     498   ; unsigned int a0, a1, a2, a3, a4, a5, a6;
                     499   ; unsigned int PC, SSP, USP;
                     500   ; unsigned short int SR;
                     501   ; // Breakpoint variables
                     502   ; unsigned int BreakPointAddress[8];                      //array of 8 breakpoint addresses
                     503   ; unsigned short int BreakPointInstruction[8];           // to hold the instruction opcode at the breakpoint
                     504   ; unsigned int BreakPointSetOrCleared[8];
                     505   ; unsigned int InstructionSize;
                     506   ; // watchpoint variables
                     507   ; unsigned int WatchPointAddress[8];                      //array of 8 breakpoint addresses
                     508   ; unsigned int WatchPointSetOrCleared[8];
                     509   ; char WatchPointString[8][100];
                     510   ; char    TempString[100];
                     511   ; unsigned char Timer1Count;
                     512   ; /************************************************************************************
                     513   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                     514   ; ************************************************************************************/
                     515   ; void Wait1ms(void)
                     516   ; {
                     517   _Wait1ms:
00000932  2F02       518          move.l    D2,-(A7)
                     519   ; long int  i;
                     520   ; for (i = 0; i < 1000; i++)
00000934  4282       521          clr.l     D2
                     522   Wait1ms_1:
00000936  0C82 0000  523          cmp.l     #1000,D2
0000093A  03E8      
0000093C  6C04       524          bge.s     Wait1ms_3
0000093E  5282       525          addq.l    #1,D2
00000940  60F4       526          bra       Wait1ms_1
                     527   Wait1ms_3:
00000942  241F       528          move.l    (A7)+,D2
00000944  4E75       529          rts
                     530   ; ;
                     531   ; }
                     532   ; /************************************************************************************
                     533   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                     534   ; **************************************************************************************/
                     535   ; void Wait3ms(void)
                     536   ; {
                     537   _Wait3ms:
00000946  2F02       538          move.l    D2,-(A7)
                     539   ; int i;
                     540   ; for (i = 0; i < 3; i++)
00000948  4282       541          clr.l     D2
                     542   Wait3ms_1:
0000094A  0C82 0000  543          cmp.l     #3,D2
0000094E  0003      
00000950  6C08       544          bge.s     Wait3ms_3
                     545   ; Wait1ms();
00000952  4EB8 0932  546          jsr       _Wait1ms
00000956  5282       547          addq.l    #1,D2
00000958  60F0       548          bra       Wait3ms_1
                     549   Wait3ms_3:
0000095A  241F       550          move.l    (A7)+,D2
0000095C  4E75       551          rts
                     552   ; }
                     553   ; /*********************************************************************************************
                     554   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                     555   ; *********************************************************************************************/
                     556   ; void Init_LCD(void)
                     557   ; {
                     558   _Init_LCD:
                     559   ; LCDcommand = (char)(0x0c);
0000095E  13FC 000C  560          move.b    #12,4194336
00000962  0040 0020 
                     561   ; Wait3ms();
00000966  4EB8 0946  562          jsr       _Wait3ms
                     563   ; LCDcommand = (char)(0x38);
0000096A  13FC 0038  564          move.b    #56,4194336
0000096E  0040 0020 
                     565   ; Wait3ms();
00000972  4EB8 0946  566          jsr       _Wait3ms
00000976  4E75       567          rts
                     568   ; }
                     569   ; /******************************************************************************
                     570   ; *subroutine to output a single character held in d1 to the LCD display
                     571   ; *it is assumed the character is an ASCII code and it will be displayed at the
                     572   ; *current cursor position
                     573   ; *******************************************************************************/
                     574   ; void Outchar(int c)
                     575   ; {
                     576   _Outchar:
00000978  4E56 0000  577          link      A6,#0
                     578   ; LCDdata = (char)(c);
0000097C  202E 0008  579          move.l    8(A6),D0
00000980  13C0 0040  580          move.b    D0,4194338
00000984  0022      
                     581   ; Wait1ms();
00000986  4EB8 0932  582          jsr       _Wait1ms
0000098A  4E5E       583          unlk      A6
0000098C  4E75       584          rts
                     585   ; }
                     586   ; /**********************************************************************************
                     587   ; *subroutine to output a message at the current cursor position of the LCD display
                     588   ; ************************************************************************************/
                     589   ; void OutMess(char* theMessage)
                     590   ; {
                     591   _OutMess:
0000098E  4E56 FFFC  592          link      A6,#-4
                     593   ; char c;
                     594   ; while ((c = *theMessage++) != (char)(0))
                     595   OutMess_1:
00000992  206E 0008  596          move.l    8(A6),A0
00000996  52AE 0008  597          addq.l    #1,8(A6)
0000099A  1D50 FFFF  598          move.b    (A0),-1(A6)
0000099E  1010       599          move.b    (A0),D0
000009A0  6712       600          beq.s     OutMess_3
                     601   ; Outchar(c);
000009A2  122E FFFF  602          move.b    -1(A6),D1
000009A6  4881       603          ext.w     D1
000009A8  48C1       604          ext.l     D1
000009AA  2F01       605          move.l    D1,-(A7)
000009AC  4EB8 0978  606          jsr       _Outchar
000009B0  584F       607          addq.w    #4,A7
000009B2  60DE       608          bra       OutMess_1
                     609   OutMess_3:
000009B4  4E5E       610          unlk      A6
000009B6  4E75       611          rts
                     612   ; }
                     613   ; /******************************************************************************
                     614   ; *subroutine to clear the line by issuing 24 space characters
                     615   ; *******************************************************************************/
                     616   ; void Clearln(void)
                     617   ; {
                     618   _Clearln:
000009B8  2F02       619          move.l    D2,-(A7)
                     620   ; unsigned char i;
                     621   ; for (i = 0; i < 24; i++)
000009BA  4202       622          clr.b     D2
                     623   Clearln_1:
000009BC  0C02 0018  624          cmp.b     #24,D2
000009C0  640E       625          bhs.s     Clearln_3
                     626   ; Outchar(' ');  /* write a space char to the LCD display */
000009C2  4878 0020  627          pea       32
000009C6  4EB8 0978  628          jsr       _Outchar
000009CA  584F       629          addq.w    #4,A7
000009CC  5202       630          addq.b    #1,D2
000009CE  60EC       631          bra       Clearln_1
                     632   Clearln_3:
000009D0  241F       633          move.l    (A7)+,D2
000009D2  4E75       634          rts
                     635   ; }
                     636   ; /******************************************************************************
                     637   ; *subroutine to move the cursor to the start of line 1 and clear that line
                     638   ; *******************************************************************************/
                     639   ; void Oline0(char* theMessage)
                     640   ; {
                     641   _Oline0:
000009D4  4E56 0000  642          link      A6,#0
                     643   ; LCDcommand = (char)(0x80);
000009D8  13FC 0080  644          move.b    #128,4194336
000009DC  0040 0020 
                     645   ; Wait3ms();
000009E0  4EB8 0946  646          jsr       _Wait3ms
                     647   ; Clearln();
000009E4  4EB8 09B8  648          jsr       _Clearln
                     649   ; LCDcommand = (char)(0x80);
000009E8  13FC 0080  650          move.b    #128,4194336
000009EC  0040 0020 
                     651   ; Wait3ms();
000009F0  4EB8 0946  652          jsr       _Wait3ms
                     653   ; OutMess(theMessage);
000009F4  2F2E 0008  654          move.l    8(A6),-(A7)
000009F8  4EB8 098E  655          jsr       _OutMess
000009FC  584F       656          addq.w    #4,A7
000009FE  4E5E       657          unlk      A6
00000A00  4E75       658          rts
                     659   ; }
                     660   ; /******************************************************************************
                     661   ; *subroutine to move the cursor to the start of line 2 and clear that line
                     662   ; *******************************************************************************/
                     663   ; void Oline1(char* theMessage)
                     664   ; {
                     665   _Oline1:
00000A02  4E56 0000  666          link      A6,#0
                     667   ; LCDcommand = (char)(0xC0);
00000A06  13FC 00C0  668          move.b    #192,4194336
00000A0A  0040 0020 
                     669   ; Wait3ms();
00000A0E  4EB8 0946  670          jsr       _Wait3ms
                     671   ; Clearln();
00000A12  4EB8 09B8  672          jsr       _Clearln
                     673   ; LCDcommand = (char)(0xC0);
00000A16  13FC 00C0  674          move.b    #192,4194336
00000A1A  0040 0020 
                     675   ; Wait3ms();
00000A1E  4EB8 0946  676          jsr       _Wait3ms
                     677   ; OutMess(theMessage);
00000A22  2F2E 0008  678          move.l    8(A6),-(A7)
00000A26  4EB8 098E  679          jsr       _OutMess
00000A2A  584F       680          addq.w    #4,A7
00000A2C  4E5E       681          unlk      A6
00000A2E  4E75       682          rts
                     683   ; }
                     684   ; void InstallExceptionHandler(void (*function_ptr)(), int level)
                     685   ; {
                     686   _InstallExceptionHandler:
00000A30  4E56 FFFC  687          link      A6,#-4
                     688   ; volatile long int* RamVectorAddress = (volatile long int*)(StartOfExceptionVectorTable);   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
00000A34  2D7C 0B00  689          move.l    #184549376,-4(A6)
00000A38  0000 FFFC 
                     690   ; RamVectorAddress[level] = (long int*)(function_ptr);
00000A3C  206E FFFC  691          move.l    -4(A6),A0
00000A40  202E 000C  692          move.l    12(A6),D0
00000A44  E588       693          lsl.l     #2,D0
00000A46  21AE 0008  694          move.l    8(A6),0(A0,D0.L)
00000A4A  0800      
00000A4C  4E5E       695          unlk      A6
00000A4E  4E75       696          rts
                     697   ; }
                     698   ; void TestLEDS(void)
                     699   ; {
                     700   _TestLEDS:
00000A50  48E7 3000  701          movem.l   D2/D3,-(A7)
                     702   ; int delay;
                     703   ; unsigned char count = 0;
00000A54  4202       704          clr.b     D2
                     705   ; while (1) {
                     706   TestLEDS_1:
                     707   ; PortA = PortB = PortC = PortD = HEX_A = HEX_B = HEX_C = HEX_D = ((count << 4) + (count & 0x0f));
00000A56  1002       708          move.b    D2,D0
00000A58  E908       709          lsl.b     #4,D0
00000A5A  1202       710          move.b    D2,D1
00000A5C  C23C 000F  711          and.b     #15,D1
00000A60  D001       712          add.b     D1,D0
00000A62  13C0 0040  713          move.b    D0,4194326
00000A66  0016      
00000A68  13C0 0040  714          move.b    D0,4194324
00000A6C  0014      
00000A6E  13C0 0040  715          move.b    D0,4194322
00000A72  0012      
00000A74  13C0 0040  716          move.b    D0,4194320
00000A78  0010      
00000A7A  13C0 0040  717          move.b    D0,4194310
00000A7E  0006      
00000A80  13C0 0040  718          move.b    D0,4194308
00000A84  0004      
00000A86  13C0 0040  719          move.b    D0,4194306
00000A8A  0002      
00000A8C  13C0 0040  720          move.b    D0,4194304
00000A90  0000      
                     721   ; for (delay = 0; delay < 200000; delay++)
00000A92  4283       722          clr.l     D3
                     723   TestLEDS_4:
00000A94  0C83 0003  724          cmp.l     #200000,D3
00000A98  0D40      
00000A9A  6C04       725          bge.s     TestLEDS_6
00000A9C  5283       726          addq.l    #1,D3
00000A9E  60F4       727          bra       TestLEDS_4
                     728   TestLEDS_6:
                     729   ; ;
                     730   ; count++;
00000AA0  5202       731          addq.b    #1,D2
00000AA2  60B2       732          bra       TestLEDS_1
                     733   ; }
                     734   ; }
                     735   ; void SwitchTest(void)
                     736   ; {
                     737   _SwitchTest:
00000AA4  48E7 3020  738          movem.l   D2/D3/A2,-(A7)
00000AA8  45F9 0000  739          lea       _printf.L,A2
00000AAC  43B8      
                     740   ; int i, switches = 0;
00000AAE  4283       741          clr.l     D3
                     742   ; printf("\r\n");
00000AB0  4879 0000  743          pea       @lab6b_1.L
00000AB4  4D08      
00000AB6  4E92       744          jsr       (A2)
00000AB8  584F       745          addq.w    #4,A7
                     746   ; while (1) {
                     747   SwitchTest_1:
                     748   ; switches = (PortB << 8) | (PortA);
00000ABA  1039 0040  749          move.b    4194306,D0
00000ABE  0002      
00000AC0  C0BC 0000  750          and.l     #255,D0
00000AC4  00FF      
00000AC6  E188       751          lsl.l     #8,D0
00000AC8  1239 0040  752          move.b    4194304,D1
00000ACC  0000      
00000ACE  C2BC 0000  753          and.l     #255,D1
00000AD2  00FF      
00000AD4  8081       754          or.l      D1,D0
00000AD6  2600       755          move.l    D0,D3
                     756   ; printf("\rSwitches SW[7-0] = ");
00000AD8  4879 0000  757          pea       @lab6b_2.L
00000ADC  4D0C      
00000ADE  4E92       758          jsr       (A2)
00000AE0  584F       759          addq.w    #4,A7
                     760   ; for (i = (int)(0x00000080); i > 0; i = i >> 1) {
00000AE2  243C 0000  761          move.l    #128,D2
00000AE6  0080      
                     762   SwitchTest_4:
00000AE8  0C82 0000  763          cmp.l     #0,D2
00000AEC  0000      
00000AEE  6F20       764          ble.s     SwitchTest_6
                     765   ; if ((switches & i) == 0)
00000AF0  2003       766          move.l    D3,D0
00000AF2  C082       767          and.l     D2,D0
00000AF4  660C       768          bne.s     SwitchTest_7
                     769   ; printf("0");
00000AF6  4879 0000  770          pea       @lab6b_3.L
00000AFA  4D22      
00000AFC  4E92       771          jsr       (A2)
00000AFE  584F       772          addq.w    #4,A7
00000B00  600A       773          bra.s     SwitchTest_8
                     774   SwitchTest_7:
                     775   ; else
                     776   ; printf("1");
00000B02  4879 0000  777          pea       @lab6b_4.L
00000B06  4D24      
00000B08  4E92       778          jsr       (A2)
00000B0A  584F       779          addq.w    #4,A7
                     780   SwitchTest_8:
00000B0C  E282       781          asr.l     #1,D2
00000B0E  60D8       782          bra       SwitchTest_4
                     783   SwitchTest_6:
00000B10  60A8       784          bra       SwitchTest_1
                     785   ; }
                     786   ; }
                     787   ; }
                     788   ; /*********************************************************************************************
                     789   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                     790   ; *********************************************************************************************/
                     791   ; void Init_RS232(void)
                     792   ; {
                     793   _Init_RS232:
                     794   ; RS232_Control = (char)(0x15); //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00000B12  13FC 0015  795          move.b    #21,4194368
00000B16  0040 0040 
                     796   ; RS232_Baud = (char)(0x1);      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00000B1A  13FC 0001  797          move.b    #1,4194372
00000B1E  0040 0044 
00000B22  4E75       798          rts
                     799   ; }
                     800   ; int kbhit(void)
                     801   ; {
                     802   _kbhit:
                     803   ; if (((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // wait for Rx bit in status register to be '1'
00000B24  1039 0040  804          move.b    4194368,D0
00000B28  0040      
00000B2A  C03C 0001  805          and.b     #1,D0
00000B2E  0C00 0001  806          cmp.b     #1,D0
00000B32  6604       807          bne.s     kbhit_1
                     808   ; return 1;
00000B34  7001       809          moveq     #1,D0
00000B36  6002       810          bra.s     kbhit_3
                     811   kbhit_1:
                     812   ; else
                     813   ; return 0;
00000B38  4280       814          clr.l     D0
                     815   kbhit_3:
00000B3A  4E75       816          rts
                     817   ; }
                     818   ; /*********************************************************************************************************
                     819   ; **  Subroutine to provide a low level output function to 6850 ACIA
                     820   ; **  This routine provides the basic functionality to output a single character to the serial Port
                     821   ; **  to allow the board to communicate with HyperTerminal Program
                     822   ; **
                     823   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                     824   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                     825   ; **  call _putch() also
                     826   ; *********************************************************************************************************/
                     827   ; int _putch(int c)
                     828   ; {
                     829   __putch:
00000B3C  4E56 0000  830          link      A6,#0
                     831   ; while (((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                     832   _putch_1:
00000B40  1039 0040  833          move.b    4194368,D0
00000B44  0040      
00000B46  C03C 0002  834          and.b     #2,D0
00000B4A  0C00 0002  835          cmp.b     #2,D0
00000B4E  6702       836          beq.s     _putch_3
00000B50  60EE       837          bra       _putch_1
                     838   _putch_3:
                     839   ; ;
                     840   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00000B52  202E 0008  841          move.l    8(A6),D0
00000B56  C03C 007F  842          and.b     #127,D0
00000B5A  13C0 0040  843          move.b    D0,4194370
00000B5E  0042      
                     844   ; return c;                                              // putchar() expects the character to be returned
00000B60  202E 0008  845          move.l    8(A6),D0
00000B64  4E5E       846          unlk      A6
00000B66  4E75       847          rts
                     848   ; }
                     849   ; /*********************************************************************************************************
                     850   ; **  Subroutine to provide a low level input function to 6850 ACIA
                     851   ; **  This routine provides the basic functionality to input a single character from the serial Port
                     852   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                     853   ; **
                     854   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                     855   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                     856   ; **  call _getch() also
                     857   ; *********************************************************************************************************/
                     858   ; int _getch(void)
                     859   ; {
                     860   __getch:
00000B68  2F02       861          move.l    D2,-(A7)
                     862   ; int c;
                     863   ; while (((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                     864   _getch_1:
00000B6A  1039 0040  865          move.b    4194368,D0
00000B6E  0040      
00000B70  C03C 0001  866          and.b     #1,D0
00000B74  0C00 0001  867          cmp.b     #1,D0
00000B78  6702       868          beq.s     _getch_3
00000B7A  60EE       869          bra       _getch_1
                     870   _getch_3:
                     871   ; ;
                     872   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00000B7C  1039 0040  873          move.b    4194370,D0
00000B80  0042      
00000B82  C0BC 0000  874          and.l     #255,D0
00000B86  00FF      
00000B88  C0BC 0000  875          and.l     #127,D0
00000B8C  007F      
00000B8E  2400       876          move.l    D0,D2
                     877   ; // shall we echo the character? Echo is set to TRUE at reset, but for speed we don't want to echo when downloading code with the 'L' debugger command
                     878   ; if (Echo)
00000B90  4AB9 0B00  879          tst.l     _Echo.L
00000B94  00E0      
00000B96  6708       880          beq.s     _getch_4
                     881   ; _putch(c);
00000B98  2F02       882          move.l    D2,-(A7)
00000B9A  4EB8 0B3C  883          jsr       __putch
00000B9E  584F       884          addq.w    #4,A7
                     885   _getch_4:
                     886   ; return c;
00000BA0  2002       887          move.l    D2,D0
00000BA2  241F       888          move.l    (A7)+,D2
00000BA4  4E75       889          rts
                     890   ; }
                     891   ; // flush the input stream for any unread characters
                     892   ; void FlushKeyboard(void)
                     893   ; {
                     894   _FlushKeyboard:
00000BA6  4E56 FFFC  895          link      A6,#-4
                     896   ; char c;
                     897   ; while (1) {
                     898   FlushKeyboard_1:
                     899   ; if (((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // if Rx bit in status register is '1'
00000BAA  1039 0040  900          move.b    4194368,D0
00000BAE  0040      
00000BB0  C03C 0001  901          and.b     #1,D0
00000BB4  0C00 0001  902          cmp.b     #1,D0
00000BB8  6610       903          bne.s     FlushKeyboard_4
                     904   ; c = ((char)(RS232_RxData) & (char)(0x7f));
00000BBA  1039 0040  905          move.b    4194370,D0
00000BBE  0042      
00000BC0  C03C 007F  906          and.b     #127,D0
00000BC4  1D40 FFFF  907          move.b    D0,-1(A6)
00000BC8  6002       908          bra.s     FlushKeyboard_5
                     909   FlushKeyboard_4:
                     910   ; else
                     911   ; return;
00000BCA  6002       912          bra.s     FlushKeyboard_6
                     913   FlushKeyboard_5:
00000BCC  60DC       914          bra       FlushKeyboard_1
                     915   FlushKeyboard_6:
00000BCE  4E5E       916          unlk      A6
00000BD0  4E75       917          rts
                     918   ; }
                     919   ; }
                     920   ; // converts hex char to 4 bit binary equiv in range 0000-1111 (0-F)
                     921   ; // char assumed to be a valid hex char 0-9, a-f, A-F
                     922   ; char xtod(int c)
                     923   ; {
                     924   _xtod:
00000BD2  4E56 0000  925          link      A6,#0
00000BD6  2F02       926          move.l    D2,-(A7)
00000BD8  242E 0008  927          move.l    8(A6),D2
                     928   ; if ((char)(c) <= (char)('9'))
00000BDC  0C02 0039  929          cmp.b     #57,D2
00000BE0  6E08       930          bgt.s     xtod_1
                     931   ; return c - (char)(0x30);    // 0 - 9 = 0x30 - 0x39 so convert to number by sutracting 0x30
00000BE2  1002       932          move.b    D2,D0
00000BE4  0400 0030  933          sub.b     #48,D0
00000BE8  6014       934          bra.s     xtod_3
                     935   xtod_1:
                     936   ; else if ((char)(c) > (char)('F'))    // assume lower case
00000BEA  0C02 0046  937          cmp.b     #70,D2
00000BEE  6F08       938          ble.s     xtod_4
                     939   ; return c - (char)(0x57);    // a-f = 0x61-66 so needs to be converted to 0x0A - 0x0F so subtract 0x57
00000BF0  1002       940          move.b    D2,D0
00000BF2  0400 0057  941          sub.b     #87,D0
00000BF6  6006       942          bra.s     xtod_3
                     943   xtod_4:
                     944   ; else
                     945   ; return c - (char)(0x37);    // A-F = 0x41-46 so needs to be converted to 0x0A - 0x0F so subtract 0x37
00000BF8  1002       946          move.b    D2,D0
00000BFA  0400 0037  947          sub.b     #55,D0
                     948   xtod_3:
00000BFE  241F       949          move.l    (A7)+,D2
00000C00  4E5E       950          unlk      A6
00000C02  4E75       951          rts
                     952   ; }
                     953   ; int Get2HexDigits(char* CheckSumPtr)
                     954   ; {
                     955   _Get2HexDigits:
00000C04  4E56 0000  956          link      A6,#0
00000C08  2F02       957          move.l    D2,-(A7)
                     958   ; register int i = (xtod(_getch()) << 4) | (xtod(_getch()));
00000C0A  2F00       959          move.l    D0,-(A7)
00000C0C  4EB8 0B68  960          jsr       __getch
00000C10  2200       961          move.l    D0,D1
00000C12  201F       962          move.l    (A7)+,D0
00000C14  2F01       963          move.l    D1,-(A7)
00000C16  4EB8 0BD2  964          jsr       _xtod
00000C1A  584F       965          addq.w    #4,A7
00000C1C  C0BC 0000  966          and.l     #255,D0
00000C20  00FF      
00000C22  E980       967          asl.l     #4,D0
00000C24  2F00       968          move.l    D0,-(A7)
00000C26  2F01       969          move.l    D1,-(A7)
00000C28  4EB8 0B68  970          jsr       __getch
00000C2C  221F       971          move.l    (A7)+,D1
00000C2E  2F00       972          move.l    D0,-(A7)
00000C30  4EB8 0BD2  973          jsr       _xtod
00000C34  584F       974          addq.w    #4,A7
00000C36  2200       975          move.l    D0,D1
00000C38  201F       976          move.l    (A7)+,D0
00000C3A  C2BC 0000  977          and.l     #255,D1
00000C3E  00FF      
00000C40  8081       978          or.l      D1,D0
00000C42  2400       979          move.l    D0,D2
                     980   ; if (CheckSumPtr)
00000C44  4AAE 0008  981          tst.l     8(A6)
00000C48  6706       982          beq.s     Get2HexDigits_1
                     983   ; *CheckSumPtr += i;
00000C4A  206E 0008  984          move.l    8(A6),A0
00000C4E  D510       985          add.b     D2,(A0)
                     986   Get2HexDigits_1:
                     987   ; return i;
00000C50  2002       988          move.l    D2,D0
00000C52  241F       989          move.l    (A7)+,D2
00000C54  4E5E       990          unlk      A6
00000C56  4E75       991          rts
                     992   ; }
                     993   ; int Get4HexDigits(char* CheckSumPtr)
                     994   ; {
                     995   _Get4HexDigits:
00000C58  4E56 0000  996          link      A6,#0
                     997   ; return (Get2HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000C5C  2F2E 0008  998          move.l    8(A6),-(A7)
00000C60  4EB8 0C04  999          jsr       _Get2HexDigits
00000C64  584F      1000          addq.w    #4,A7
00000C66  E180      1001          asl.l     #8,D0
00000C68  2F00      1002          move.l    D0,-(A7)
00000C6A  2F2E 0008 1003          move.l    8(A6),-(A7)
00000C6E  4EB8 0C04 1004          jsr       _Get2HexDigits
00000C72  584F      1005          addq.w    #4,A7
00000C74  2200      1006          move.l    D0,D1
00000C76  201F      1007          move.l    (A7)+,D0
00000C78  8081      1008          or.l      D1,D0
00000C7A  4E5E      1009          unlk      A6
00000C7C  4E75      1010          rts
                    1011   ; }
                    1012   ; int Get6HexDigits(char* CheckSumPtr)
                    1013   ; {
                    1014   _Get6HexDigits:
00000C7E  4E56 0000 1015          link      A6,#0
                    1016   ; return (Get4HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000C82  2F2E 0008 1017          move.l    8(A6),-(A7)
00000C86  4EB8 0C58 1018          jsr       _Get4HexDigits
00000C8A  584F      1019          addq.w    #4,A7
00000C8C  E180      1020          asl.l     #8,D0
00000C8E  2F00      1021          move.l    D0,-(A7)
00000C90  2F2E 0008 1022          move.l    8(A6),-(A7)
00000C94  4EB8 0C04 1023          jsr       _Get2HexDigits
00000C98  584F      1024          addq.w    #4,A7
00000C9A  2200      1025          move.l    D0,D1
00000C9C  201F      1026          move.l    (A7)+,D0
00000C9E  8081      1027          or.l      D1,D0
00000CA0  4E5E      1028          unlk      A6
00000CA2  4E75      1029          rts
                    1030   ; }
                    1031   ; int Get8HexDigits(char* CheckSumPtr)
                    1032   ; {
                    1033   _Get8HexDigits:
00000CA4  4E56 0000 1034          link      A6,#0
                    1035   ; return (Get4HexDigits(CheckSumPtr) << 16) | (Get4HexDigits(CheckSumPtr));
00000CA8  2F2E 0008 1036          move.l    8(A6),-(A7)
00000CAC  4EB8 0C58 1037          jsr       _Get4HexDigits
00000CB0  584F      1038          addq.w    #4,A7
00000CB2  E180      1039          asl.l     #8,D0
00000CB4  E180      1040          asl.l     #8,D0
00000CB6  2F00      1041          move.l    D0,-(A7)
00000CB8  2F2E 0008 1042          move.l    8(A6),-(A7)
00000CBC  4EB8 0C58 1043          jsr       _Get4HexDigits
00000CC0  584F      1044          addq.w    #4,A7
00000CC2  2200      1045          move.l    D0,D1
00000CC4  201F      1046          move.l    (A7)+,D0
00000CC6  8081      1047          or.l      D1,D0
00000CC8  4E5E      1048          unlk      A6
00000CCA  4E75      1049          rts
                    1050   ; }
                    1051   ; void DumpMemory(void)   // simple dump memory fn
                    1052   ; {
                    1053   _DumpMemory:
00000CCC  48E7 3C30 1054          movem.l   D2/D3/D4/D5/A2/A3,-(A7)
00000CD0  45F9 0000 1055          lea       _printf.L,A2
00000CD4  43B8      
00000CD6  47F9 0000 1056          lea       _putch.L,A3
00000CDA  42AA      
                    1057   ; int i, j;
                    1058   ; unsigned char* RamPtr, c; // pointer to where the program is download (assumed)
                    1059   ; printf("\r\nDump Memory Block: <ESC> to Abort, <SPACE> to Continue");
00000CDC  4879 0000 1060          pea       @lab6b_5.L
00000CE0  4D26      
00000CE2  4E92      1061          jsr       (A2)
00000CE4  584F      1062          addq.w    #4,A7
                    1063   ; printf("\r\nEnter Start Address: ");
00000CE6  4879 0000 1064          pea       @lab6b_6.L
00000CEA  4D60      
00000CEC  4E92      1065          jsr       (A2)
00000CEE  584F      1066          addq.w    #4,A7
                    1067   ; RamPtr = Get8HexDigits(0);
00000CF0  42A7      1068          clr.l     -(A7)
00000CF2  4EB8 0CA4 1069          jsr       _Get8HexDigits
00000CF6  584F      1070          addq.w    #4,A7
00000CF8  2600      1071          move.l    D0,D3
                    1072   ; while (1) {
                    1073   DumpMemory_1:
                    1074   ; for (i = 0; i < 16; i++) {
00000CFA  4285      1075          clr.l     D5
                    1076   DumpMemory_4:
00000CFC  0C85 0000 1077          cmp.l     #16,D5
00000D00  0010      
00000D02  6C00 0096 1078          bge       DumpMemory_6
                    1079   ; printf("\r\n%08x ", RamPtr);
00000D06  2F03      1080          move.l    D3,-(A7)
00000D08  4879 0000 1081          pea       @lab6b_7.L
00000D0C  4D78      
00000D0E  4E92      1082          jsr       (A2)
00000D10  504F      1083          addq.w    #8,A7
                    1084   ; for (j = 0; j < 16; j++) {
00000D12  4282      1085          clr.l     D2
                    1086   DumpMemory_7:
00000D14  0C82 0000 1087          cmp.l     #16,D2
00000D18  0010      
00000D1A  6C24      1088          bge.s     DumpMemory_9
                    1089   ; printf("%02X", RamPtr[j]);
00000D1C  2043      1090          move.l    D3,A0
00000D1E  1230 2800 1091          move.b    0(A0,D2.L),D1
00000D22  C2BC 0000 1092          and.l     #255,D1
00000D26  00FF      
00000D28  2F01      1093          move.l    D1,-(A7)
00000D2A  4879 0000 1094          pea       @lab6b_8.L
00000D2E  4D80      
00000D30  4E92      1095          jsr       (A2)
00000D32  504F      1096          addq.w    #8,A7
                    1097   ; putchar(' ');
00000D34  4878 0020 1098          pea       32
00000D38  4E93      1099          jsr       (A3)
00000D3A  584F      1100          addq.w    #4,A7
00000D3C  5282      1101          addq.l    #1,D2
00000D3E  60D4      1102          bra       DumpMemory_7
                    1103   DumpMemory_9:
                    1104   ; }
                    1105   ; // now display the data as ASCII at the end
                    1106   ; printf("  ");
00000D40  4879 0000 1107          pea       @lab6b_9.L
00000D44  4D86      
00000D46  4E92      1108          jsr       (A2)
00000D48  584F      1109          addq.w    #4,A7
                    1110   ; for (j = 0; j < 16; j++) {
00000D4A  4282      1111          clr.l     D2
                    1112   DumpMemory_10:
00000D4C  0C82 0000 1113          cmp.l     #16,D2
00000D50  0010      
00000D52  6C00 003A 1114          bge       DumpMemory_12
                    1115   ; c = ((char)(RamPtr[j]) & 0x7f);
00000D56  2043      1116          move.l    D3,A0
00000D58  1030 2800 1117          move.b    0(A0,D2.L),D0
00000D5C  C03C 007F 1118          and.b     #127,D0
00000D60  1800      1119          move.b    D0,D4
                    1120   ; if ((c > (char)(0x7f)) || (c < ' '))
00000D62  0C04 007F 1121          cmp.b     #127,D4
00000D66  6206      1122          bhi.s     DumpMemory_15
00000D68  0C04 0020 1123          cmp.b     #32,D4
00000D6C  640A      1124          bhs.s     DumpMemory_13
                    1125   DumpMemory_15:
                    1126   ; putchar('.');
00000D6E  4878 002E 1127          pea       46
00000D72  4E93      1128          jsr       (A3)
00000D74  584F      1129          addq.w    #4,A7
00000D76  6012      1130          bra.s     DumpMemory_14
                    1131   DumpMemory_13:
                    1132   ; else
                    1133   ; putchar(RamPtr[j]);
00000D78  2043      1134          move.l    D3,A0
00000D7A  1230 2800 1135          move.b    0(A0,D2.L),D1
00000D7E  C2BC 0000 1136          and.l     #255,D1
00000D82  00FF      
00000D84  2F01      1137          move.l    D1,-(A7)
00000D86  4E93      1138          jsr       (A3)
00000D88  584F      1139          addq.w    #4,A7
                    1140   DumpMemory_14:
00000D8A  5282      1141          addq.l    #1,D2
00000D8C  60BE      1142          bra       DumpMemory_10
                    1143   DumpMemory_12:
                    1144   ; }
                    1145   ; RamPtr = RamPtr + 16;
00000D8E  0683 0000 1146          add.l     #16,D3
00000D92  0010      
00000D94  5285      1147          addq.l    #1,D5
00000D96  6000 FF64 1148          bra       DumpMemory_4
                    1149   DumpMemory_6:
                    1150   ; }
                    1151   ; printf("\r\n");
00000D9A  4879 0000 1152          pea       @lab6b_1.L
00000D9E  4D08      
00000DA0  4E92      1153          jsr       (A2)
00000DA2  584F      1154          addq.w    #4,A7
                    1155   ; c = _getch();
00000DA4  4EB8 0B68 1156          jsr       __getch
00000DA8  1800      1157          move.b    D0,D4
                    1158   ; if (c == 0x1b)          // break on ESC
00000DAA  0C04 001B 1159          cmp.b     #27,D4
00000DAE  6602      1160          bne.s     DumpMemory_16
                    1161   ; break;
00000DB0  6004      1162          bra.s     DumpMemory_3
                    1163   DumpMemory_16:
00000DB2  6000 FF46 1164          bra       DumpMemory_1
                    1165   DumpMemory_3:
00000DB6  4CDF 0C3C 1166          movem.l   (A7)+,D2/D3/D4/D5/A2/A3
00000DBA  4E75      1167          rts
                    1168   ; }
                    1169   ; }
                    1170   ; void FillMemory()
                    1171   ; {
                    1172   _FillMemory:
00000DBC  48E7 3820 1173          movem.l   D2/D3/D4/A2,-(A7)
00000DC0  45F9 0000 1174          lea       _printf.L,A2
00000DC4  43B8      
                    1175   ; char* StartRamPtr, * EndRamPtr;
                    1176   ; unsigned char FillData;
                    1177   ; printf("\r\nFill Memory Block");
00000DC6  4879 0000 1178          pea       @lab6b_10.L
00000DCA  4D8A      
00000DCC  4E92      1179          jsr       (A2)
00000DCE  584F      1180          addq.w    #4,A7
                    1181   ; printf("\r\nEnter Start Address: ");
00000DD0  4879 0000 1182          pea       @lab6b_6.L
00000DD4  4D60      
00000DD6  4E92      1183          jsr       (A2)
00000DD8  584F      1184          addq.w    #4,A7
                    1185   ; StartRamPtr = Get8HexDigits(0);
00000DDA  42A7      1186          clr.l     -(A7)
00000DDC  4EB8 0CA4 1187          jsr       _Get8HexDigits
00000DE0  584F      1188          addq.w    #4,A7
00000DE2  2400      1189          move.l    D0,D2
                    1190   ; printf("\r\nEnter End Address: ");
00000DE4  4879 0000 1191          pea       @lab6b_11.L
00000DE8  4D9E      
00000DEA  4E92      1192          jsr       (A2)
00000DEC  584F      1193          addq.w    #4,A7
                    1194   ; EndRamPtr = Get8HexDigits(0);
00000DEE  42A7      1195          clr.l     -(A7)
00000DF0  4EB8 0CA4 1196          jsr       _Get8HexDigits
00000DF4  584F      1197          addq.w    #4,A7
00000DF6  2800      1198          move.l    D0,D4
                    1199   ; printf("\r\nEnter Fill Data: ");
00000DF8  4879 0000 1200          pea       @lab6b_12.L
00000DFC  4DB4      
00000DFE  4E92      1201          jsr       (A2)
00000E00  584F      1202          addq.w    #4,A7
                    1203   ; FillData = Get2HexDigits(0);
00000E02  42A7      1204          clr.l     -(A7)
00000E04  4EB8 0C04 1205          jsr       _Get2HexDigits
00000E08  584F      1206          addq.w    #4,A7
00000E0A  1600      1207          move.b    D0,D3
                    1208   ; printf("\r\nFilling Addresses [$%08X - $%08X] with $%02X", StartRamPtr, EndRamPtr, FillData);
00000E0C  C6BC 0000 1209          and.l     #255,D3
00000E10  00FF      
00000E12  2F03      1210          move.l    D3,-(A7)
00000E14  2F04      1211          move.l    D4,-(A7)
00000E16  2F02      1212          move.l    D2,-(A7)
00000E18  4879 0000 1213          pea       @lab6b_13.L
00000E1C  4DC8      
00000E1E  4E92      1214          jsr       (A2)
00000E20  DEFC 0010 1215          add.w     #16,A7
                    1216   ; while (StartRamPtr < EndRamPtr)
                    1217   FillMemory_1:
00000E24  B484      1218          cmp.l     D4,D2
00000E26  6408      1219          bhs.s     FillMemory_3
                    1220   ; *StartRamPtr++ = FillData;
00000E28  2042      1221          move.l    D2,A0
00000E2A  5282      1222          addq.l    #1,D2
00000E2C  1083      1223          move.b    D3,(A0)
00000E2E  60F4      1224          bra       FillMemory_1
                    1225   FillMemory_3:
00000E30  4CDF 041C 1226          movem.l   (A7)+,D2/D3/D4/A2
00000E34  4E75      1227          rts
                    1228   ; }
                    1229   ; void Load_SRecordFile()
                    1230   ; {
                    1231   _Load_SRecordFile:
00000E36  4E56 FFDC 1232          link      A6,#-36
00000E3A  48E7 3F3C 1233          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00000E3E  45EE FFFA 1234          lea       -6(A6),A2
00000E42  47F8 0C04 1235          lea       _Get2HexDigits.L,A3
00000E46  49F9 0000 1236          lea       _printf.L,A4
00000E4A  43B8      
                    1237   ; int i, Address, AddressSize, DataByte, NumDataBytesToRead, LoadFailed, FailedAddress, AddressFail, SRecordCount = 0, ByteTotal = 0;
00000E4C  42AE FFEE 1238          clr.l     -18(A6)
00000E50  3A7C 0000 1239          move.w    #0,A5
                    1240   ; int result, ByteCount;
                    1241   ; char c, CheckSum, ReadCheckSum, HeaderType;
                    1242   ; char* RamPtr;                          // pointer to Memory where downloaded program will be stored
                    1243   ; LoadFailed = 0;                        //assume LOAD operation will pass
00000E54  7E00      1244          moveq     #0,D7
                    1245   ; AddressFail = 0;
00000E56  42AE FFEA 1246          clr.l     -22(A6)
                    1247   ; Echo = 0;                              // don't echo S records during download
00000E5A  42B9 0B00 1248          clr.l     _Echo.L
00000E5E  00E0      
                    1249   ; printf("\r\nUse HyperTerminal to Send Text File (.hex)\r\n");
00000E60  4879 0000 1250          pea       @lab6b_14.L
00000E64  4DF8      
00000E66  4E94      1251          jsr       (A4)
00000E68  584F      1252          addq.w    #4,A7
                    1253   ; while (1) {
                    1254   Load_SRecordFile_1:
                    1255   ; CheckSum = 0;
00000E6A  4212      1256          clr.b     (A2)
                    1257   ; do {
                    1258   Load_SRecordFile_4:
                    1259   ; c = toupper(_getch());
00000E6C  2F00      1260          move.l    D0,-(A7)
00000E6E  4EB8 0B68 1261          jsr       __getch
00000E72  2200      1262          move.l    D0,D1
00000E74  201F      1263          move.l    (A7)+,D0
00000E76  2F01      1264          move.l    D1,-(A7)
00000E78  4EB9 0000 1265          jsr       _toupper
00000E7C  438C      
00000E7E  584F      1266          addq.w    #4,A7
00000E80  1C00      1267          move.b    D0,D6
                    1268   ; if (c == 0x1b)      // if break
00000E82  0C06 001B 1269          cmp.b     #27,D6
00000E86  6604      1270          bne.s     Load_SRecordFile_6
                    1271   ; return;
00000E88  6000 0132 1272          bra       Load_SRecordFile_8
                    1273   Load_SRecordFile_6:
00000E8C  0C06 0053 1274          cmp.b     #83,D6
00000E90  66DA      1275          bne       Load_SRecordFile_4
                    1276   ; } while (c != (char)('S'));   // wait for S start of header
                    1277   ; HeaderType = _getch();
00000E92  4EB8 0B68 1278          jsr       __getch
00000E96  1600      1279          move.b    D0,D3
                    1280   ; if (HeaderType == (char)('0') || HeaderType == (char)('5'))       // ignore s0, s5 records
00000E98  0C03 0030 1281          cmp.b     #48,D3
00000E9C  6706      1282          beq.s     Load_SRecordFile_11
00000E9E  0C03 0035 1283          cmp.b     #53,D3
00000EA2  6604      1284          bne.s     Load_SRecordFile_9
                    1285   Load_SRecordFile_11:
                    1286   ; continue;
00000EA4  6000 00D2 1287          bra       Load_SRecordFile_23
                    1288   Load_SRecordFile_9:
                    1289   ; if (HeaderType >= (char)('7'))
00000EA8  0C03 0037 1290          cmp.b     #55,D3
00000EAC  6D04      1291          blt.s     Load_SRecordFile_12
                    1292   ; break;                 // end load on s7,s8,s9 records
00000EAE  6000 00CC 1293          bra       Load_SRecordFile_3
                    1294   Load_SRecordFile_12:
                    1295   ; // get the bytecount
                    1296   ; ByteCount = Get2HexDigits(&CheckSum);
00000EB2  2F0A      1297          move.l    A2,-(A7)
00000EB4  4E93      1298          jsr       (A3)
00000EB6  584F      1299          addq.w    #4,A7
00000EB8  2D40 FFF6 1300          move.l    D0,-10(A6)
                    1301   ; // get the address, 4 digits for s1, 6 digits for s2, and 8 digits for s3 record
                    1302   ; if (HeaderType == (char)('1')) {
00000EBC  0C03 0031 1303          cmp.b     #49,D3
00000EC0  660E      1304          bne.s     Load_SRecordFile_14
                    1305   ; AddressSize = 2;       // 2 byte address
00000EC2  7A02      1306          moveq     #2,D5
                    1307   ; Address = Get4HexDigits(&CheckSum);
00000EC4  2F0A      1308          move.l    A2,-(A7)
00000EC6  4EB8 0C58 1309          jsr       _Get4HexDigits
00000ECA  584F      1310          addq.w    #4,A7
00000ECC  2800      1311          move.l    D0,D4
00000ECE  6020      1312          bra.s     Load_SRecordFile_17
                    1313   Load_SRecordFile_14:
                    1314   ; }
                    1315   ; else if (HeaderType == (char)('2')) {
00000ED0  0C03 0032 1316          cmp.b     #50,D3
00000ED4  660E      1317          bne.s     Load_SRecordFile_16
                    1318   ; AddressSize = 3;       // 3 byte address
00000ED6  7A03      1319          moveq     #3,D5
                    1320   ; Address = Get6HexDigits(&CheckSum);
00000ED8  2F0A      1321          move.l    A2,-(A7)
00000EDA  4EB8 0C7E 1322          jsr       _Get6HexDigits
00000EDE  584F      1323          addq.w    #4,A7
00000EE0  2800      1324          move.l    D0,D4
00000EE2  600C      1325          bra.s     Load_SRecordFile_17
                    1326   Load_SRecordFile_16:
                    1327   ; }
                    1328   ; else {
                    1329   ; AddressSize = 4;       // 4 byte address
00000EE4  7A04      1330          moveq     #4,D5
                    1331   ; Address = Get8HexDigits(&CheckSum);
00000EE6  2F0A      1332          move.l    A2,-(A7)
00000EE8  4EB8 0CA4 1333          jsr       _Get8HexDigits
00000EEC  584F      1334          addq.w    #4,A7
00000EEE  2800      1335          move.l    D0,D4
                    1336   Load_SRecordFile_17:
                    1337   ; }
                    1338   ; RamPtr = (char*)(Address);                            // point to download area
00000EF0  2D44 FFFC 1339          move.l    D4,-4(A6)
                    1340   ; NumDataBytesToRead = ByteCount - AddressSize - 1;
00000EF4  202E FFF6 1341          move.l    -10(A6),D0
00000EF8  9085      1342          sub.l     D5,D0
00000EFA  5380      1343          subq.l    #1,D0
00000EFC  2D40 FFE2 1344          move.l    D0,-30(A6)
                    1345   ; for (i = 0; i < NumDataBytesToRead; i++) {     // read in remaining data bytes (ignore address and checksum at the end
00000F00  4282      1346          clr.l     D2
                    1347   Load_SRecordFile_18:
00000F02  B4AE FFE2 1348          cmp.l     -30(A6),D2
00000F06  6C1E      1349          bge.s     Load_SRecordFile_20
                    1350   ; DataByte = Get2HexDigits(&CheckSum);
00000F08  2F0A      1351          move.l    A2,-(A7)
00000F0A  4E93      1352          jsr       (A3)
00000F0C  584F      1353          addq.w    #4,A7
00000F0E  2D40 FFDE 1354          move.l    D0,-34(A6)
                    1355   ; *RamPtr++ = DataByte;                      // store downloaded byte in Ram at specified address
00000F12  202E FFDE 1356          move.l    -34(A6),D0
00000F16  206E FFFC 1357          move.l    -4(A6),A0
00000F1A  52AE FFFC 1358          addq.l    #1,-4(A6)
00000F1E  1080      1359          move.b    D0,(A0)
                    1360   ; ByteTotal++;
00000F20  524D      1361          addq.w    #1,A5
00000F22  5282      1362          addq.l    #1,D2
00000F24  60DC      1363          bra       Load_SRecordFile_18
                    1364   Load_SRecordFile_20:
                    1365   ; }
                    1366   ; // checksum is the 1's complement of the sum of all data pairs following the bytecount, i.e. it includes the address and the data itself
                    1367   ; ReadCheckSum = Get2HexDigits(0);
00000F26  42A7      1368          clr.l     -(A7)
00000F28  4E93      1369          jsr       (A3)
00000F2A  584F      1370          addq.w    #4,A7
00000F2C  1D40 FFFB 1371          move.b    D0,-5(A6)
                    1372   ; if ((~CheckSum & 0Xff) != (ReadCheckSum & 0Xff)) {
00000F30  1012      1373          move.b    (A2),D0
00000F32  4600      1374          not.b     D0
00000F34  4880      1375          ext.w     D0
00000F36  C07C 00FF 1376          and.w     #255,D0
00000F3A  122E FFFB 1377          move.b    -5(A6),D1
00000F3E  4881      1378          ext.w     D1
00000F40  C27C 00FF 1379          and.w     #255,D1
00000F44  B041      1380          cmp.w     D1,D0
00000F46  6708      1381          beq.s     Load_SRecordFile_21
                    1382   ; LoadFailed = 1;
00000F48  7E01      1383          moveq     #1,D7
                    1384   ; FailedAddress = Address;
00000F4A  2D44 FFE6 1385          move.l    D4,-26(A6)
                    1386   ; break;
00000F4E  602C      1387          bra.s     Load_SRecordFile_3
                    1388   Load_SRecordFile_21:
                    1389   ; }
                    1390   ; SRecordCount++;
00000F50  52AE FFEE 1391          addq.l    #1,-18(A6)
                    1392   ; // display feedback on progress
                    1393   ; if (SRecordCount % 25 == 0)
00000F54  2F2E FFEE 1394          move.l    -18(A6),-(A7)
00000F58  4878 0019 1395          pea       25
00000F5C  4EB9 0000 1396          jsr       LDIV
00000F60  41DE      
00000F62  202F 0004 1397          move.l    4(A7),D0
00000F66  504F      1398          addq.w    #8,A7
00000F68  4A80      1399          tst.l     D0
00000F6A  660C      1400          bne.s     Load_SRecordFile_23
                    1401   ; putchar('.');
00000F6C  4878 002E 1402          pea       46
00000F70  4EB9 0000 1403          jsr       _putch
00000F74  42AA      
00000F76  584F      1404          addq.w    #4,A7
                    1405   Load_SRecordFile_23:
00000F78  6000 FEF0 1406          bra       Load_SRecordFile_1
                    1407   Load_SRecordFile_3:
                    1408   ; }
                    1409   ; if (LoadFailed == 1) {
00000F7C  0C87 0000 1410          cmp.l     #1,D7
00000F80  0001      
00000F82  6610      1411          bne.s     Load_SRecordFile_25
                    1412   ; printf("\r\nLoad Failed at Address = [$%08X]\r\n", FailedAddress);
00000F84  2F2E FFE6 1413          move.l    -26(A6),-(A7)
00000F88  4879 0000 1414          pea       @lab6b_15.L
00000F8C  4E28      
00000F8E  4E94      1415          jsr       (A4)
00000F90  504F      1416          addq.w    #8,A7
00000F92  600C      1417          bra.s     Load_SRecordFile_26
                    1418   Load_SRecordFile_25:
                    1419   ; }
                    1420   ; else
                    1421   ; printf("\r\nSuccess: Downloaded %d bytes\r\n", ByteTotal);
00000F94  2F0D      1422          move.l    A5,-(A7)
00000F96  4879 0000 1423          pea       @lab6b_16.L
00000F9A  4E4E      
00000F9C  4E94      1424          jsr       (A4)
00000F9E  504F      1425          addq.w    #8,A7
                    1426   Load_SRecordFile_26:
                    1427   ; // pause at the end to wait for download to finish transmitting at the end of S8 etc
                    1428   ; for (i = 0; i < 400000; i++)
00000FA0  4282      1429          clr.l     D2
                    1430   Load_SRecordFile_27:
00000FA2  0C82 0006 1431          cmp.l     #400000,D2
00000FA6  1A80      
00000FA8  6C04      1432          bge.s     Load_SRecordFile_29
00000FAA  5282      1433          addq.l    #1,D2
00000FAC  60F4      1434          bra       Load_SRecordFile_27
                    1435   Load_SRecordFile_29:
                    1436   ; ;
                    1437   ; FlushKeyboard();
00000FAE  4EB8 0BA6 1438          jsr       _FlushKeyboard
                    1439   ; Echo = 1;
00000FB2  23FC 0000 1440          move.l    #1,_Echo.L
00000FB6  0001 0B00 
00000FBA  00E0      
                    1441   Load_SRecordFile_8:
00000FBC  4CDF 3CFC 1442          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00000FC0  4E5E      1443          unlk      A6
00000FC2  4E75      1444          rts
                    1445   ; }
                    1446   ; void MemoryChange(void)
                    1447   ; {
                    1448   _MemoryChange:
00000FC4  48E7 3820 1449          movem.l   D2/D3/D4/A2,-(A7)
00000FC8  45F9 0000 1450          lea       _printf.L,A2
00000FCC  43B8      
                    1451   ; unsigned char* RamPtr, c; // pointer to memory
                    1452   ; int Data;
                    1453   ; printf("\r\nExamine and Change Memory");
00000FCE  4879 0000 1454          pea       @lab6b_17.L
00000FD2  4E70      
00000FD4  4E92      1455          jsr       (A2)
00000FD6  584F      1456          addq.w    #4,A7
                    1457   ; printf("\r\n<ESC> to Stop, <SPACE> to Advance, '-' to Go Back, <DATA> to change");
00000FD8  4879 0000 1458          pea       @lab6b_18.L
00000FDC  4E8C      
00000FDE  4E92      1459          jsr       (A2)
00000FE0  584F      1460          addq.w    #4,A7
                    1461   ; printf("\r\nEnter Address: ");
00000FE2  4879 0000 1462          pea       @lab6b_19.L
00000FE6  4ED2      
00000FE8  4E92      1463          jsr       (A2)
00000FEA  584F      1464          addq.w    #4,A7
                    1465   ; RamPtr = Get8HexDigits(0);
00000FEC  42A7      1466          clr.l     -(A7)
00000FEE  4EB8 0CA4 1467          jsr       _Get8HexDigits
00000FF2  584F      1468          addq.w    #4,A7
00000FF4  2600      1469          move.l    D0,D3
                    1470   ; while (1) {
                    1471   MemoryChange_1:
                    1472   ; printf("\r\n[%08x] : %02x  ", RamPtr, *RamPtr);
00000FF6  2043      1473          move.l    D3,A0
00000FF8  1210      1474          move.b    (A0),D1
00000FFA  C2BC 0000 1475          and.l     #255,D1
00000FFE  00FF      
00001000  2F01      1476          move.l    D1,-(A7)
00001002  2F03      1477          move.l    D3,-(A7)
00001004  4879 0000 1478          pea       @lab6b_20.L
00001008  4EE4      
0000100A  4E92      1479          jsr       (A2)
0000100C  DEFC 000C 1480          add.w     #12,A7
                    1481   ; c = tolower(_getch());
00001010  2F00      1482          move.l    D0,-(A7)
00001012  4EB8 0B68 1483          jsr       __getch
00001016  2200      1484          move.l    D0,D1
00001018  201F      1485          move.l    (A7)+,D0
0000101A  2F01      1486          move.l    D1,-(A7)
0000101C  4EB9 0000 1487          jsr       _tolower
00001020  4316      
00001022  584F      1488          addq.w    #4,A7
00001024  1400      1489          move.b    D0,D2
                    1490   ; if (c == (char)(0x1b))
00001026  0C02 001B 1491          cmp.b     #27,D2
0000102A  6604      1492          bne.s     MemoryChange_4
                    1493   ; return;                                // abort on escape
0000102C  6000 0090 1494          bra       MemoryChange_6
                    1495   MemoryChange_4:
                    1496   ; else if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {  // are we trying to change data at this location by entering a hex char
00001030  0C02 0030 1497          cmp.b     #48,D2
00001034  6506      1498          blo.s     MemoryChange_10
00001036  0C02 0039 1499          cmp.b     #57,D2
0000103A  6310      1500          bls.s     MemoryChange_9
                    1501   MemoryChange_10:
0000103C  0C02 0061 1502          cmp.b     #97,D2
00001040  6500 006E 1503          blo       MemoryChange_7
00001044  0C02 0066 1504          cmp.b     #102,D2
00001048  6200 0066 1505          bhi       MemoryChange_7
                    1506   MemoryChange_9:
                    1507   ; Data = (xtod(c) << 4) | (xtod(_getch()));
0000104C  C4BC 0000 1508          and.l     #255,D2
00001050  00FF      
00001052  2F02      1509          move.l    D2,-(A7)
00001054  4EB8 0BD2 1510          jsr       _xtod
00001058  584F      1511          addq.w    #4,A7
0000105A  C0BC 0000 1512          and.l     #255,D0
0000105E  00FF      
00001060  E980      1513          asl.l     #4,D0
00001062  2F00      1514          move.l    D0,-(A7)
00001064  2F01      1515          move.l    D1,-(A7)
00001066  4EB8 0B68 1516          jsr       __getch
0000106A  221F      1517          move.l    (A7)+,D1
0000106C  2F00      1518          move.l    D0,-(A7)
0000106E  4EB8 0BD2 1519          jsr       _xtod
00001072  584F      1520          addq.w    #4,A7
00001074  2200      1521          move.l    D0,D1
00001076  201F      1522          move.l    (A7)+,D0
00001078  C2BC 0000 1523          and.l     #255,D1
0000107C  00FF      
0000107E  8081      1524          or.l      D1,D0
00001080  2800      1525          move.l    D0,D4
                    1526   ; *RamPtr = (char)(Data);
00001082  2043      1527          move.l    D3,A0
00001084  1084      1528          move.b    D4,(A0)
                    1529   ; if (*RamPtr != Data) {
00001086  2043      1530          move.l    D3,A0
00001088  1010      1531          move.b    (A0),D0
0000108A  C0BC 0000 1532          and.l     #255,D0
0000108E  00FF      
00001090  B084      1533          cmp.l     D4,D0
00001092  671A      1534          beq.s     MemoryChange_11
                    1535   ; printf("\r\nWarning Change Failed: Wrote [%02x], Read [%02x]", Data, *RamPtr);
00001094  2043      1536          move.l    D3,A0
00001096  1210      1537          move.b    (A0),D1
00001098  C2BC 0000 1538          and.l     #255,D1
0000109C  00FF      
0000109E  2F01      1539          move.l    D1,-(A7)
000010A0  2F04      1540          move.l    D4,-(A7)
000010A2  4879 0000 1541          pea       @lab6b_21.L
000010A6  4EF6      
000010A8  4E92      1542          jsr       (A2)
000010AA  DEFC 000C 1543          add.w     #12,A7
                    1544   MemoryChange_11:
000010AE  6008      1545          bra.s     MemoryChange_13
                    1546   MemoryChange_7:
                    1547   ; }
                    1548   ; }
                    1549   ; else if (c == (char)('-'))
000010B0  0C02 002D 1550          cmp.b     #45,D2
000010B4  6602      1551          bne.s     MemoryChange_13
                    1552   ; RamPtr -= 2; ;
000010B6  5583      1553          subq.l    #2,D3
                    1554   MemoryChange_13:
                    1555   ; RamPtr++;
000010B8  5283      1556          addq.l    #1,D3
000010BA  6000 FF3A 1557          bra       MemoryChange_1
                    1558   MemoryChange_6:
000010BE  4CDF 041C 1559          movem.l   (A7)+,D2/D3/D4/A2
000010C2  4E75      1560          rts
                    1561   ; }
                    1562   ; }
                    1563   ; /******************************************************************************************
                    1564   ; ** The following code is for the SPI controller
                    1565   ; *******************************************************************************************/
                    1566   ; // return true if the SPI has finished transmitting a byte (to say the Flash chip) return false otherwise
                    1567   ; // this can be used in a polling algorithm to know when the controller is busy or idle.
                    1568   ; int TestForSPITransmitDataComplete(void)    {
                    1569   _TestForSPITransmitDataComplete:
000010C4  4E56 FFFC 1570          link      A6,#-4
                    1571   ; /* TODO replace 0 below with a test for status register SPIF bit and if set, return true */
                    1572   ; int SPIF = SPI_Status >> 7;
000010C8  1039 0040 1573          move.b    4227106,D0
000010CC  8022      
000010CE  C0BC 0000 1574          and.l     #255,D0
000010D2  00FF      
000010D4  EE88      1575          lsr.l     #7,D0
000010D6  2D40 FFFC 1576          move.l    D0,-4(A6)
                    1577   ; return SPIF;
000010DA  202E FFFC 1578          move.l    -4(A6),D0
000010DE  4E5E      1579          unlk      A6
000010E0  4E75      1580          rts
                    1581   ; }
                    1582   ; /************************************************************************************
                    1583   ; ** initialises the SPI controller chip to set speed, interrupt capability etc.
                    1584   ; ************************************************************************************/
                    1585   ; void SPI_Init(void)
                    1586   ; {
                    1587   _SPI_Init:
                    1588   ; //TODO
                    1589   ; //
                    1590   ; // Program the SPI Control, EXT, CS and Status registers to initialise the SPI controller
                    1591   ; // Don't forget to call this routine from main() before you do anything else with SPI
                    1592   ; //
                    1593   ; // Here are some settings we want to create
                    1594   ; //
                    1595   ; // Control Reg     - interrupts disabled, core enabled, Master mode, Polarity and Phase of clock = [0,0], speed =  divide by 32 = approx 700Khz
                    1596   ; // Ext Reg         - in conjunction with control reg, sets speed above and also sets interrupt flag after every completed transfer (each byte)
                    1597   ; // SPI_CS Reg      - control selection of slave SPI chips via their CS# signals
                    1598   ; // Status Reg      - status of SPI controller chip and used to clear any write collision and interrupt on transmit complete flag
                    1599   ; SPI_Control = (unsigned char) 0x53; // 0101_0011
000010E2  13FC 0053 1600          move.b    #83,4227104
000010E6  0040 8020 
                    1601   ; SPI_Ext = (unsigned char) 0x00; // 00_0000_00
000010EA  4239 0040 1602          clr.b     4227110
000010EE  8026      
                    1603   ; Disable_SPI_CS();
000010F0  13FC 00FF 1604          move.b    #255,4227112
000010F4  0040 8028 
                    1605   ; SPI_Status = (unsigned char) 0xC0; // 1100_0000
000010F8  13FC 00C0 1606          move.b    #192,4227106
000010FC  0040 8022 
00001100  4E75      1607          rts
                    1608   ; }
                    1609   ; /************************************************************************************
                    1610   ; ** return ONLY when the SPI controller has finished transmitting a byte
                    1611   ; ************************************************************************************/
                    1612   ; void WaitForSPITransmitComplete(void)
                    1613   ; {
                    1614   _WaitForSPITransmitComplete:
                    1615   ; // TODO : poll the status register SPIF bit looking for completion of transmission
                    1616   ; // once transmission is complete, clear the write collision and interrupt on transmit complete flags in the status register (read documentation)
                    1617   ; // just in case they were set
                    1618   ; while(!TestForSPITransmitDataComplete()) {}
                    1619   WaitForSPITransmitComplete_1:
00001102  4EB8 10C4 1620          jsr       _TestForSPITransmitDataComplete
00001106  4A80      1621          tst.l     D0
00001108  6602      1622          bne.s     WaitForSPITransmitComplete_3
0000110A  60F6      1623          bra       WaitForSPITransmitComplete_1
                    1624   WaitForSPITransmitComplete_3:
                    1625   ; SPI_Status = (unsigned char) 0xC0; // 1100_0000
0000110C  13FC 00C0 1626          move.b    #192,4227106
00001110  0040 8022 
00001114  4E75      1627          rts
                    1628   ; }
                    1629   ; /************************************************************************************
                    1630   ; ** Write a byte to the SPI flash chip via the controller and returns (reads) whatever was
                    1631   ; ** given back by SPI device at the same time (removes the read byte from the FIFO)
                    1632   ; ************************************************************************************/
                    1633   ; int WriteSPIChar(int c)
                    1634   ; {
                    1635   _WriteSPIChar:
00001116  4E56 FFFC 1636          link      A6,#-4
                    1637   ; // todo - write the byte in parameter 'c' to the SPI data register, this will start it transmitting to the flash device
                    1638   ; // wait for completion of transmission
                    1639   ; // return the received data from Flash chip (which may not be relevent depending upon what we are doing)
                    1640   ; // by reading fom the SPI controller Data Register.
                    1641   ; // note however that in order to get data from an SPI slave device (e.g. flash) chip we have to write a dummy byte to it
                    1642   ; //
                    1643   ; // modify '0' below to return back read byte from data register
                    1644   ; //
                    1645   ; int read_data;
                    1646   ; SPI_Data = c;
0000111A  202E 0008 1647          move.l    8(A6),D0
0000111E  13C0 0040 1648          move.b    D0,4227108
00001122  8024      
                    1649   ; WaitForSPITransmitComplete();
00001124  4EB8 1102 1650          jsr       _WaitForSPITransmitComplete
                    1651   ; read_data = SPI_Data;
00001128  1039 0040 1652          move.b    4227108,D0
0000112C  8024      
0000112E  C0BC 0000 1653          and.l     #255,D0
00001132  00FF      
00001134  2D40 FFFC 1654          move.l    D0,-4(A6)
                    1655   ; return read_data;            
00001138  202E FFFC 1656          move.l    -4(A6),D0
0000113C  4E5E      1657          unlk      A6
0000113E  4E75      1658          rts
                    1659   ; }
                    1660   ; void SendFlashCmd(int cmd)
                    1661   ; {
                    1662   _SendFlashCmd:
00001140  4E56 0000 1663          link      A6,#0
                    1664   ; Enable_SPI_CS();
00001144  13FC 00FE 1665          move.b    #254,4227112
00001148  0040 8028 
                    1666   ; WriteSPIChar(cmd); 
0000114C  2F2E 0008 1667          move.l    8(A6),-(A7)
00001150  4EB8 1116 1668          jsr       _WriteSPIChar
00001154  584F      1669          addq.w    #4,A7
                    1670   ; Disable_SPI_CS();
00001156  13FC 00FF 1671          move.b    #255,4227112
0000115A  0040 8028 
0000115E  4E5E      1672          unlk      A6
00001160  4E75      1673          rts
                    1674   ; }
                    1675   ; void SendFlashCmdAndAddr(int cmd, int addr)
                    1676   ; {
                    1677   _SendFlashCmdAndAddr:
00001162  4E56 0000 1678          link      A6,#0
00001166  48E7 2020 1679          movem.l   D2/A2,-(A7)
0000116A  45F8 1116 1680          lea       _WriteSPIChar.L,A2
0000116E  242E 000C 1681          move.l    12(A6),D2
                    1682   ; WriteSPIChar(cmd);
00001172  2F2E 0008 1683          move.l    8(A6),-(A7)
00001176  4E92      1684          jsr       (A2)
00001178  584F      1685          addq.w    #4,A7
                    1686   ; WriteSPIChar(addr >> 16);
0000117A  2202      1687          move.l    D2,D1
0000117C  E081      1688          asr.l     #8,D1
0000117E  E081      1689          asr.l     #8,D1
00001180  2F01      1690          move.l    D1,-(A7)
00001182  4E92      1691          jsr       (A2)
00001184  584F      1692          addq.w    #4,A7
                    1693   ; WriteSPIChar(addr >> 8);
00001186  2202      1694          move.l    D2,D1
00001188  E081      1695          asr.l     #8,D1
0000118A  2F01      1696          move.l    D1,-(A7)
0000118C  4E92      1697          jsr       (A2)
0000118E  584F      1698          addq.w    #4,A7
                    1699   ; WriteSPIChar(addr);
00001190  2F02      1700          move.l    D2,-(A7)
00001192  4E92      1701          jsr       (A2)
00001194  584F      1702          addq.w    #4,A7
00001196  4CDF 0404 1703          movem.l   (A7)+,D2/A2
0000119A  4E5E      1704          unlk      A6
0000119C  4E75      1705          rts
                    1706   ; }
                    1707   ; void WaitFlashIdle(void)
                    1708   ; {
                    1709   _WaitFlashIdle:
                    1710   ; Enable_SPI_CS();
0000119E  13FC 00FE 1711          move.b    #254,4227112
000011A2  0040 8028 
                    1712   ; WriteSPIChar(0x05);  // read status
000011A6  4878 0005 1713          pea       5
000011AA  4EB8 1116 1714          jsr       _WriteSPIChar
000011AE  584F      1715          addq.w    #4,A7
                    1716   ; while(WriteSPIChar(0x00) & 0x01){}; // wait until idle
                    1717   WaitFlashIdle_1:
000011B0  42A7      1718          clr.l     -(A7)
000011B2  4EB8 1116 1719          jsr       _WriteSPIChar
000011B6  584F      1720          addq.w    #4,A7
000011B8  C0BC 0000 1721          and.l     #1,D0
000011BC  0001      
000011BE  6702      1722          beq.s     WaitFlashIdle_3
000011C0  60EE      1723          bra       WaitFlashIdle_1
                    1724   WaitFlashIdle_3:
                    1725   ; Disable_SPI_CS();
000011C2  13FC 00FF 1726          move.b    #255,4227112
000011C6  0040 8028 
000011CA  4E75      1727          rts
                    1728   ; }
                    1729   ; void EraseSPIFlashChip(void)
                    1730   ; {
                    1731   _EraseSPIFlashChip:
                    1732   ; SendFlashCmd(0x06);  // write enable
000011CC  4878 0006 1733          pea       6
000011D0  4EB8 1140 1734          jsr       _SendFlashCmd
000011D4  584F      1735          addq.w    #4,A7
                    1736   ; SendFlashCmd(0xC7);  // erase chip
000011D6  4878 00C7 1737          pea       199
000011DA  4EB8 1140 1738          jsr       _SendFlashCmd
000011DE  584F      1739          addq.w    #4,A7
                    1740   ; WaitFlashIdle();
000011E0  4EB8 119E 1741          jsr       _WaitFlashIdle
000011E4  4E75      1742          rts
                    1743   ; }
                    1744   ; void SPIFlashProgram(int AddressOffset, int ByteData)
                    1745   ; {
                    1746   _SPIFlashProgram:
000011E6  4E56 FFFC 1747          link      A6,#-4
                    1748   ; int readbackdata;
                    1749   ; SendFlashCmd(0x06);  // write enable
000011EA  4878 0006 1750          pea       6
000011EE  4EB8 1140 1751          jsr       _SendFlashCmd
000011F2  584F      1752          addq.w    #4,A7
                    1753   ; Enable_SPI_CS();
000011F4  13FC 00FE 1754          move.b    #254,4227112
000011F8  0040 8028 
                    1755   ; SendFlashCmdAndAddr(0x02, AddressOffset); // page program
000011FC  2F2E 0008 1756          move.l    8(A6),-(A7)
00001200  4878 0002 1757          pea       2
00001204  4EB8 1162 1758          jsr       _SendFlashCmdAndAddr
00001208  504F      1759          addq.w    #8,A7
                    1760   ; // if (AddressOffset == 0) {
                    1761   ; //     printf("ByteData: 0x%08x", ByteData);
                    1762   ; // }
                    1763   ; readbackdata = WriteSPIChar(ByteData); // write byte data
0000120A  2F2E 000C 1764          move.l    12(A6),-(A7)
0000120E  4EB8 1116 1765          jsr       _WriteSPIChar
00001212  584F      1766          addq.w    #4,A7
00001214  2D40 FFFC 1767          move.l    D0,-4(A6)
                    1768   ; Disable_SPI_CS();
00001218  13FC 00FF 1769          move.b    #255,4227112
0000121C  0040 8028 
                    1770   ; WaitFlashIdle();  // wait idle
00001220  4EB8 119E 1771          jsr       _WaitFlashIdle
00001224  4E5E      1772          unlk      A6
00001226  4E75      1773          rts
                    1774   ; }
                    1775   ; void WriteSPIFlashData(int FlashAddress, unsigned char *MemoryAddress, int size)
                    1776   ; {
                    1777   _WriteSPIFlashData:
00001228  4E56 0000 1778          link      A6,#0
0000122C  2F02      1779          move.l    D2,-(A7)
                    1780   ; int addressOffset = 0;
0000122E  4282      1781          clr.l     D2
                    1782   ; for (addressOffset = 0; addressOffset < size; addressOffset++) {
00001230  4282      1783          clr.l     D2
                    1784   WriteSPIFlashData_1:
00001232  B4AE 0010 1785          cmp.l     16(A6),D2
00001236  6C00 003C 1786          bge       WriteSPIFlashData_3
                    1787   ; SPIFlashProgram(addressOffset + FlashAddress, MemoryAddress[addressOffset]);
0000123A  206E 000C 1788          move.l    12(A6),A0
0000123E  1230 2800 1789          move.b    0(A0,D2.L),D1
00001242  C2BC 0000 1790          and.l     #255,D1
00001246  00FF      
00001248  2F01      1791          move.l    D1,-(A7)
0000124A  2202      1792          move.l    D2,D1
0000124C  D2AE 0008 1793          add.l     8(A6),D1
00001250  2F01      1794          move.l    D1,-(A7)
00001252  4EB8 11E6 1795          jsr       _SPIFlashProgram
00001256  504F      1796          addq.w    #8,A7
                    1797   ; if (addressOffset % 32768 == 0){
00001258  2002      1798          move.l    D2,D0
0000125A  C0BC 0000 1799          and.l     #32767,D0
0000125E  7FFF      
00001260  660E      1800          bne.s     WriteSPIFlashData_4
                    1801   ; printf(".");
00001262  4879 0000 1802          pea       @lab6b_22.L
00001266  4F2A      
00001268  4EB9 0000 1803          jsr       _printf
0000126C  43B8      
0000126E  584F      1804          addq.w    #4,A7
                    1805   WriteSPIFlashData_4:
00001270  5282      1806          addq.l    #1,D2
00001272  60BE      1807          bra       WriteSPIFlashData_1
                    1808   WriteSPIFlashData_3:
00001274  241F      1809          move.l    (A7)+,D2
00001276  4E5E      1810          unlk      A6
00001278  4E75      1811          rts
                    1812   ; }
                    1813   ; }
                    1814   ; }
                    1815   ; int SPIFlashRead(int AddressOffset)
                    1816   ; {
                    1817   _SPIFlashRead:
0000127A  4E56 FFFC 1818          link      A6,#-4
                    1819   ; int data;
                    1820   ; Enable_SPI_CS();
0000127E  13FC 00FE 1821          move.b    #254,4227112
00001282  0040 8028 
                    1822   ; SendFlashCmdAndAddr(0x03, AddressOffset); // read
00001286  2F2E 0008 1823          move.l    8(A6),-(A7)
0000128A  4878 0003 1824          pea       3
0000128E  4EB8 1162 1825          jsr       _SendFlashCmdAndAddr
00001292  504F      1826          addq.w    #8,A7
                    1827   ; data = WriteSPIChar(0x00); // dummy
00001294  42A7      1828          clr.l     -(A7)
00001296  4EB8 1116 1829          jsr       _WriteSPIChar
0000129A  584F      1830          addq.w    #4,A7
0000129C  2D40 FFFC 1831          move.l    D0,-4(A6)
                    1832   ; // if (AddressOffset == 0) {
                    1833   ; //     printf("ByteData: 0x%08x", data);
                    1834   ; // }
                    1835   ; Disable_SPI_CS();
000012A0  13FC 00FF 1836          move.b    #255,4227112
000012A4  0040 8028 
                    1837   ; return data;
000012A8  202E FFFC 1838          move.l    -4(A6),D0
000012AC  4E5E      1839          unlk      A6
000012AE  4E75      1840          rts
                    1841   ; }
                    1842   ; void ReadSPIFlashData(int FlashAddress, unsigned char *MemoryAddress, int size)
                    1843   ; {
                    1844   _ReadSPIFlashData:
000012B0  4E56 0000 1845          link      A6,#0
000012B4  2F02      1846          move.l    D2,-(A7)
                    1847   ; int addressOffset;
                    1848   ; for (addressOffset = 0; addressOffset < size; addressOffset++)
000012B6  4282      1849          clr.l     D2
                    1850   ReadSPIFlashData_1:
000012B8  B4AE 0010 1851          cmp.l     16(A6),D2
000012BC  6C1A      1852          bge.s     ReadSPIFlashData_3
                    1853   ; {
                    1854   ; MemoryAddress[addressOffset] = SPIFlashRead(FlashAddress+addressOffset);
000012BE  222E 0008 1855          move.l    8(A6),D1
000012C2  D282      1856          add.l     D2,D1
000012C4  2F01      1857          move.l    D1,-(A7)
000012C6  4EB8 127A 1858          jsr       _SPIFlashRead
000012CA  584F      1859          addq.w    #4,A7
000012CC  206E 000C 1860          move.l    12(A6),A0
000012D0  1180 2800 1861          move.b    D0,0(A0,D2.L)
000012D4  5282      1862          addq.l    #1,D2
000012D6  60E0      1863          bra       ReadSPIFlashData_1
                    1864   ReadSPIFlashData_3:
000012D8  241F      1865          move.l    (A7)+,D2
000012DA  4E5E      1866          unlk      A6
000012DC  4E75      1867          rts
                    1868   ; }
                    1869   ; }
                    1870   ; /*******************************************************************
                    1871   ; ** Write a program to SPI Flash Chip from memory and verify by reading back
                    1872   ; ********************************************************************/
                    1873   ; void ProgramFlashChip(void)
                    1874   ; {
                    1875   _ProgramFlashChip:
000012DE  4E56 FF00 1876          link      A6,#-256
000012E2  48E7 3C30 1877          movem.l   D2/D3/D4/D5/A2/A3,-(A7)
000012E6  45F9 0000 1878          lea       _printf.L,A2
000012EA  43B8      
000012EC  47EE FF00 1879          lea       -256(A6),A3
                    1880   ; //
                    1881   ; // TODO : put your code here to program the 1st 256k of ram (where user program is held at hex 08000000) to SPI flash chip
                    1882   ; // TODO : then verify by reading it back and comparing to memory
                    1883   ; //
                    1884   ; unsigned char * dataPtr = 0x08000000;
000012F0  263C 0800 1885          move.l    #134217728,D3
000012F4  0000      
                    1886   ; int flashAddress = 0;
000012F6  4285      1887          clr.l     D5
                    1888   ; int i = 0;
000012F8  4284      1889          clr.l     D4
                    1890   ; unsigned char readBuffer[256];
                    1891   ; int bufferOffset = 0;
000012FA  4282      1892          clr.l     D2
                    1893   ; printf("\n\rErasing\n\r");
000012FC  4879 0000 1894          pea       @lab6b_23.L
00001300  4F2C      
00001302  4E92      1895          jsr       (A2)
00001304  584F      1896          addq.w    #4,A7
                    1897   ; EraseSPIFlashChip();
00001306  4EB8 11CC 1898          jsr       _EraseSPIFlashChip
                    1899   ; printf("Writing Program to memory \n\r");
0000130A  4879 0000 1900          pea       @lab6b_24.L
0000130E  4F38      
00001310  4E92      1901          jsr       (A2)
00001312  584F      1902          addq.w    #4,A7
                    1903   ; WriteSPIFlashData(0, dataPtr, 262144); // 256kB = 256 * 1024 = 262144
00001314  4879 0004 1904          pea       262144
00001318  0000      
0000131A  2F03      1905          move.l    D3,-(A7)
0000131C  42A7      1906          clr.l     -(A7)
0000131E  4EB8 1228 1907          jsr       _WriteSPIFlashData
00001322  DEFC 000C 1908          add.w     #12,A7
                    1909   ; printf("Writing Done\n\r");
00001326  4879 0000 1910          pea       @lab6b_25.L
0000132A  4F56      
0000132C  4E92      1911          jsr       (A2)
0000132E  584F      1912          addq.w    #4,A7
                    1913   ; dataPtr = 0x08000000; // reset address
00001330  263C 0800 1914          move.l    #134217728,D3
00001334  0000      
                    1915   ; printf("Reading Program from memory\n\r");
00001336  4879 0000 1916          pea       @lab6b_26.L
0000133A  4F66      
0000133C  4E92      1917          jsr       (A2)
0000133E  584F      1918          addq.w    #4,A7
                    1919   ; for (i = 0; i < 1024; i++) {
00001340  4284      1920          clr.l     D4
                    1921   ProgramFlashChip_1:
00001342  0C84 0000 1922          cmp.l     #1024,D4
00001346  0400      
00001348  6C00 0090 1923          bge       ProgramFlashChip_3
                    1924   ; ReadSPIFlashData(flashAddress, readBuffer, 256);
0000134C  4878 0100 1925          pea       256
00001350  2F0B      1926          move.l    A3,-(A7)
00001352  2F05      1927          move.l    D5,-(A7)
00001354  4EB8 12B0 1928          jsr       _ReadSPIFlashData
00001358  DEFC 000C 1929          add.w     #12,A7
                    1930   ; for (bufferOffset = 0; bufferOffset < 256; bufferOffset++){
0000135C  4282      1931          clr.l     D2
                    1932   ProgramFlashChip_4:
0000135E  0C82 0000 1933          cmp.l     #256,D2
00001362  0100      
00001364  6C00 0042 1934          bge       ProgramFlashChip_6
                    1935   ; if (dataPtr[bufferOffset] != readBuffer[bufferOffset]){
00001368  2043      1936          move.l    D3,A0
0000136A  1030 2800 1937          move.b    0(A0,D2.L),D0
0000136E  B033 2800 1938          cmp.b     0(A3,D2.L),D0
00001372  6730      1939          beq.s     ProgramFlashChip_7
                    1940   ; printf("\r\nERROR: DATA Mismatch at addr 0x%08x. WRITE: 0x%02x READ: 0x%02x\r\n", &dataPtr[bufferOffset], dataPtr[bufferOffset], readBuffer[bufferOffset]);
00001374  1233 2800 1941          move.b    0(A3,D2.L),D1
00001378  C2BC 0000 1942          and.l     #255,D1
0000137C  00FF      
0000137E  2F01      1943          move.l    D1,-(A7)
00001380  2043      1944          move.l    D3,A0
00001382  1230 2800 1945          move.b    0(A0,D2.L),D1
00001386  C2BC 0000 1946          and.l     #255,D1
0000138A  00FF      
0000138C  2F01      1947          move.l    D1,-(A7)
0000138E  2203      1948          move.l    D3,D1
00001390  D282      1949          add.l     D2,D1
00001392  2F01      1950          move.l    D1,-(A7)
00001394  4879 0000 1951          pea       @lab6b_27.L
00001398  4F84      
0000139A  4E92      1952          jsr       (A2)
0000139C  DEFC 0010 1953          add.w     #16,A7
                    1954   ; return;
000013A0  6000 0042 1955          bra       ProgramFlashChip_9
                    1956   ProgramFlashChip_7:
000013A4  5282      1957          addq.l    #1,D2
000013A6  60B6      1958          bra       ProgramFlashChip_4
                    1959   ProgramFlashChip_6:
                    1960   ; }
                    1961   ; }
                    1962   ; flashAddress += 256;
000013A8  0685 0000 1963          add.l     #256,D5
000013AC  0100      
                    1964   ; dataPtr += 256;
000013AE  0683 0000 1965          add.l     #256,D3
000013B2  0100      
                    1966   ; if (i % 128 == 0){
000013B4  2F04      1967          move.l    D4,-(A7)
000013B6  4878 0080 1968          pea       128
000013BA  4EB9 0000 1969          jsr       LDIV
000013BE  41DE      
000013C0  202F 0004 1970          move.l    4(A7),D0
000013C4  504F      1971          addq.w    #8,A7
000013C6  4A80      1972          tst.l     D0
000013C8  660A      1973          bne.s     ProgramFlashChip_10
                    1974   ; printf(".");
000013CA  4879 0000 1975          pea       @lab6b_22.L
000013CE  4F2A      
000013D0  4E92      1976          jsr       (A2)
000013D2  584F      1977          addq.w    #4,A7
                    1978   ProgramFlashChip_10:
000013D4  5284      1979          addq.l    #1,D4
000013D6  6000 FF6A 1980          bra       ProgramFlashChip_1
                    1981   ProgramFlashChip_3:
                    1982   ; }
                    1983   ; }
                    1984   ; printf("PASS\n\r");
000013DA  4879 0000 1985          pea       @lab6b_28.L
000013DE  4FC8      
000013E0  4E92      1986          jsr       (A2)
000013E2  584F      1987          addq.w    #4,A7
                    1988   ProgramFlashChip_9:
000013E4  4CDF 0C3C 1989          movem.l   (A7)+,D2/D3/D4/D5/A2/A3
000013E8  4E5E      1990          unlk      A6
000013EA  4E75      1991          rts
                    1992   ; }
                    1993   ; /*************************************************************************
                    1994   ; ** Load a program from SPI Flash Chip and copy to Dram
                    1995   ; **************************************************************************/
                    1996   ; void LoadFromFlashChip(void)
                    1997   ; {
                    1998   _LoadFromFlashChip:
000013EC  4E56 FF00 1999          link      A6,#-256
000013F0  48E7 3C30 2000          movem.l   D2/D3/D4/D5/A2/A3,-(A7)
000013F4  45F9 0000 2001          lea       _printf.L,A2
000013F8  43B8      
000013FA  47EE FF00 2002          lea       -256(A6),A3
                    2003   ; unsigned int flashAddress = 0;
000013FE  4285      2004          clr.l     D5
                    2005   ; unsigned char * dataPtr = 0x08000000;
00001400  283C 0800 2006          move.l    #134217728,D4
00001404  0000      
                    2007   ; unsigned int i = 0, j = 0;
00001406  4283      2008          clr.l     D3
00001408  4282      2009          clr.l     D2
                    2010   ; unsigned char readBuffer[256];
                    2011   ; printf("\r\nLoading Program From SPI Flash....");
0000140A  4879 0000 2012          pea       @lab6b_29.L
0000140E  4FD0      
00001410  4E92      2013          jsr       (A2)
00001412  584F      2014          addq.w    #4,A7
                    2015   ; //
                    2016   ; // TODO : put your code here to read 256k of data from SPI flash chip and store in user ram starting at hex 08000000
                    2017   ; //
                    2018   ; for (i = 0; i < 1024; i++){
00001414  4283      2019          clr.l     D3
                    2020   LoadFromFlashChip_1:
00001416  0C83 0000 2021          cmp.l     #1024,D3
0000141A  0400      
0000141C  6400 0076 2022          bhs       LoadFromFlashChip_3
                    2023   ; ReadSPIFlashData(flashAddress, readBuffer, 256);
00001420  4878 0100 2024          pea       256
00001424  2F0B      2025          move.l    A3,-(A7)
00001426  2F05      2026          move.l    D5,-(A7)
00001428  4EB8 12B0 2027          jsr       _ReadSPIFlashData
0000142C  DEFC 000C 2028          add.w     #12,A7
                    2029   ; if (i == 0) {
00001430  4A83      2030          tst.l     D3
00001432  661A      2031          bne.s     LoadFromFlashChip_6
                    2032   ; if (readBuffer[0] == 0xFF) {
00001434  1013      2033          move.b    (A3),D0
00001436  C07C 00FF 2034          and.w     #255,D0
0000143A  0C40 00FF 2035          cmp.w     #255,D0
0000143E  660E      2036          bne.s     LoadFromFlashChip_6
                    2037   ; printf("garbage value read!\r\n");
00001440  4879 0000 2038          pea       @lab6b_30.L
00001444  4FF6      
00001446  4E92      2039          jsr       (A2)
00001448  584F      2040          addq.w    #4,A7
                    2041   ; return;
0000144A  6000 0052 2042          bra       LoadFromFlashChip_8
                    2043   LoadFromFlashChip_6:
                    2044   ; }
                    2045   ; }
                    2046   ; for (j = 0; j < 256; j++){
0000144E  4282      2047          clr.l     D2
                    2048   LoadFromFlashChip_9:
00001450  0C82 0000 2049          cmp.l     #256,D2
00001454  0100      
00001456  640C      2050          bhs.s     LoadFromFlashChip_11
                    2051   ; dataPtr[j] = readBuffer[j];
00001458  2044      2052          move.l    D4,A0
0000145A  11B3 2800 2053          move.b    0(A3,D2.L),0(A0,D2.L)
0000145E  2800      
00001460  5282      2054          addq.l    #1,D2
00001462  60EC      2055          bra       LoadFromFlashChip_9
                    2056   LoadFromFlashChip_11:
                    2057   ; }
                    2058   ; dataPtr+=256;
00001464  0684 0000 2059          add.l     #256,D4
00001468  0100      
                    2060   ; flashAddress+=256;
0000146A  0685 0000 2061          add.l     #256,D5
0000146E  0100      
                    2062   ; if (i % 128 == 0){
00001470  2F03      2063          move.l    D3,-(A7)
00001472  4878 0080 2064          pea       128
00001476  4EB9 0000 2065          jsr       ULDIV
0000147A  41CC      
0000147C  202F 0004 2066          move.l    4(A7),D0
00001480  504F      2067          addq.w    #8,A7
00001482  4A80      2068          tst.l     D0
00001484  660A      2069          bne.s     LoadFromFlashChip_12
                    2070   ; printf(".");
00001486  4879 0000 2071          pea       @lab6b_22.L
0000148A  4F2A      
0000148C  4E92      2072          jsr       (A2)
0000148E  584F      2073          addq.w    #4,A7
                    2074   LoadFromFlashChip_12:
00001490  5283      2075          addq.l    #1,D3
00001492  6082      2076          bra       LoadFromFlashChip_1
                    2077   LoadFromFlashChip_3:
                    2078   ; }
                    2079   ; }
                    2080   ; printf("\r\nDone loading.\r\n");
00001494  4879 0000 2081          pea       @lab6b_31.L
00001498  500C      
0000149A  4E92      2082          jsr       (A2)
0000149C  584F      2083          addq.w    #4,A7
                    2084   LoadFromFlashChip_8:
0000149E  4CDF 0C3C 2085          movem.l   (A7)+,D2/D3/D4/D5/A2/A3
000014A2  4E5E      2086          unlk      A6
000014A4  4E75      2087          rts
                    2088   ; }
                    2089   ; //////////////////////////////////////////////////////////////////////////////////////////////////
                    2090   ; // IMPORTANT
                    2091   ; // TG68 does not support the Native Trace mode of the original 68000 so tracing
                    2092   ; // has to be done with an interrupt (IRQ Level 6)
                    2093   ; //
                    2094   ; // To allow the 68000 to execute one more instruction after each pseudo trace (IRQ6)
                    2095   ; // the IRQ is removed in hardware once the TG68 reads the IRQ autovector (i.e. acknowledges the IRQ)
                    2096   ; //
                    2097   ; // on return from the IRQ service handler, the first access to the user memory program space
                    2098   ; // generates a fresh IRQ (in hardware) to generate a new trace, this allows the tg68 to
                    2099   ; // execute one more new instruction (without it the TG68 would trace on the same instruction
                    2100   ; // each time and not after the next one). It also means it doesn't simgle step outside the user
                    2101   ; // program area
                    2102   ; //
                    2103   ; // The bottom line is the Trace handler, which includes the Dump registers below
                    2104   ; // cannot access the user memory to display for example the Instruction Opcode or to disassemble etc
                    2105   ; // as this would lead to a new IRQ being reset and the TG68 would trace on same instruction
                    2106   ; // NOT SURE THIS IS TRUE NOW THAT TRACE HANDLER HAS BEEN MODIVIED TO NOT AUTOMATICALLY GENERATE A TRACE EXCEPTION
                    2107   ; // INSTEAD IT IS DONE IN THE 'N' COMMAND FOR NEXT
                    2108   ; /////////////////////////////////////////////////////////////////////////////////////////////////////
                    2109   ; void DumpRegisters()
                    2110   ; {
                    2111   _DumpRegisters:
000014A6  48E7 3F3C 2112          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000014AA  45F9 0000 2113          lea       _putch.L,A2
000014AE  42AA      
000014B0  47F9 0000 2114          lea       _printf.L,A3
000014B4  43B8      
000014B6  49F9 0B00 2115          lea       _SR.L,A4
000014BA  012C      
000014BC  4BF9 0B00 2116          lea       _WatchPointString.L,A5
000014C0  01C2      
                    2117   ; short i, x, j, k;
                    2118   ; unsigned char c, * BytePointer;
                    2119   ; // buld up strings for displaying watchpoints
                    2120   ; for (x = 0; x < (short)(8); x++)
000014C2  4242      2121          clr.w     D2
                    2122   DumpRegisters_1:
000014C4  0C42 0008 2123          cmp.w     #8,D2
000014C8  6C00 01C6 2124          bge       DumpRegisters_3
                    2125   ; {
                    2126   ; if (WatchPointSetOrCleared[x] == 1)
000014CC  48C2      2127          ext.l     D2
000014CE  2002      2128          move.l    D2,D0
000014D0  E588      2129          lsl.l     #2,D0
000014D2  41F9 0B00 2130          lea       _WatchPointSetOrCleared.L,A0
000014D6  01A2      
000014D8  2030 0800 2131          move.l    0(A0,D0.L),D0
000014DC  0C80 0000 2132          cmp.l     #1,D0
000014E0  0001      
000014E2  6600 0186 2133          bne       DumpRegisters_4
                    2134   ; {
                    2135   ; sprintf(WatchPointString[x], "$%08X  ", WatchPointAddress[x]);
000014E6  48C2      2136          ext.l     D2
000014E8  2202      2137          move.l    D2,D1
000014EA  E589      2138          lsl.l     #2,D1
000014EC  41F9 0B00 2139          lea       _WatchPointAddress.L,A0
000014F0  0182      
000014F2  2F30 1800 2140          move.l    0(A0,D1.L),-(A7)
000014F6  4879 0000 2141          pea       @lab6b_32.L
000014FA  501E      
000014FC  220D      2142          move.l    A5,D1
000014FE  48C2      2143          ext.l     D2
00001500  2F00      2144          move.l    D0,-(A7)
00001502  2002      2145          move.l    D2,D0
00001504  C1FC 0064 2146          muls      #100,D0
00001508  D280      2147          add.l     D0,D1
0000150A  201F      2148          move.l    (A7)+,D0
0000150C  2F01      2149          move.l    D1,-(A7)
0000150E  4EB9 0000 2150          jsr       _sprintf
00001512  4342      
00001514  DEFC 000C 2151          add.w     #12,A7
                    2152   ; BytePointer = (char*)(WatchPointAddress[x]);
00001518  48C2      2153          ext.l     D2
0000151A  2002      2154          move.l    D2,D0
0000151C  E588      2155          lsl.l     #2,D0
0000151E  41F9 0B00 2156          lea       _WatchPointAddress.L,A0
00001522  0182      
00001524  2A30 0800 2157          move.l    0(A0,D0.L),D5
                    2158   ; for (j = 0; j < (short)(16); j += 2)
00001528  4243      2159          clr.w     D3
                    2160   DumpRegisters_6:
0000152A  0C43 0010 2161          cmp.w     #16,D3
0000152E  6C00 0082 2162          bge       DumpRegisters_8
                    2163   ; {
                    2164   ; for (k = 0; k < (short)(2); k++)
00001532  4246      2165          clr.w     D6
                    2166   DumpRegisters_9:
00001534  0C46 0002 2167          cmp.w     #2,D6
00001538  6C00 0052 2168          bge       DumpRegisters_11
                    2169   ; {
                    2170   ; sprintf(TempString, "%02X", BytePointer[j + k]);
0000153C  2045      2171          move.l    D5,A0
0000153E  48C3      2172          ext.l     D3
00001540  2203      2173          move.l    D3,D1
00001542  48C6      2174          ext.l     D6
00001544  D286      2175          add.l     D6,D1
00001546  1230 1800 2176          move.b    0(A0,D1.L),D1
0000154A  C2BC 0000 2177          and.l     #255,D1
0000154E  00FF      
00001550  2F01      2178          move.l    D1,-(A7)
00001552  4879 0000 2179          pea       @lab6b_8.L
00001556  4D80      
00001558  4879 0B00 2180          pea       _TempString.L
0000155C  04E2      
0000155E  4EB9 0000 2181          jsr       _sprintf
00001562  4342      
00001564  DEFC 000C 2182          add.w     #12,A7
                    2183   ; strcat(WatchPointString[x], TempString);
00001568  4879 0B00 2184          pea       _TempString.L
0000156C  04E2      
0000156E  220D      2185          move.l    A5,D1
00001570  48C2      2186          ext.l     D2
00001572  2F00      2187          move.l    D0,-(A7)
00001574  2002      2188          move.l    D2,D0
00001576  C1FC 0064 2189          muls      #100,D0
0000157A  D280      2190          add.l     D0,D1
0000157C  201F      2191          move.l    (A7)+,D0
0000157E  2F01      2192          move.l    D1,-(A7)
00001580  4EB9 0000 2193          jsr       _strcat
00001584  4376      
00001586  504F      2194          addq.w    #8,A7
00001588  5246      2195          addq.w    #1,D6
0000158A  60A8      2196          bra       DumpRegisters_9
                    2197   DumpRegisters_11:
                    2198   ; }
                    2199   ; strcat(WatchPointString[x], " ");
0000158C  4879 0000 2200          pea       @lab6b_33.L
00001590  5026      
00001592  220D      2201          move.l    A5,D1
00001594  48C2      2202          ext.l     D2
00001596  2F00      2203          move.l    D0,-(A7)
00001598  2002      2204          move.l    D2,D0
0000159A  C1FC 0064 2205          muls      #100,D0
0000159E  D280      2206          add.l     D0,D1
000015A0  201F      2207          move.l    (A7)+,D0
000015A2  2F01      2208          move.l    D1,-(A7)
000015A4  4EB9 0000 2209          jsr       _strcat
000015A8  4376      
000015AA  504F      2210          addq.w    #8,A7
000015AC  5443      2211          addq.w    #2,D3
000015AE  6000 FF7A 2212          bra       DumpRegisters_6
                    2213   DumpRegisters_8:
                    2214   ; }
                    2215   ; strcat(WatchPointString[x], "  ");
000015B2  4879 0000 2216          pea       @lab6b_9.L
000015B6  4D86      
000015B8  220D      2217          move.l    A5,D1
000015BA  48C2      2218          ext.l     D2
000015BC  2F00      2219          move.l    D0,-(A7)
000015BE  2002      2220          move.l    D2,D0
000015C0  C1FC 0064 2221          muls      #100,D0
000015C4  D280      2222          add.l     D0,D1
000015C6  201F      2223          move.l    (A7)+,D0
000015C8  2F01      2224          move.l    D1,-(A7)
000015CA  4EB9 0000 2225          jsr       _strcat
000015CE  4376      
000015D0  504F      2226          addq.w    #8,A7
                    2227   ; BytePointer = (char*)(WatchPointAddress[x]);
000015D2  48C2      2228          ext.l     D2
000015D4  2002      2229          move.l    D2,D0
000015D6  E588      2230          lsl.l     #2,D0
000015D8  41F9 0B00 2231          lea       _WatchPointAddress.L,A0
000015DC  0182      
000015DE  2A30 0800 2232          move.l    0(A0,D0.L),D5
                    2233   ; for (j = 0; j < (short)(16); j++)
000015E2  4243      2234          clr.w     D3
                    2235   DumpRegisters_12:
000015E4  0C43 0010 2236          cmp.w     #16,D3
000015E8  6C00 007E 2237          bge       DumpRegisters_14
                    2238   ; {
                    2239   ; c = ((char)(BytePointer[j]) & 0x7f);
000015EC  2045      2240          move.l    D5,A0
000015EE  48C3      2241          ext.l     D3
000015F0  1030 3800 2242          move.b    0(A0,D3.L),D0
000015F4  C03C 007F 2243          and.b     #127,D0
000015F8  1E00      2244          move.b    D0,D7
                    2245   ; if ((c > (char)(0x7f)) || (c < (char)(' ')))
000015FA  0C07 007F 2246          cmp.b     #127,D7
000015FE  6206      2247          bhi.s     DumpRegisters_17
00001600  0C07 0020 2248          cmp.b     #32,D7
00001604  6416      2249          bhs.s     DumpRegisters_15
                    2250   DumpRegisters_17:
                    2251   ; sprintf(TempString, ".");
00001606  4879 0000 2252          pea       @lab6b_22.L
0000160A  4F2A      
0000160C  4879 0B00 2253          pea       _TempString.L
00001610  04E2      
00001612  4EB9 0000 2254          jsr       _sprintf
00001616  4342      
00001618  504F      2255          addq.w    #8,A7
0000161A  6026      2256          bra.s     DumpRegisters_16
                    2257   DumpRegisters_15:
                    2258   ; else
                    2259   ; sprintf(TempString, "%c", BytePointer[j]);
0000161C  2045      2260          move.l    D5,A0
0000161E  48C3      2261          ext.l     D3
00001620  1230 3800 2262          move.b    0(A0,D3.L),D1
00001624  C2BC 0000 2263          and.l     #255,D1
00001628  00FF      
0000162A  2F01      2264          move.l    D1,-(A7)
0000162C  4879 0000 2265          pea       @lab6b_34.L
00001630  5028      
00001632  4879 0B00 2266          pea       _TempString.L
00001636  04E2      
00001638  4EB9 0000 2267          jsr       _sprintf
0000163C  4342      
0000163E  DEFC 000C 2268          add.w     #12,A7
                    2269   DumpRegisters_16:
                    2270   ; strcat(WatchPointString[x], TempString);
00001642  4879 0B00 2271          pea       _TempString.L
00001646  04E2      
00001648  220D      2272          move.l    A5,D1
0000164A  48C2      2273          ext.l     D2
0000164C  2F00      2274          move.l    D0,-(A7)
0000164E  2002      2275          move.l    D2,D0
00001650  C1FC 0064 2276          muls      #100,D0
00001654  D280      2277          add.l     D0,D1
00001656  201F      2278          move.l    (A7)+,D0
00001658  2F01      2279          move.l    D1,-(A7)
0000165A  4EB9 0000 2280          jsr       _strcat
0000165E  4376      
00001660  504F      2281          addq.w    #8,A7
00001662  5243      2282          addq.w    #1,D3
00001664  6000 FF7E 2283          bra       DumpRegisters_12
                    2284   DumpRegisters_14:
00001668  6020      2285          bra.s     DumpRegisters_5
                    2286   DumpRegisters_4:
                    2287   ; }
                    2288   ; }
                    2289   ; else
                    2290   ; strcpy(WatchPointString[x], "");
0000166A  4879 0000 2291          pea       @lab6b_35.L
0000166E  502C      
00001670  220D      2292          move.l    A5,D1
00001672  48C2      2293          ext.l     D2
00001674  2F00      2294          move.l    D0,-(A7)
00001676  2002      2295          move.l    D2,D0
00001678  C1FC 0064 2296          muls      #100,D0
0000167C  D280      2297          add.l     D0,D1
0000167E  201F      2298          move.l    (A7)+,D0
00001680  2F01      2299          move.l    D1,-(A7)
00001682  4EB9 0000 2300          jsr       _strcpy
00001686  41BC      
00001688  504F      2301          addq.w    #8,A7
                    2302   DumpRegisters_5:
0000168A  5242      2303          addq.w    #1,D2
0000168C  6000 FE36 2304          bra       DumpRegisters_1
                    2305   DumpRegisters_3:
                    2306   ; }
                    2307   ; printf("\r\n\r\n D0 = $%08X  A0 = $%08X", d0, a0);
00001690  2F39 0B00 2308          move.l    _a0.L,-(A7)
00001694  0104      
00001696  2F39 0B00 2309          move.l    _d0.L,-(A7)
0000169A  00E4      
0000169C  4879 0000 2310          pea       @lab6b_36.L
000016A0  502E      
000016A2  4E93      2311          jsr       (A3)
000016A4  DEFC 000C 2312          add.w     #12,A7
                    2313   ; printf("\r\n D1 = $%08X  A1 = $%08X", d1, a1);
000016A8  2F39 0B00 2314          move.l    _a1.L,-(A7)
000016AC  0108      
000016AE  2F39 0B00 2315          move.l    _d1.L,-(A7)
000016B2  00E8      
000016B4  4879 0000 2316          pea       @lab6b_37.L
000016B8  504A      
000016BA  4E93      2317          jsr       (A3)
000016BC  DEFC 000C 2318          add.w     #12,A7
                    2319   ; printf("\r\n D2 = $%08X  A2 = $%08X", d2, a2);
000016C0  2F39 0B00 2320          move.l    _a2.L,-(A7)
000016C4  010C      
000016C6  2F39 0B00 2321          move.l    _d2.L,-(A7)
000016CA  00EC      
000016CC  4879 0000 2322          pea       @lab6b_38.L
000016D0  5064      
000016D2  4E93      2323          jsr       (A3)
000016D4  DEFC 000C 2324          add.w     #12,A7
                    2325   ; printf("\r\n D3 = $%08X  A3 = $%08X", d3, a3);
000016D8  2F39 0B00 2326          move.l    _a3.L,-(A7)
000016DC  0110      
000016DE  2F39 0B00 2327          move.l    _d3.L,-(A7)
000016E2  00F0      
000016E4  4879 0000 2328          pea       @lab6b_39.L
000016E8  507E      
000016EA  4E93      2329          jsr       (A3)
000016EC  DEFC 000C 2330          add.w     #12,A7
                    2331   ; printf("\r\n D4 = $%08X  A4 = $%08X", d4, a4);
000016F0  2F39 0B00 2332          move.l    _a4.L,-(A7)
000016F4  0114      
000016F6  2F39 0B00 2333          move.l    _d4.L,-(A7)
000016FA  00F4      
000016FC  4879 0000 2334          pea       @lab6b_40.L
00001700  5098      
00001702  4E93      2335          jsr       (A3)
00001704  DEFC 000C 2336          add.w     #12,A7
                    2337   ; printf("\r\n D5 = $%08X  A5 = $%08X", d5, a5);
00001708  2F39 0B00 2338          move.l    _a5.L,-(A7)
0000170C  0118      
0000170E  2F39 0B00 2339          move.l    _d5.L,-(A7)
00001712  00F8      
00001714  4879 0000 2340          pea       @lab6b_41.L
00001718  50B2      
0000171A  4E93      2341          jsr       (A3)
0000171C  DEFC 000C 2342          add.w     #12,A7
                    2343   ; printf("\r\n D6 = $%08X  A6 = $%08X", d6, a6);
00001720  2F39 0B00 2344          move.l    _a6.L,-(A7)
00001724  011C      
00001726  2F39 0B00 2345          move.l    _d6.L,-(A7)
0000172A  00FC      
0000172C  4879 0000 2346          pea       @lab6b_42.L
00001730  50CC      
00001732  4E93      2347          jsr       (A3)
00001734  DEFC 000C 2348          add.w     #12,A7
                    2349   ; printf("\r\n D7 = $%08X  A7 = $%08X", d7, ((SR & (unsigned short int)(0x2000)) == ((unsigned short int)(0x2000))) ? SSP : USP);
00001738  3214      2350          move.w    (A4),D1
0000173A  C27C 2000 2351          and.w     #8192,D1
0000173E  0C41 2000 2352          cmp.w     #8192,D1
00001742  6608      2353          bne.s     DumpRegisters_18
00001744  2239 0B00 2354          move.l    _SSP.L,D1
00001748  0124      
0000174A  6006      2355          bra.s     DumpRegisters_19
                    2356   DumpRegisters_18:
0000174C  2239 0B00 2357          move.l    _USP.L,D1
00001750  0128      
                    2358   DumpRegisters_19:
00001752  2F01      2359          move.l    D1,-(A7)
00001754  2F39 0B00 2360          move.l    _d7.L,-(A7)
00001758  0100      
0000175A  4879 0000 2361          pea       @lab6b_43.L
0000175E  50E6      
00001760  4E93      2362          jsr       (A3)
00001762  DEFC 000C 2363          add.w     #12,A7
                    2364   ; printf("\r\n\r\nUSP = $%08X  (A7) User SP", USP);
00001766  2F39 0B00 2365          move.l    _USP.L,-(A7)
0000176A  0128      
0000176C  4879 0000 2366          pea       @lab6b_44.L
00001770  5100      
00001772  4E93      2367          jsr       (A3)
00001774  504F      2368          addq.w    #8,A7
                    2369   ; printf("\r\nSSP = $%08X  (A7) Supervisor SP", SSP);
00001776  2F39 0B00 2370          move.l    _SSP.L,-(A7)
0000177A  0124      
0000177C  4879 0000 2371          pea       @lab6b_45.L
00001780  511E      
00001782  4E93      2372          jsr       (A3)
00001784  504F      2373          addq.w    #8,A7
                    2374   ; printf("\r\n SR = $%04X   ", SR);
00001786  3214      2375          move.w    (A4),D1
00001788  C2BC 0000 2376          and.l     #65535,D1
0000178C  FFFF      
0000178E  2F01      2377          move.l    D1,-(A7)
00001790  4879 0000 2378          pea       @lab6b_46.L
00001794  5140      
00001796  4E93      2379          jsr       (A3)
00001798  504F      2380          addq.w    #8,A7
                    2381   ; // display the status word in characters etc.
                    2382   ; printf("   [");
0000179A  4879 0000 2383          pea       @lab6b_47.L
0000179E  5152      
000017A0  4E93      2384          jsr       (A3)
000017A2  584F      2385          addq.w    #4,A7
                    2386   ; if ((SR & (unsigned short int)(0x8000)) == (unsigned short int)(0x8000)) putchar('T'); else putchar('-');      // Trace bit(bit 15)
000017A4  3014      2387          move.w    (A4),D0
000017A6  C07C 8000 2388          and.w     #32768,D0
000017AA  0C40 8000 2389          cmp.w     #32768,D0
000017AE  660A      2390          bne.s     DumpRegisters_20
000017B0  4878 0054 2391          pea       84
000017B4  4E92      2392          jsr       (A2)
000017B6  584F      2393          addq.w    #4,A7
000017B8  6008      2394          bra.s     DumpRegisters_21
                    2395   DumpRegisters_20:
000017BA  4878 002D 2396          pea       45
000017BE  4E92      2397          jsr       (A2)
000017C0  584F      2398          addq.w    #4,A7
                    2399   DumpRegisters_21:
                    2400   ; if ((SR & (unsigned short int)(0x2000)) == (unsigned short int)(0x2000)) putchar('S'); else putchar('U');      // supervisor bit  (bit 13)
000017C2  3014      2401          move.w    (A4),D0
000017C4  C07C 2000 2402          and.w     #8192,D0
000017C8  0C40 2000 2403          cmp.w     #8192,D0
000017CC  660A      2404          bne.s     DumpRegisters_22
000017CE  4878 0053 2405          pea       83
000017D2  4E92      2406          jsr       (A2)
000017D4  584F      2407          addq.w    #4,A7
000017D6  6008      2408          bra.s     DumpRegisters_23
                    2409   DumpRegisters_22:
000017D8  4878 0055 2410          pea       85
000017DC  4E92      2411          jsr       (A2)
000017DE  584F      2412          addq.w    #4,A7
                    2413   DumpRegisters_23:
                    2414   ; if ((SR & (unsigned short int)(0x0400)) == (unsigned short int)(0x0400)) putchar('1'); else putchar('0');      // IRQ2 Bit (bit 10)
000017E0  3014      2415          move.w    (A4),D0
000017E2  C07C 0400 2416          and.w     #1024,D0
000017E6  0C40 0400 2417          cmp.w     #1024,D0
000017EA  660A      2418          bne.s     DumpRegisters_24
000017EC  4878 0031 2419          pea       49
000017F0  4E92      2420          jsr       (A2)
000017F2  584F      2421          addq.w    #4,A7
000017F4  6008      2422          bra.s     DumpRegisters_25
                    2423   DumpRegisters_24:
000017F6  4878 0030 2424          pea       48
000017FA  4E92      2425          jsr       (A2)
000017FC  584F      2426          addq.w    #4,A7
                    2427   DumpRegisters_25:
                    2428   ; if ((SR & (unsigned short int)(0x0200)) == (unsigned short int)(0x0200)) putchar('1'); else putchar('0');      // IRQ1 Bit (bit 9)
000017FE  3014      2429          move.w    (A4),D0
00001800  C07C 0200 2430          and.w     #512,D0
00001804  0C40 0200 2431          cmp.w     #512,D0
00001808  660A      2432          bne.s     DumpRegisters_26
0000180A  4878 0031 2433          pea       49
0000180E  4E92      2434          jsr       (A2)
00001810  584F      2435          addq.w    #4,A7
00001812  6008      2436          bra.s     DumpRegisters_27
                    2437   DumpRegisters_26:
00001814  4878 0030 2438          pea       48
00001818  4E92      2439          jsr       (A2)
0000181A  584F      2440          addq.w    #4,A7
                    2441   DumpRegisters_27:
                    2442   ; if ((SR & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100)) putchar('1'); else putchar('0');      // IRQ0 Bit (bit 8)
0000181C  3014      2443          move.w    (A4),D0
0000181E  C07C 0100 2444          and.w     #256,D0
00001822  0C40 0100 2445          cmp.w     #256,D0
00001826  660A      2446          bne.s     DumpRegisters_28
00001828  4878 0031 2447          pea       49
0000182C  4E92      2448          jsr       (A2)
0000182E  584F      2449          addq.w    #4,A7
00001830  6008      2450          bra.s     DumpRegisters_29
                    2451   DumpRegisters_28:
00001832  4878 0030 2452          pea       48
00001836  4E92      2453          jsr       (A2)
00001838  584F      2454          addq.w    #4,A7
                    2455   DumpRegisters_29:
                    2456   ; if ((SR & (unsigned short int)(0x0010)) == (unsigned short int)(0x0010)) putchar('X'); else putchar('-');      // X Bit (bit 4)
0000183A  3014      2457          move.w    (A4),D0
0000183C  C07C 0010 2458          and.w     #16,D0
00001840  0C40 0010 2459          cmp.w     #16,D0
00001844  660A      2460          bne.s     DumpRegisters_30
00001846  4878 0058 2461          pea       88
0000184A  4E92      2462          jsr       (A2)
0000184C  584F      2463          addq.w    #4,A7
0000184E  6008      2464          bra.s     DumpRegisters_31
                    2465   DumpRegisters_30:
00001850  4878 002D 2466          pea       45
00001854  4E92      2467          jsr       (A2)
00001856  584F      2468          addq.w    #4,A7
                    2469   DumpRegisters_31:
                    2470   ; if ((SR & (unsigned short int)(0x0008)) == (unsigned short int)(0x0008)) putchar('N'); else putchar('-');      // N Bit (bit 3)
00001858  3014      2471          move.w    (A4),D0
0000185A  C07C 0008 2472          and.w     #8,D0
0000185E  0C40 0008 2473          cmp.w     #8,D0
00001862  660A      2474          bne.s     DumpRegisters_32
00001864  4878 004E 2475          pea       78
00001868  4E92      2476          jsr       (A2)
0000186A  584F      2477          addq.w    #4,A7
0000186C  6008      2478          bra.s     DumpRegisters_33
                    2479   DumpRegisters_32:
0000186E  4878 002D 2480          pea       45
00001872  4E92      2481          jsr       (A2)
00001874  584F      2482          addq.w    #4,A7
                    2483   DumpRegisters_33:
                    2484   ; if ((SR & (unsigned short int)(0x0004)) == (unsigned short int)(0x0004)) putchar('Z'); else putchar('-');      // Z Bit (bit 2)
00001876  3014      2485          move.w    (A4),D0
00001878  C07C 0004 2486          and.w     #4,D0
0000187C  0C40 0004 2487          cmp.w     #4,D0
00001880  660A      2488          bne.s     DumpRegisters_34
00001882  4878 005A 2489          pea       90
00001886  4E92      2490          jsr       (A2)
00001888  584F      2491          addq.w    #4,A7
0000188A  6008      2492          bra.s     DumpRegisters_35
                    2493   DumpRegisters_34:
0000188C  4878 002D 2494          pea       45
00001890  4E92      2495          jsr       (A2)
00001892  584F      2496          addq.w    #4,A7
                    2497   DumpRegisters_35:
                    2498   ; if ((SR & (unsigned short int)(0x0002)) == (unsigned short int)(0x0002)) putchar('V'); else putchar('-');      // V Bit (bit 1)
00001894  3014      2499          move.w    (A4),D0
00001896  C07C 0002 2500          and.w     #2,D0
0000189A  0C40 0002 2501          cmp.w     #2,D0
0000189E  660A      2502          bne.s     DumpRegisters_36
000018A0  4878 0056 2503          pea       86
000018A4  4E92      2504          jsr       (A2)
000018A6  584F      2505          addq.w    #4,A7
000018A8  6008      2506          bra.s     DumpRegisters_37
                    2507   DumpRegisters_36:
000018AA  4878 002D 2508          pea       45
000018AE  4E92      2509          jsr       (A2)
000018B0  584F      2510          addq.w    #4,A7
                    2511   DumpRegisters_37:
                    2512   ; if ((SR & (unsigned short int)(0x0001)) == (unsigned short int)(0x0001)) putchar('C'); else putchar('-');      // C Bit (bit 0)
000018B2  3014      2513          move.w    (A4),D0
000018B4  C07C 0001 2514          and.w     #1,D0
000018B8  0C40 0001 2515          cmp.w     #1,D0
000018BC  660A      2516          bne.s     DumpRegisters_38
000018BE  4878 0043 2517          pea       67
000018C2  4E92      2518          jsr       (A2)
000018C4  584F      2519          addq.w    #4,A7
000018C6  6008      2520          bra.s     DumpRegisters_39
                    2521   DumpRegisters_38:
000018C8  4878 002D 2522          pea       45
000018CC  4E92      2523          jsr       (A2)
000018CE  584F      2524          addq.w    #4,A7
                    2525   DumpRegisters_39:
                    2526   ; putchar(']');
000018D0  4878 005D 2527          pea       93
000018D4  4E92      2528          jsr       (A2)
000018D6  584F      2529          addq.w    #4,A7
                    2530   ; printf("\r\n PC = $%08X  ", PC);
000018D8  2F39 0B00 2531          move.l    _PC.L,-(A7)
000018DC  0120      
000018DE  4879 0000 2532          pea       @lab6b_48.L
000018E2  5158      
000018E4  4E93      2533          jsr       (A3)
000018E6  504F      2534          addq.w    #8,A7
                    2535   ; if (*(unsigned short int*)(PC) == 0x4e4e)
000018E8  2039 0B00 2536          move.l    _PC.L,D0
000018EC  0120      
000018EE  2040      2537          move.l    D0,A0
000018F0  3010      2538          move.w    (A0),D0
000018F2  0C40 4E4E 2539          cmp.w     #20046,D0
000018F6  660A      2540          bne.s     DumpRegisters_40
                    2541   ; printf("[@ BREAKPOINT]");
000018F8  4879 0000 2542          pea       @lab6b_49.L
000018FC  5168      
000018FE  4E93      2543          jsr       (A3)
00001900  584F      2544          addq.w    #4,A7
                    2545   DumpRegisters_40:
                    2546   ; printf("\r\n");
00001902  4879 0000 2547          pea       @lab6b_1.L
00001906  4D08      
00001908  4E93      2548          jsr       (A3)
0000190A  584F      2549          addq.w    #4,A7
                    2550   ; for (i = 0; i < 8; i++) {
0000190C  4244      2551          clr.w     D4
                    2552   DumpRegisters_42:
0000190E  0C44 0008 2553          cmp.w     #8,D4
00001912  6C00 0040 2554          bge       DumpRegisters_44
                    2555   ; if (WatchPointSetOrCleared[i] == 1)
00001916  48C4      2556          ext.l     D4
00001918  2004      2557          move.l    D4,D0
0000191A  E588      2558          lsl.l     #2,D0
0000191C  41F9 0B00 2559          lea       _WatchPointSetOrCleared.L,A0
00001920  01A2      
00001922  2030 0800 2560          move.l    0(A0,D0.L),D0
00001926  0C80 0000 2561          cmp.l     #1,D0
0000192A  0001      
0000192C  6622      2562          bne.s     DumpRegisters_45
                    2563   ; printf("\r\nWP%d = %s", i, WatchPointString[i]);
0000192E  220D      2564          move.l    A5,D1
00001930  48C4      2565          ext.l     D4
00001932  2F00      2566          move.l    D0,-(A7)
00001934  2004      2567          move.l    D4,D0
00001936  C1FC 0064 2568          muls      #100,D0
0000193A  D280      2569          add.l     D0,D1
0000193C  201F      2570          move.l    (A7)+,D0
0000193E  2F01      2571          move.l    D1,-(A7)
00001940  48C4      2572          ext.l     D4
00001942  2F04      2573          move.l    D4,-(A7)
00001944  4879 0000 2574          pea       @lab6b_50.L
00001948  5178      
0000194A  4E93      2575          jsr       (A3)
0000194C  DEFC 000C 2576          add.w     #12,A7
                    2577   DumpRegisters_45:
00001950  5244      2578          addq.w    #1,D4
00001952  60BA      2579          bra       DumpRegisters_42
                    2580   DumpRegisters_44:
00001954  4CDF 3CFC 2581          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00001958  4E75      2582          rts
                    2583   ; }
                    2584   ; }
                    2585   ; // Trace Exception Handler
                    2586   ; void DumpRegistersandPause(void)
                    2587   ; {
                    2588   _DumpRegistersandPause:
0000195A  2F0A      2589          move.l    A2,-(A7)
0000195C  45F9 0000 2590          lea       _printf.L,A2
00001960  43B8      
                    2591   ; printf("\r\n\r\n\r\n\r\n\r\n\r\nSingle Step  :[ON]");
00001962  4879 0000 2592          pea       @lab6b_51.L
00001966  5184      
00001968  4E92      2593          jsr       (A2)
0000196A  584F      2594          addq.w    #4,A7
                    2595   ; printf("\r\nBreak Points :[Disabled]");
0000196C  4879 0000 2596          pea       @lab6b_52.L
00001970  51A4      
00001972  4E92      2597          jsr       (A2)
00001974  584F      2598          addq.w    #4,A7
                    2599   ; DumpRegisters();
00001976  4EB8 14A6 2600          jsr       _DumpRegisters
                    2601   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
0000197A  4879 0000 2602          pea       @lab6b_53.L
0000197E  51C0      
00001980  4E92      2603          jsr       (A2)
00001982  584F      2604          addq.w    #4,A7
                    2605   ; printf("\r\nPress <ESC> to Resume Program");
00001984  4879 0000 2606          pea       @lab6b_54.L
00001988  51EC      
0000198A  4E92      2607          jsr       (A2)
0000198C  584F      2608          addq.w    #4,A7
                    2609   ; menu();
0000198E  4EB9 0000 2610          jsr       _menu
00001992  253E      
00001994  245F      2611          move.l    (A7)+,A2
00001996  4E75      2612          rts
                    2613   ; }
                    2614   ; void ChangeRegisters(void)
                    2615   ; {
                    2616   _ChangeRegisters:
00001998  4E56 FFFC 2617          link      A6,#-4
0000199C  48E7 303C 2618          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
000019A0  45F9 0000 2619          lea       _printf.L,A2
000019A4  43B8      
000019A6  47EE FFFC 2620          lea       -4(A6),A3
000019AA  49F8 0CA4 2621          lea       _Get8HexDigits.L,A4
000019AE  4BF8 0B68 2622          lea       __getch.L,A5
                    2623   ; // get register name d0-d7, a0-a7, up, sp, sr, pc
                    2624   ; int reg_val;
                    2625   ; char c, reg[3];
                    2626   ; reg[0] = tolower(_getch());
000019B2  2F00      2627          move.l    D0,-(A7)
000019B4  4E95      2628          jsr       (A5)
000019B6  2200      2629          move.l    D0,D1
000019B8  201F      2630          move.l    (A7)+,D0
000019BA  2F01      2631          move.l    D1,-(A7)
000019BC  4EB9 0000 2632          jsr       _tolower
000019C0  4316      
000019C2  584F      2633          addq.w    #4,A7
000019C4  1680      2634          move.b    D0,(A3)
                    2635   ; reg[1] = c = tolower(_getch());
000019C6  2F00      2636          move.l    D0,-(A7)
000019C8  4E95      2637          jsr       (A5)
000019CA  2200      2638          move.l    D0,D1
000019CC  201F      2639          move.l    (A7)+,D0
000019CE  2F01      2640          move.l    D1,-(A7)
000019D0  4EB9 0000 2641          jsr       _tolower
000019D4  4316      
000019D6  584F      2642          addq.w    #4,A7
000019D8  1400      2643          move.b    D0,D2
000019DA  1740 0001 2644          move.b    D0,1(A3)
                    2645   ; if (reg[0] == (char)('d')) {    // change data register
000019DE  1013      2646          move.b    (A3),D0
000019E0  0C00 0064 2647          cmp.b     #100,D0
000019E4  6600 00AE 2648          bne       ChangeRegisters_1
                    2649   ; if ((reg[1] > (char)('7')) || (reg[1] < (char)('0'))) {
000019E8  102B 0001 2650          move.b    1(A3),D0
000019EC  0C00 0037 2651          cmp.b     #55,D0
000019F0  6E0A      2652          bgt.s     ChangeRegisters_5
000019F2  102B 0001 2653          move.b    1(A3),D0
000019F6  0C00 0030 2654          cmp.b     #48,D0
000019FA  6C0E      2655          bge.s     ChangeRegisters_3
                    2656   ChangeRegisters_5:
                    2657   ; printf("\r\nIllegal Data Register : Use D0-D7.....\r\n");
000019FC  4879 0000 2658          pea       @lab6b_55.L
00001A00  520C      
00001A02  4E92      2659          jsr       (A2)
00001A04  584F      2660          addq.w    #4,A7
                    2661   ; return;
00001A06  6000 0244 2662          bra       ChangeRegisters_6
                    2663   ChangeRegisters_3:
                    2664   ; }
                    2665   ; else {
                    2666   ; printf("\r\nD%c = ", c);
00001A0A  4882      2667          ext.w     D2
00001A0C  48C2      2668          ext.l     D2
00001A0E  2F02      2669          move.l    D2,-(A7)
00001A10  4879 0000 2670          pea       @lab6b_56.L
00001A14  5238      
00001A16  4E92      2671          jsr       (A2)
00001A18  504F      2672          addq.w    #8,A7
                    2673   ; reg_val = Get8HexDigits(0);    // read 32 bit value from user keyboard
00001A1A  42A7      2674          clr.l     -(A7)
00001A1C  4E94      2675          jsr       (A4)
00001A1E  584F      2676          addq.w    #4,A7
00001A20  2600      2677          move.l    D0,D3
                    2678   ; }
                    2679   ; // bit cludgy but d0-d7 not stored as an array for good reason
                    2680   ; if (c == (char)('0'))
00001A22  0C02 0030 2681          cmp.b     #48,D2
00001A26  660A      2682          bne.s     ChangeRegisters_7
                    2683   ; d0 = reg_val;
00001A28  23C3 0B00 2684          move.l    D3,_d0.L
00001A2C  00E4      
00001A2E  6000 0060 2685          bra       ChangeRegisters_20
                    2686   ChangeRegisters_7:
                    2687   ; else if (c == (char)('1'))
00001A32  0C02 0031 2688          cmp.b     #49,D2
00001A36  660A      2689          bne.s     ChangeRegisters_9
                    2690   ; d1 = reg_val;
00001A38  23C3 0B00 2691          move.l    D3,_d1.L
00001A3C  00E8      
00001A3E  6000 0050 2692          bra       ChangeRegisters_20
                    2693   ChangeRegisters_9:
                    2694   ; else if (c == (char)('2'))
00001A42  0C02 0032 2695          cmp.b     #50,D2
00001A46  660A      2696          bne.s     ChangeRegisters_11
                    2697   ; d2 = reg_val;
00001A48  23C3 0B00 2698          move.l    D3,_d2.L
00001A4C  00EC      
00001A4E  6000 0040 2699          bra       ChangeRegisters_20
                    2700   ChangeRegisters_11:
                    2701   ; else if (c == (char)('3'))
00001A52  0C02 0033 2702          cmp.b     #51,D2
00001A56  6608      2703          bne.s     ChangeRegisters_13
                    2704   ; d3 = reg_val;
00001A58  23C3 0B00 2705          move.l    D3,_d3.L
00001A5C  00F0      
00001A5E  6030      2706          bra.s     ChangeRegisters_20
                    2707   ChangeRegisters_13:
                    2708   ; else if (c == (char)('4'))
00001A60  0C02 0034 2709          cmp.b     #52,D2
00001A64  6608      2710          bne.s     ChangeRegisters_15
                    2711   ; d4 = reg_val;
00001A66  23C3 0B00 2712          move.l    D3,_d4.L
00001A6A  00F4      
00001A6C  6022      2713          bra.s     ChangeRegisters_20
                    2714   ChangeRegisters_15:
                    2715   ; else if (c == (char)('5'))
00001A6E  0C02 0035 2716          cmp.b     #53,D2
00001A72  6608      2717          bne.s     ChangeRegisters_17
                    2718   ; d5 = reg_val;
00001A74  23C3 0B00 2719          move.l    D3,_d5.L
00001A78  00F8      
00001A7A  6014      2720          bra.s     ChangeRegisters_20
                    2721   ChangeRegisters_17:
                    2722   ; else if (c == (char)('6'))
00001A7C  0C02 0036 2723          cmp.b     #54,D2
00001A80  6608      2724          bne.s     ChangeRegisters_19
                    2725   ; d6 = reg_val;
00001A82  23C3 0B00 2726          move.l    D3,_d6.L
00001A86  00FC      
00001A88  6006      2727          bra.s     ChangeRegisters_20
                    2728   ChangeRegisters_19:
                    2729   ; else
                    2730   ; d7 = reg_val;
00001A8A  23C3 0B00 2731          move.l    D3,_d7.L
00001A8E  0100      
                    2732   ChangeRegisters_20:
00001A90  6000 01B6 2733          bra       ChangeRegisters_51
                    2734   ChangeRegisters_1:
                    2735   ; }
                    2736   ; else if (reg[0] == (char)('a')) {    // change address register, a7 is the user stack pointer, sp is the system stack pointer
00001A94  1013      2737          move.b    (A3),D0
00001A96  0C00 0061 2738          cmp.b     #97,D0
00001A9A  6600 00A6 2739          bne       ChangeRegisters_21
                    2740   ; if ((c > (char)('7')) || (c < (char)('0'))) {
00001A9E  0C02 0037 2741          cmp.b     #55,D2
00001AA2  6E06      2742          bgt.s     ChangeRegisters_25
00001AA4  0C02 0030 2743          cmp.b     #48,D2
00001AA8  6C0E      2744          bge.s     ChangeRegisters_23
                    2745   ChangeRegisters_25:
                    2746   ; printf("\r\nIllegal Address Register : Use A0-A7.....\r\n");
00001AAA  4879 0000 2747          pea       @lab6b_57.L
00001AAE  5242      
00001AB0  4E92      2748          jsr       (A2)
00001AB2  584F      2749          addq.w    #4,A7
                    2750   ; return;
00001AB4  6000 0196 2751          bra       ChangeRegisters_6
                    2752   ChangeRegisters_23:
                    2753   ; }
                    2754   ; else {
                    2755   ; printf("\r\nA%c = ", c);
00001AB8  4882      2756          ext.w     D2
00001ABA  48C2      2757          ext.l     D2
00001ABC  2F02      2758          move.l    D2,-(A7)
00001ABE  4879 0000 2759          pea       @lab6b_58.L
00001AC2  5270      
00001AC4  4E92      2760          jsr       (A2)
00001AC6  504F      2761          addq.w    #8,A7
                    2762   ; reg_val = Get8HexDigits(0);    // read 32 bit value from user keyboard
00001AC8  42A7      2763          clr.l     -(A7)
00001ACA  4E94      2764          jsr       (A4)
00001ACC  584F      2765          addq.w    #4,A7
00001ACE  2600      2766          move.l    D0,D3
                    2767   ; }
                    2768   ; // bit cludgy but a0-a7 not stored as an array for good reason
                    2769   ; if (c == (char)('0'))
00001AD0  0C02 0030 2770          cmp.b     #48,D2
00001AD4  660A      2771          bne.s     ChangeRegisters_26
                    2772   ; a0 = reg_val;
00001AD6  23C3 0B00 2773          move.l    D3,_a0.L
00001ADA  0104      
00001ADC  6000 0060 2774          bra       ChangeRegisters_39
                    2775   ChangeRegisters_26:
                    2776   ; else if (c == (char)('1'))
00001AE0  0C02 0031 2777          cmp.b     #49,D2
00001AE4  660A      2778          bne.s     ChangeRegisters_28
                    2779   ; a1 = reg_val;
00001AE6  23C3 0B00 2780          move.l    D3,_a1.L
00001AEA  0108      
00001AEC  6000 0050 2781          bra       ChangeRegisters_39
                    2782   ChangeRegisters_28:
                    2783   ; else if (c == (char)('2'))
00001AF0  0C02 0032 2784          cmp.b     #50,D2
00001AF4  660A      2785          bne.s     ChangeRegisters_30
                    2786   ; a2 = reg_val;
00001AF6  23C3 0B00 2787          move.l    D3,_a2.L
00001AFA  010C      
00001AFC  6000 0040 2788          bra       ChangeRegisters_39
                    2789   ChangeRegisters_30:
                    2790   ; else if (c == (char)('3'))
00001B00  0C02 0033 2791          cmp.b     #51,D2
00001B04  6608      2792          bne.s     ChangeRegisters_32
                    2793   ; a3 = reg_val;
00001B06  23C3 0B00 2794          move.l    D3,_a3.L
00001B0A  0110      
00001B0C  6030      2795          bra.s     ChangeRegisters_39
                    2796   ChangeRegisters_32:
                    2797   ; else if (c == (char)('4'))
00001B0E  0C02 0034 2798          cmp.b     #52,D2
00001B12  6608      2799          bne.s     ChangeRegisters_34
                    2800   ; a4 = reg_val;
00001B14  23C3 0B00 2801          move.l    D3,_a4.L
00001B18  0114      
00001B1A  6022      2802          bra.s     ChangeRegisters_39
                    2803   ChangeRegisters_34:
                    2804   ; else if (c == (char)('5'))
00001B1C  0C02 0035 2805          cmp.b     #53,D2
00001B20  6608      2806          bne.s     ChangeRegisters_36
                    2807   ; a5 = reg_val;
00001B22  23C3 0B00 2808          move.l    D3,_a5.L
00001B26  0118      
00001B28  6014      2809          bra.s     ChangeRegisters_39
                    2810   ChangeRegisters_36:
                    2811   ; else if (c == (char)('6'))
00001B2A  0C02 0036 2812          cmp.b     #54,D2
00001B2E  6608      2813          bne.s     ChangeRegisters_38
                    2814   ; a6 = reg_val;
00001B30  23C3 0B00 2815          move.l    D3,_a6.L
00001B34  011C      
00001B36  6006      2816          bra.s     ChangeRegisters_39
                    2817   ChangeRegisters_38:
                    2818   ; else
                    2819   ; USP = reg_val;
00001B38  23C3 0B00 2820          move.l    D3,_USP.L
00001B3C  0128      
                    2821   ChangeRegisters_39:
00001B3E  6000 0108 2822          bra       ChangeRegisters_51
                    2823   ChangeRegisters_21:
                    2824   ; }
                    2825   ; else if ((reg[0] == (char)('u')) && (c == (char)('s'))) {
00001B42  1013      2826          move.b    (A3),D0
00001B44  0C00 0075 2827          cmp.b     #117,D0
00001B48  6600 004E 2828          bne       ChangeRegisters_40
00001B4C  0C02 0073 2829          cmp.b     #115,D2
00001B50  6600 0046 2830          bne       ChangeRegisters_40
                    2831   ; if (tolower(_getch()) == 'p') {    // change user stack pointer
00001B54  2F00      2832          move.l    D0,-(A7)
00001B56  4E95      2833          jsr       (A5)
00001B58  2200      2834          move.l    D0,D1
00001B5A  201F      2835          move.l    (A7)+,D0
00001B5C  2F01      2836          move.l    D1,-(A7)
00001B5E  4EB9 0000 2837          jsr       _tolower
00001B62  4316      
00001B64  584F      2838          addq.w    #4,A7
00001B66  0C80 0000 2839          cmp.l     #112,D0
00001B6A  0070      
00001B6C  6618      2840          bne.s     ChangeRegisters_42
                    2841   ; printf("\r\nUser SP = ");
00001B6E  4879 0000 2842          pea       @lab6b_59.L
00001B72  527A      
00001B74  4E92      2843          jsr       (A2)
00001B76  584F      2844          addq.w    #4,A7
                    2845   ; USP = Get8HexDigits(0);    // read 32 bit value from user keyboard
00001B78  42A7      2846          clr.l     -(A7)
00001B7A  4E94      2847          jsr       (A4)
00001B7C  584F      2848          addq.w    #4,A7
00001B7E  23C0 0B00 2849          move.l    D0,_USP.L
00001B82  0128      
00001B84  600E      2850          bra.s     ChangeRegisters_43
                    2851   ChangeRegisters_42:
                    2852   ; }
                    2853   ; else {
                    2854   ; printf("\r\nIllegal Register....");
00001B86  4879 0000 2855          pea       @lab6b_60.L
00001B8A  5288      
00001B8C  4E92      2856          jsr       (A2)
00001B8E  584F      2857          addq.w    #4,A7
                    2858   ; return;
00001B90  6000 00BA 2859          bra       ChangeRegisters_6
                    2860   ChangeRegisters_43:
00001B94  6000 00B2 2861          bra       ChangeRegisters_51
                    2862   ChangeRegisters_40:
                    2863   ; }
                    2864   ; }
                    2865   ; else if ((reg[0] == (char)('s')) && (c == (char)('s'))) {
00001B98  1013      2866          move.b    (A3),D0
00001B9A  0C00 0073 2867          cmp.b     #115,D0
00001B9E  6600 004E 2868          bne       ChangeRegisters_44
00001BA2  0C02 0073 2869          cmp.b     #115,D2
00001BA6  6600 0046 2870          bne       ChangeRegisters_44
                    2871   ; if (tolower(_getch()) == 'p') {    // change system stack pointer
00001BAA  2F00      2872          move.l    D0,-(A7)
00001BAC  4E95      2873          jsr       (A5)
00001BAE  2200      2874          move.l    D0,D1
00001BB0  201F      2875          move.l    (A7)+,D0
00001BB2  2F01      2876          move.l    D1,-(A7)
00001BB4  4EB9 0000 2877          jsr       _tolower
00001BB8  4316      
00001BBA  584F      2878          addq.w    #4,A7
00001BBC  0C80 0000 2879          cmp.l     #112,D0
00001BC0  0070      
00001BC2  6618      2880          bne.s     ChangeRegisters_46
                    2881   ; printf("\r\nSystem SP = ");
00001BC4  4879 0000 2882          pea       @lab6b_61.L
00001BC8  52A0      
00001BCA  4E92      2883          jsr       (A2)
00001BCC  584F      2884          addq.w    #4,A7
                    2885   ; SSP = Get8HexDigits(0);    // read 32 bit value from user keyboard
00001BCE  42A7      2886          clr.l     -(A7)
00001BD0  4E94      2887          jsr       (A4)
00001BD2  584F      2888          addq.w    #4,A7
00001BD4  23C0 0B00 2889          move.l    D0,_SSP.L
00001BD8  0124      
00001BDA  600E      2890          bra.s     ChangeRegisters_47
                    2891   ChangeRegisters_46:
                    2892   ; }
                    2893   ; else {
                    2894   ; printf("\r\nIllegal Register....");
00001BDC  4879 0000 2895          pea       @lab6b_60.L
00001BE0  5288      
00001BE2  4E92      2896          jsr       (A2)
00001BE4  584F      2897          addq.w    #4,A7
                    2898   ; return;
00001BE6  6000 0064 2899          bra       ChangeRegisters_6
                    2900   ChangeRegisters_47:
00001BEA  6000 005C 2901          bra       ChangeRegisters_51
                    2902   ChangeRegisters_44:
                    2903   ; }
                    2904   ; }
                    2905   ; else if ((reg[0] == (char)('p')) && (c == (char)('c'))) {    // change program counter
00001BEE  1013      2906          move.b    (A3),D0
00001BF0  0C00 0070 2907          cmp.b     #112,D0
00001BF4  6620      2908          bne.s     ChangeRegisters_48
00001BF6  0C02 0063 2909          cmp.b     #99,D2
00001BFA  661A      2910          bne.s     ChangeRegisters_48
                    2911   ; printf("\r\nPC = ");
00001BFC  4879 0000 2912          pea       @lab6b_62.L
00001C00  52B0      
00001C02  4E92      2913          jsr       (A2)
00001C04  584F      2914          addq.w    #4,A7
                    2915   ; PC = Get8HexDigits(0);    // read 32 bit value from user keyboard
00001C06  42A7      2916          clr.l     -(A7)
00001C08  4E94      2917          jsr       (A4)
00001C0A  584F      2918          addq.w    #4,A7
00001C0C  23C0 0B00 2919          move.l    D0,_PC.L
00001C10  0120      
00001C12  6000 0034 2920          bra       ChangeRegisters_51
                    2921   ChangeRegisters_48:
                    2922   ; }
                    2923   ; else if ((reg[0] == (char)('s')) && (c == (char)('r'))) {    // change status register
00001C16  1013      2924          move.b    (A3),D0
00001C18  0C00 0073 2925          cmp.b     #115,D0
00001C1C  6620      2926          bne.s     ChangeRegisters_50
00001C1E  0C02 0072 2927          cmp.b     #114,D2
00001C22  661A      2928          bne.s     ChangeRegisters_50
                    2929   ; printf("\r\nSR = ");
00001C24  4879 0000 2930          pea       @lab6b_63.L
00001C28  52B8      
00001C2A  4E92      2931          jsr       (A2)
00001C2C  584F      2932          addq.w    #4,A7
                    2933   ; SR = Get4HexDigits(0);    // read 16 bit value from user keyboard
00001C2E  42A7      2934          clr.l     -(A7)
00001C30  4EB8 0C58 2935          jsr       _Get4HexDigits
00001C34  584F      2936          addq.w    #4,A7
00001C36  33C0 0B00 2937          move.w    D0,_SR.L
00001C3A  012C      
00001C3C  600A      2938          bra.s     ChangeRegisters_51
                    2939   ChangeRegisters_50:
                    2940   ; }
                    2941   ; else
                    2942   ; printf("\r\nIllegal Register: Use A0-A7, D0-D7, SSP, USP, PC or SR\r\n");
00001C3E  4879 0000 2943          pea       @lab6b_64.L
00001C42  52C0      
00001C44  4E92      2944          jsr       (A2)
00001C46  584F      2945          addq.w    #4,A7
                    2946   ChangeRegisters_51:
                    2947   ; DumpRegisters();
00001C48  4EB8 14A6 2948          jsr       _DumpRegisters
                    2949   ChangeRegisters_6:
00001C4C  4CDF 3C0C 2950          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00001C50  4E5E      2951          unlk      A6
00001C52  4E75      2952          rts
                    2953   ; }
                    2954   ; void BreakPointDisplay(void)
                    2955   ; {
                    2956   _BreakPointDisplay:
00001C54  48E7 3030 2957          movem.l   D2/D3/A2/A3,-(A7)
00001C58  45F9 0000 2958          lea       _printf.L,A2
00001C5C  43B8      
00001C5E  47F9 0B00 2959          lea       _BreakPointAddress.L,A3
00001C62  012E      
                    2960   ; int i, BreakPointsSet = 0;
00001C64  4283      2961          clr.l     D3
                    2962   ; // any break points  set
                    2963   ; for (i = 0; i < 8; i++) {
00001C66  4282      2964          clr.l     D2
                    2965   BreakPointDisplay_1:
00001C68  0C82 0000 2966          cmp.l     #8,D2
00001C6C  0008      
00001C6E  6C1C      2967          bge.s     BreakPointDisplay_3
                    2968   ; if (BreakPointSetOrCleared[i] == 1)
00001C70  2002      2969          move.l    D2,D0
00001C72  E588      2970          lsl.l     #2,D0
00001C74  41F9 0B00 2971          lea       _BreakPointSetOrCleared.L,A0
00001C78  015E      
00001C7A  2030 0800 2972          move.l    0(A0,D0.L),D0
00001C7E  0C80 0000 2973          cmp.l     #1,D0
00001C82  0001      
00001C84  6602      2974          bne.s     BreakPointDisplay_4
                    2975   ; BreakPointsSet = 1;
00001C86  7601      2976          moveq     #1,D3
                    2977   BreakPointDisplay_4:
00001C88  5282      2978          addq.l    #1,D2
00001C8A  60DC      2979          bra       BreakPointDisplay_1
                    2980   BreakPointDisplay_3:
                    2981   ; }
                    2982   ; if (BreakPointsSet == 1) {
00001C8C  0C83 0000 2983          cmp.l     #1,D3
00001C90  0001      
00001C92  6616      2984          bne.s     BreakPointDisplay_6
                    2985   ; printf("\r\n\r\nNum     Address      Instruction");
00001C94  4879 0000 2986          pea       @lab6b_65.L
00001C98  52FC      
00001C9A  4E92      2987          jsr       (A2)
00001C9C  584F      2988          addq.w    #4,A7
                    2989   ; printf("\r\n---     ---------    -----------");
00001C9E  4879 0000 2990          pea       @lab6b_66.L
00001CA2  5322      
00001CA4  4E92      2991          jsr       (A2)
00001CA6  584F      2992          addq.w    #4,A7
00001CA8  600A      2993          bra.s     BreakPointDisplay_7
                    2994   BreakPointDisplay_6:
                    2995   ; }
                    2996   ; else
                    2997   ; printf("\r\nNo BreakPoints Set");
00001CAA  4879 0000 2998          pea       @lab6b_67.L
00001CAE  5346      
00001CB0  4E92      2999          jsr       (A2)
00001CB2  584F      3000          addq.w    #4,A7
                    3001   BreakPointDisplay_7:
                    3002   ; for (i = 0; i < 8; i++) {
00001CB4  4282      3003          clr.l     D2
                    3004   BreakPointDisplay_8:
00001CB6  0C82 0000 3005          cmp.l     #8,D2
00001CBA  0008      
00001CBC  6C00 005A 3006          bge       BreakPointDisplay_10
                    3007   ; // put opcode back, then put break point back
                    3008   ; if (BreakPointSetOrCleared[i] == 1) {
00001CC0  2002      3009          move.l    D2,D0
00001CC2  E588      3010          lsl.l     #2,D0
00001CC4  41F9 0B00 3011          lea       _BreakPointSetOrCleared.L,A0
00001CC8  015E      
00001CCA  2030 0800 3012          move.l    0(A0,D0.L),D0
00001CCE  0C80 0000 3013          cmp.l     #1,D0
00001CD2  0001      
00001CD4  6600 003E 3014          bne       BreakPointDisplay_11
                    3015   ; *(unsigned short int*)(BreakPointAddress[i]) = BreakPointInstruction[i];
00001CD8  2002      3016          move.l    D2,D0
00001CDA  E388      3017          lsl.l     #1,D0
00001CDC  41F9 0B00 3018          lea       _BreakPointInstruction.L,A0
00001CE0  014E      
00001CE2  2202      3019          move.l    D2,D1
00001CE4  E589      3020          lsl.l     #2,D1
00001CE6  2233 1800 3021          move.l    0(A3,D1.L),D1
00001CEA  2241      3022          move.l    D1,A1
00001CEC  32B0 0800 3023          move.w    0(A0,D0.L),(A1)
                    3024   ; *(unsigned short int*)(BreakPointAddress[i]) = (unsigned short int)(0x4e4e);
00001CF0  2002      3025          move.l    D2,D0
00001CF2  E588      3026          lsl.l     #2,D0
00001CF4  2033 0800 3027          move.l    0(A3,D0.L),D0
00001CF8  2040      3028          move.l    D0,A0
00001CFA  30BC 4E4E 3029          move.w    #20046,(A0)
                    3030   ; printf("\r\n%3d     $%08x", i, BreakPointAddress[i]);
00001CFE  2202      3031          move.l    D2,D1
00001D00  E589      3032          lsl.l     #2,D1
00001D02  2F33 1800 3033          move.l    0(A3,D1.L),-(A7)
00001D06  2F02      3034          move.l    D2,-(A7)
00001D08  4879 0000 3035          pea       @lab6b_68.L
00001D0C  535C      
00001D0E  4E92      3036          jsr       (A2)
00001D10  DEFC 000C 3037          add.w     #12,A7
                    3038   BreakPointDisplay_11:
00001D14  5282      3039          addq.l    #1,D2
00001D16  609E      3040          bra       BreakPointDisplay_8
                    3041   BreakPointDisplay_10:
                    3042   ; }
                    3043   ; }
                    3044   ; printf("\r\n");
00001D18  4879 0000 3045          pea       @lab6b_1.L
00001D1C  4D08      
00001D1E  4E92      3046          jsr       (A2)
00001D20  584F      3047          addq.w    #4,A7
00001D22  4CDF 0C0C 3048          movem.l   (A7)+,D2/D3/A2/A3
00001D26  4E75      3049          rts
                    3050   ; }
                    3051   ; void WatchPointDisplay(void)
                    3052   ; {
                    3053   _WatchPointDisplay:
00001D28  48E7 3020 3054          movem.l   D2/D3/A2,-(A7)
00001D2C  45F9 0000 3055          lea       _printf.L,A2
00001D30  43B8      
                    3056   ; int i;
                    3057   ; int WatchPointsSet = 0;
00001D32  4283      3058          clr.l     D3
                    3059   ; // any watchpoints set
                    3060   ; for (i = 0; i < 8; i++) {
00001D34  4282      3061          clr.l     D2
                    3062   WatchPointDisplay_1:
00001D36  0C82 0000 3063          cmp.l     #8,D2
00001D3A  0008      
00001D3C  6C1C      3064          bge.s     WatchPointDisplay_3
                    3065   ; if (WatchPointSetOrCleared[i] == 1)
00001D3E  2002      3066          move.l    D2,D0
00001D40  E588      3067          lsl.l     #2,D0
00001D42  41F9 0B00 3068          lea       _WatchPointSetOrCleared.L,A0
00001D46  01A2      
00001D48  2030 0800 3069          move.l    0(A0,D0.L),D0
00001D4C  0C80 0000 3070          cmp.l     #1,D0
00001D50  0001      
00001D52  6602      3071          bne.s     WatchPointDisplay_4
                    3072   ; WatchPointsSet = 1;
00001D54  7601      3073          moveq     #1,D3
                    3074   WatchPointDisplay_4:
00001D56  5282      3075          addq.l    #1,D2
00001D58  60DC      3076          bra       WatchPointDisplay_1
                    3077   WatchPointDisplay_3:
                    3078   ; }
                    3079   ; if (WatchPointsSet == 1) {
00001D5A  0C83 0000 3080          cmp.l     #1,D3
00001D5E  0001      
00001D60  6616      3081          bne.s     WatchPointDisplay_6
                    3082   ; printf("\r\nNum     Address");
00001D62  4879 0000 3083          pea       @lab6b_69.L
00001D66  536C      
00001D68  4E92      3084          jsr       (A2)
00001D6A  584F      3085          addq.w    #4,A7
                    3086   ; printf("\r\n---     ---------");
00001D6C  4879 0000 3087          pea       @lab6b_70.L
00001D70  537E      
00001D72  4E92      3088          jsr       (A2)
00001D74  584F      3089          addq.w    #4,A7
00001D76  600A      3090          bra.s     WatchPointDisplay_7
                    3091   WatchPointDisplay_6:
                    3092   ; }
                    3093   ; else
                    3094   ; printf("\r\nNo WatchPoints Set");
00001D78  4879 0000 3095          pea       @lab6b_71.L
00001D7C  5392      
00001D7E  4E92      3096          jsr       (A2)
00001D80  584F      3097          addq.w    #4,A7
                    3098   WatchPointDisplay_7:
                    3099   ; for (i = 0; i < 8; i++) {
00001D82  4282      3100          clr.l     D2
                    3101   WatchPointDisplay_8:
00001D84  0C82 0000 3102          cmp.l     #8,D2
00001D88  0008      
00001D8A  6C00 0038 3103          bge       WatchPointDisplay_10
                    3104   ; if (WatchPointSetOrCleared[i] == 1)
00001D8E  2002      3105          move.l    D2,D0
00001D90  E588      3106          lsl.l     #2,D0
00001D92  41F9 0B00 3107          lea       _WatchPointSetOrCleared.L,A0
00001D96  01A2      
00001D98  2030 0800 3108          move.l    0(A0,D0.L),D0
00001D9C  0C80 0000 3109          cmp.l     #1,D0
00001DA0  0001      
00001DA2  661C      3110          bne.s     WatchPointDisplay_11
                    3111   ; printf("\r\n%3d     $%08x", i, WatchPointAddress[i]);
00001DA4  2202      3112          move.l    D2,D1
00001DA6  E589      3113          lsl.l     #2,D1
00001DA8  41F9 0B00 3114          lea       _WatchPointAddress.L,A0
00001DAC  0182      
00001DAE  2F30 1800 3115          move.l    0(A0,D1.L),-(A7)
00001DB2  2F02      3116          move.l    D2,-(A7)
00001DB4  4879 0000 3117          pea       @lab6b_68.L
00001DB8  535C      
00001DBA  4E92      3118          jsr       (A2)
00001DBC  DEFC 000C 3119          add.w     #12,A7
                    3120   WatchPointDisplay_11:
00001DC0  5282      3121          addq.l    #1,D2
00001DC2  60C0      3122          bra       WatchPointDisplay_8
                    3123   WatchPointDisplay_10:
                    3124   ; }
                    3125   ; printf("\r\n");
00001DC4  4879 0000 3126          pea       @lab6b_1.L
00001DC8  4D08      
00001DCA  4E92      3127          jsr       (A2)
00001DCC  584F      3128          addq.w    #4,A7
00001DCE  4CDF 040C 3129          movem.l   (A7)+,D2/D3/A2
00001DD2  4E75      3130          rts
                    3131   ; }
                    3132   ; void BreakPointClear(void)
                    3133   ; {
                    3134   _BreakPointClear:
00001DD4  4E56 FFFC 3135          link      A6,#-4
00001DD8  48E7 2020 3136          movem.l   D2/A2,-(A7)
00001DDC  45F9 0000 3137          lea       _printf.L,A2
00001DE0  43B8      
                    3138   ; unsigned int i;
                    3139   ; volatile unsigned short int* ProgramBreakPointAddress;
                    3140   ; BreakPointDisplay();
00001DE2  4EB8 1C54 3141          jsr       _BreakPointDisplay
                    3142   ; printf("\r\nEnter Break Point Number: ");
00001DE6  4879 0000 3143          pea       @lab6b_72.L
00001DEA  53A8      
00001DEC  4E92      3144          jsr       (A2)
00001DEE  584F      3145          addq.w    #4,A7
                    3146   ; i = xtod(_getch());           // get break pointer number
00001DF0  2F00      3147          move.l    D0,-(A7)
00001DF2  4EB8 0B68 3148          jsr       __getch
00001DF6  2200      3149          move.l    D0,D1
00001DF8  201F      3150          move.l    (A7)+,D0
00001DFA  2F01      3151          move.l    D1,-(A7)
00001DFC  4EB8 0BD2 3152          jsr       _xtod
00001E00  584F      3153          addq.w    #4,A7
00001E02  C0BC 0000 3154          and.l     #255,D0
00001E06  00FF      
00001E08  2400      3155          move.l    D0,D2
                    3156   ; if ((i < 0) || (i > 7)) {
00001E0A  0C82 0000 3157          cmp.l     #0,D2
00001E0E  0000      
00001E10  6508      3158          blo.s     BreakPointClear_3
00001E12  0C82 0000 3159          cmp.l     #7,D2
00001E16  0007      
00001E18  630E      3160          bls.s     BreakPointClear_1
                    3161   BreakPointClear_3:
                    3162   ; printf("\r\nIllegal Range : Use 0 - 7");
00001E1A  4879 0000 3163          pea       @lab6b_73.L
00001E1E  53C6      
00001E20  4E92      3164          jsr       (A2)
00001E22  584F      3165          addq.w    #4,A7
                    3166   ; return;
00001E24  6000 0080 3167          bra       BreakPointClear_4
                    3168   BreakPointClear_1:
                    3169   ; }
                    3170   ; if (BreakPointSetOrCleared[i] == 1) {       // if break point set
00001E28  2002      3171          move.l    D2,D0
00001E2A  E588      3172          lsl.l     #2,D0
00001E2C  41F9 0B00 3173          lea       _BreakPointSetOrCleared.L,A0
00001E30  015E      
00001E32  2030 0800 3174          move.l    0(A0,D0.L),D0
00001E36  0C80 0000 3175          cmp.l     #1,D0
00001E3A  0001      
00001E3C  6600 005A 3176          bne       BreakPointClear_5
                    3177   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BreakPointAddress[i]);     // point to the instruction in the user program we are about to change
00001E40  2002      3178          move.l    D2,D0
00001E42  E588      3179          lsl.l     #2,D0
00001E44  41F9 0B00 3180          lea       _BreakPointAddress.L,A0
00001E48  012E      
00001E4A  2D70 0800 3181          move.l    0(A0,D0.L),-4(A6)
00001E4E  FFFC      
                    3182   ; BreakPointAddress[i] = 0;
00001E50  2002      3183          move.l    D2,D0
00001E52  E588      3184          lsl.l     #2,D0
00001E54  41F9 0B00 3185          lea       _BreakPointAddress.L,A0
00001E58  012E      
00001E5A  42B0 0800 3186          clr.l     0(A0,D0.L)
                    3187   ; BreakPointSetOrCleared[i] = 0;
00001E5E  2002      3188          move.l    D2,D0
00001E60  E588      3189          lsl.l     #2,D0
00001E62  41F9 0B00 3190          lea       _BreakPointSetOrCleared.L,A0
00001E66  015E      
00001E68  42B0 0800 3191          clr.l     0(A0,D0.L)
                    3192   ; *ProgramBreakPointAddress = BreakPointInstruction[i];  // put original instruction back
00001E6C  2002      3193          move.l    D2,D0
00001E6E  E388      3194          lsl.l     #1,D0
00001E70  41F9 0B00 3195          lea       _BreakPointInstruction.L,A0
00001E74  014E      
00001E76  226E FFFC 3196          move.l    -4(A6),A1
00001E7A  32B0 0800 3197          move.w    0(A0,D0.L),(A1)
                    3198   ; BreakPointInstruction[i] = 0;
00001E7E  2002      3199          move.l    D2,D0
00001E80  E388      3200          lsl.l     #1,D0
00001E82  41F9 0B00 3201          lea       _BreakPointInstruction.L,A0
00001E86  014E      
00001E88  4270 0800 3202          clr.w     0(A0,D0.L)
                    3203   ; printf("\r\nBreak Point Cleared.....\r\n");
00001E8C  4879 0000 3204          pea       @lab6b_74.L
00001E90  53E2      
00001E92  4E92      3205          jsr       (A2)
00001E94  584F      3206          addq.w    #4,A7
00001E96  600A      3207          bra.s     BreakPointClear_6
                    3208   BreakPointClear_5:
                    3209   ; }
                    3210   ; else
                    3211   ; printf("\r\nBreak Point wasn't Set.....");
00001E98  4879 0000 3212          pea       @lab6b_75.L
00001E9C  5400      
00001E9E  4E92      3213          jsr       (A2)
00001EA0  584F      3214          addq.w    #4,A7
                    3215   BreakPointClear_6:
                    3216   ; BreakPointDisplay();
00001EA2  4EB8 1C54 3217          jsr       _BreakPointDisplay
                    3218   ; return;
                    3219   BreakPointClear_4:
00001EA6  4CDF 0404 3220          movem.l   (A7)+,D2/A2
00001EAA  4E5E      3221          unlk      A6
00001EAC  4E75      3222          rts
                    3223   ; }
                    3224   ; void WatchPointClear(void)
                    3225   ; {
                    3226   _WatchPointClear:
00001EAE  48E7 2020 3227          movem.l   D2/A2,-(A7)
00001EB2  45F9 0000 3228          lea       _printf.L,A2
00001EB6  43B8      
                    3229   ; unsigned int i;
                    3230   ; WatchPointDisplay();
00001EB8  4EB8 1D28 3231          jsr       _WatchPointDisplay
                    3232   ; printf("\r\nEnter Watch Point Number: ");
00001EBC  4879 0000 3233          pea       @lab6b_76.L
00001EC0  541E      
00001EC2  4E92      3234          jsr       (A2)
00001EC4  584F      3235          addq.w    #4,A7
                    3236   ; i = xtod(_getch());           // get watch pointer number
00001EC6  2F00      3237          move.l    D0,-(A7)
00001EC8  4EB8 0B68 3238          jsr       __getch
00001ECC  2200      3239          move.l    D0,D1
00001ECE  201F      3240          move.l    (A7)+,D0
00001ED0  2F01      3241          move.l    D1,-(A7)
00001ED2  4EB8 0BD2 3242          jsr       _xtod
00001ED6  584F      3243          addq.w    #4,A7
00001ED8  C0BC 0000 3244          and.l     #255,D0
00001EDC  00FF      
00001EDE  2400      3245          move.l    D0,D2
                    3246   ; if ((i < 0) || (i > 7)) {
00001EE0  0C82 0000 3247          cmp.l     #0,D2
00001EE4  0000      
00001EE6  6508      3248          blo.s     WatchPointClear_3
00001EE8  0C82 0000 3249          cmp.l     #7,D2
00001EEC  0007      
00001EEE  630E      3250          bls.s     WatchPointClear_1
                    3251   WatchPointClear_3:
                    3252   ; printf("\r\nIllegal Range : Use 0 - 7");
00001EF0  4879 0000 3253          pea       @lab6b_73.L
00001EF4  53C6      
00001EF6  4E92      3254          jsr       (A2)
00001EF8  584F      3255          addq.w    #4,A7
                    3256   ; return;
00001EFA  6000 004E 3257          bra       WatchPointClear_4
                    3258   WatchPointClear_1:
                    3259   ; }
                    3260   ; if (WatchPointSetOrCleared[i] == 1) {       // if watch point set
00001EFE  2002      3261          move.l    D2,D0
00001F00  E588      3262          lsl.l     #2,D0
00001F02  41F9 0B00 3263          lea       _WatchPointSetOrCleared.L,A0
00001F06  01A2      
00001F08  2030 0800 3264          move.l    0(A0,D0.L),D0
00001F0C  0C80 0000 3265          cmp.l     #1,D0
00001F10  0001      
00001F12  6628      3266          bne.s     WatchPointClear_5
                    3267   ; WatchPointAddress[i] = 0;
00001F14  2002      3268          move.l    D2,D0
00001F16  E588      3269          lsl.l     #2,D0
00001F18  41F9 0B00 3270          lea       _WatchPointAddress.L,A0
00001F1C  0182      
00001F1E  42B0 0800 3271          clr.l     0(A0,D0.L)
                    3272   ; WatchPointSetOrCleared[i] = 0;
00001F22  2002      3273          move.l    D2,D0
00001F24  E588      3274          lsl.l     #2,D0
00001F26  41F9 0B00 3275          lea       _WatchPointSetOrCleared.L,A0
00001F2A  01A2      
00001F2C  42B0 0800 3276          clr.l     0(A0,D0.L)
                    3277   ; printf("\r\nWatch Point Cleared.....\r\n");
00001F30  4879 0000 3278          pea       @lab6b_77.L
00001F34  543C      
00001F36  4E92      3279          jsr       (A2)
00001F38  584F      3280          addq.w    #4,A7
00001F3A  600A      3281          bra.s     WatchPointClear_6
                    3282   WatchPointClear_5:
                    3283   ; }
                    3284   ; else
                    3285   ; printf("\r\nWatch Point Was not Set.....");
00001F3C  4879 0000 3286          pea       @lab6b_78.L
00001F40  545A      
00001F42  4E92      3287          jsr       (A2)
00001F44  584F      3288          addq.w    #4,A7
                    3289   WatchPointClear_6:
                    3290   ; WatchPointDisplay();
00001F46  4EB8 1D28 3291          jsr       _WatchPointDisplay
                    3292   ; return;
                    3293   WatchPointClear_4:
00001F4A  4CDF 0404 3294          movem.l   (A7)+,D2/A2
00001F4E  4E75      3295          rts
                    3296   ; }
                    3297   ; void DisableBreakPoints(void)
                    3298   ; {
                    3299   _DisableBreakPoints:
00001F50  4E56 FFFC 3300          link      A6,#-4
00001F54  2F02      3301          move.l    D2,-(A7)
                    3302   ; int i;
                    3303   ; volatile unsigned short int* ProgramBreakPointAddress;
                    3304   ; for (i = 0; i < 8; i++) {
00001F56  4282      3305          clr.l     D2
                    3306   DisableBreakPoints_1:
00001F58  0C82 0000 3307          cmp.l     #8,D2
00001F5C  0008      
00001F5E  6C00 003E 3308          bge       DisableBreakPoints_3
                    3309   ; if (BreakPointSetOrCleared[i] == 1) {                                                    // if break point set
00001F62  2002      3310          move.l    D2,D0
00001F64  E588      3311          lsl.l     #2,D0
00001F66  41F9 0B00 3312          lea       _BreakPointSetOrCleared.L,A0
00001F6A  015E      
00001F6C  2030 0800 3313          move.l    0(A0,D0.L),D0
00001F70  0C80 0000 3314          cmp.l     #1,D0
00001F74  0001      
00001F76  6622      3315          bne.s     DisableBreakPoints_4
                    3316   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BreakPointAddress[i]);     // point to the instruction in the user program where the break point has been set
00001F78  2002      3317          move.l    D2,D0
00001F7A  E588      3318          lsl.l     #2,D0
00001F7C  41F9 0B00 3319          lea       _BreakPointAddress.L,A0
00001F80  012E      
00001F82  2D70 0800 3320          move.l    0(A0,D0.L),-4(A6)
00001F86  FFFC      
                    3321   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program overwritting the $4e4e
00001F88  2002      3322          move.l    D2,D0
00001F8A  E388      3323          lsl.l     #1,D0
00001F8C  41F9 0B00 3324          lea       _BreakPointInstruction.L,A0
00001F90  014E      
00001F92  226E FFFC 3325          move.l    -4(A6),A1
00001F96  32B0 0800 3326          move.w    0(A0,D0.L),(A1)
                    3327   DisableBreakPoints_4:
00001F9A  5282      3328          addq.l    #1,D2
00001F9C  60BA      3329          bra       DisableBreakPoints_1
                    3330   DisableBreakPoints_3:
00001F9E  241F      3331          move.l    (A7)+,D2
00001FA0  4E5E      3332          unlk      A6
00001FA2  4E75      3333          rts
                    3334   ; }
                    3335   ; }
                    3336   ; }
                    3337   ; void EnableBreakPoints(void)
                    3338   ; {
                    3339   _EnableBreakPoints:
00001FA4  4E56 FFFC 3340          link      A6,#-4
00001FA8  2F02      3341          move.l    D2,-(A7)
                    3342   ; int i;
                    3343   ; volatile unsigned short int* ProgramBreakPointAddress;
                    3344   ; for (i = 0; i < 8; i++) {
00001FAA  4282      3345          clr.l     D2
                    3346   EnableBreakPoints_1:
00001FAC  0C82 0000 3347          cmp.l     #8,D2
00001FB0  0008      
00001FB2  6C32      3348          bge.s     EnableBreakPoints_3
                    3349   ; if (BreakPointSetOrCleared[i] == 1) {                                                     // if break point set
00001FB4  2002      3350          move.l    D2,D0
00001FB6  E588      3351          lsl.l     #2,D0
00001FB8  41F9 0B00 3352          lea       _BreakPointSetOrCleared.L,A0
00001FBC  015E      
00001FBE  2030 0800 3353          move.l    0(A0,D0.L),D0
00001FC2  0C80 0000 3354          cmp.l     #1,D0
00001FC6  0001      
00001FC8  6618      3355          bne.s     EnableBreakPoints_4
                    3356   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BreakPointAddress[i]);     // point to the instruction in the user program where the break point has been set
00001FCA  2002      3357          move.l    D2,D0
00001FCC  E588      3358          lsl.l     #2,D0
00001FCE  41F9 0B00 3359          lea       _BreakPointAddress.L,A0
00001FD2  012E      
00001FD4  2D70 0800 3360          move.l    0(A0,D0.L),-4(A6)
00001FD8  FFFC      
                    3361   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e);                              // put the breakpoint back in user program
00001FDA  206E FFFC 3362          move.l    -4(A6),A0
00001FDE  30BC 4E4E 3363          move.w    #20046,(A0)
                    3364   EnableBreakPoints_4:
00001FE2  5282      3365          addq.l    #1,D2
00001FE4  60C6      3366          bra       EnableBreakPoints_1
                    3367   EnableBreakPoints_3:
00001FE6  241F      3368          move.l    (A7)+,D2
00001FE8  4E5E      3369          unlk      A6
00001FEA  4E75      3370          rts
                    3371   ; }
                    3372   ; }
                    3373   ; }
                    3374   ; void KillAllBreakPoints(void)
                    3375   ; {
                    3376   _KillAllBreakPoints:
00001FEC  4E56 FFFC 3377          link      A6,#-4
00001FF0  2F02      3378          move.l    D2,-(A7)
                    3379   ; int i;
                    3380   ; volatile unsigned short int* ProgramBreakPointAddress;
                    3381   ; for (i = 0; i < 8; i++) {
00001FF2  4282      3382          clr.l     D2
                    3383   KillAllBreakPoints_1:
00001FF4  0C82 0000 3384          cmp.l     #8,D2
00001FF8  0008      
00001FFA  6C00 0052 3385          bge       KillAllBreakPoints_3
                    3386   ; // clear BP
                    3387   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BreakPointAddress[i]);     // point to the instruction in the user program where the break point has been set
00001FFE  2002      3388          move.l    D2,D0
00002000  E588      3389          lsl.l     #2,D0
00002002  41F9 0B00 3390          lea       _BreakPointAddress.L,A0
00002006  012E      
00002008  2D70 0800 3391          move.l    0(A0,D0.L),-4(A6)
0000200C  FFFC      
                    3392   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program
0000200E  2002      3393          move.l    D2,D0
00002010  E388      3394          lsl.l     #1,D0
00002012  41F9 0B00 3395          lea       _BreakPointInstruction.L,A0
00002016  014E      
00002018  226E FFFC 3396          move.l    -4(A6),A1
0000201C  32B0 0800 3397          move.w    0(A0,D0.L),(A1)
                    3398   ; BreakPointAddress[i] = 0;                                                             // set BP address to NULL
00002020  2002      3399          move.l    D2,D0
00002022  E588      3400          lsl.l     #2,D0
00002024  41F9 0B00 3401          lea       _BreakPointAddress.L,A0
00002028  012E      
0000202A  42B0 0800 3402          clr.l     0(A0,D0.L)
                    3403   ; BreakPointInstruction[i] = 0;
0000202E  2002      3404          move.l    D2,D0
00002030  E388      3405          lsl.l     #1,D0
00002032  41F9 0B00 3406          lea       _BreakPointInstruction.L,A0
00002036  014E      
00002038  4270 0800 3407          clr.w     0(A0,D0.L)
                    3408   ; BreakPointSetOrCleared[i] = 0;                                                        // mark break point as cleared for future setting
0000203C  2002      3409          move.l    D2,D0
0000203E  E588      3410          lsl.l     #2,D0
00002040  41F9 0B00 3411          lea       _BreakPointSetOrCleared.L,A0
00002044  015E      
00002046  42B0 0800 3412          clr.l     0(A0,D0.L)
0000204A  5282      3413          addq.l    #1,D2
0000204C  60A6      3414          bra       KillAllBreakPoints_1
                    3415   KillAllBreakPoints_3:
0000204E  241F      3416          move.l    (A7)+,D2
00002050  4E5E      3417          unlk      A6
00002052  4E75      3418          rts
                    3419   ; }
                    3420   ; //BreakPointDisplay() ;       // display the break points
                    3421   ; }
                    3422   ; void KillAllWatchPoints(void)
                    3423   ; {
                    3424   _KillAllWatchPoints:
00002054  2F02      3425          move.l    D2,-(A7)
                    3426   ; int i;
                    3427   ; for (i = 0; i < 8; i++) {
00002056  4282      3428          clr.l     D2
                    3429   KillAllWatchPoints_1:
00002058  0C82 0000 3430          cmp.l     #8,D2
0000205C  0008      
0000205E  6C20      3431          bge.s     KillAllWatchPoints_3
                    3432   ; WatchPointAddress[i] = 0;                                                             // set BP address to NULL
00002060  2002      3433          move.l    D2,D0
00002062  E588      3434          lsl.l     #2,D0
00002064  41F9 0B00 3435          lea       _WatchPointAddress.L,A0
00002068  0182      
0000206A  42B0 0800 3436          clr.l     0(A0,D0.L)
                    3437   ; WatchPointSetOrCleared[i] = 0;                                                        // mark break point as cleared for future setting
0000206E  2002      3438          move.l    D2,D0
00002070  E588      3439          lsl.l     #2,D0
00002072  41F9 0B00 3440          lea       _WatchPointSetOrCleared.L,A0
00002076  01A2      
00002078  42B0 0800 3441          clr.l     0(A0,D0.L)
0000207C  5282      3442          addq.l    #1,D2
0000207E  60D8      3443          bra       KillAllWatchPoints_1
                    3444   KillAllWatchPoints_3:
00002080  241F      3445          move.l    (A7)+,D2
00002082  4E75      3446          rts
                    3447   ; }
                    3448   ; //WatchPointDisplay() ;       // display the break points
                    3449   ; }
                    3450   ; void SetBreakPoint(void)
                    3451   ; {
                    3452   _SetBreakPoint:
00002084  4E56 FFFC 3453          link      A6,#-4
00002088  48E7 3830 3454          movem.l   D2/D3/D4/A2/A3,-(A7)
0000208C  45F9 0000 3455          lea       _printf.L,A2
00002090  43B8      
00002092  47F9 0B00 3456          lea       _BreakPointSetOrCleared.L,A3
00002096  015E      
                    3457   ; int i;
                    3458   ; int BPNumber;
                    3459   ; int BPAddress;
                    3460   ; volatile unsigned short int* ProgramBreakPointAddress;
                    3461   ; // see if any free break points
                    3462   ; for (i = 0; i < 8; i++) {
00002098  4282      3463          clr.l     D2
                    3464   SetBreakPoint_1:
0000209A  0C82 0000 3465          cmp.l     #8,D2
0000209E  0008      
000020A0  6C10      3466          bge.s     SetBreakPoint_3
                    3467   ; if (BreakPointSetOrCleared[i] == 0)
000020A2  2002      3468          move.l    D2,D0
000020A4  E588      3469          lsl.l     #2,D0
000020A6  2033 0800 3470          move.l    0(A3,D0.L),D0
000020AA  6602      3471          bne.s     SetBreakPoint_4
                    3472   ; break;         // if spare BP found allow user to set it
000020AC  6004      3473          bra.s     SetBreakPoint_3
                    3474   SetBreakPoint_4:
000020AE  5282      3475          addq.l    #1,D2
000020B0  60E8      3476          bra       SetBreakPoint_1
                    3477   SetBreakPoint_3:
                    3478   ; }
                    3479   ; if (i == 8) {
000020B2  0C82 0000 3480          cmp.l     #8,D2
000020B6  0008      
000020B8  660E      3481          bne.s     SetBreakPoint_6
                    3482   ; printf("\r\nNo FREE Break Points.....");
000020BA  4879 0000 3483          pea       @lab6b_79.L
000020BE  547A      
000020C0  4E92      3484          jsr       (A2)
000020C2  584F      3485          addq.w    #4,A7
                    3486   ; return;
000020C4  6000 00D6 3487          bra       SetBreakPoint_15
                    3488   SetBreakPoint_6:
                    3489   ; }
                    3490   ; printf("\r\nBreak Point Address: ");
000020C8  4879 0000 3491          pea       @lab6b_80.L
000020CC  5496      
000020CE  4E92      3492          jsr       (A2)
000020D0  584F      3493          addq.w    #4,A7
                    3494   ; BPAddress = Get8HexDigits(0);
000020D2  42A7      3495          clr.l     -(A7)
000020D4  4EB8 0CA4 3496          jsr       _Get8HexDigits
000020D8  584F      3497          addq.w    #4,A7
000020DA  2600      3498          move.l    D0,D3
                    3499   ; ProgramBreakPointAddress = (volatile unsigned short int*)(BPAddress);     // point to the instruction in the user program we are about to change
000020DC  2803      3500          move.l    D3,D4
                    3501   ; if ((BPAddress & 0x00000001) == 0x00000001) {   // cannot set BP at an odd address
000020DE  2003      3502          move.l    D3,D0
000020E0  C0BC 0000 3503          and.l     #1,D0
000020E4  0001      
000020E6  0C80 0000 3504          cmp.l     #1,D0
000020EA  0001      
000020EC  660E      3505          bne.s     SetBreakPoint_9
                    3506   ; printf("\r\nError : Break Points CANNOT be set at ODD addresses");
000020EE  4879 0000 3507          pea       @lab6b_81.L
000020F2  54AE      
000020F4  4E92      3508          jsr       (A2)
000020F6  584F      3509          addq.w    #4,A7
                    3510   ; return;
000020F8  6000 00A2 3511          bra       SetBreakPoint_15
                    3512   SetBreakPoint_9:
                    3513   ; }
                    3514   ; if (BPAddress < 0x00008000) {   // cannot set BP in ROM
000020FC  0C83 0000 3515          cmp.l     #32768,D3
00002100  8000      
00002102  640E      3516          bhs.s     SetBreakPoint_11
                    3517   ; printf("\r\nError : Break Points CANNOT be set for ROM in Range : [$0-$00007FFF]");
00002104  4879 0000 3518          pea       @lab6b_82.L
00002108  54E4      
0000210A  4E92      3519          jsr       (A2)
0000210C  584F      3520          addq.w    #4,A7
                    3521   ; return;
0000210E  6000 008C 3522          bra       SetBreakPoint_15
                    3523   SetBreakPoint_11:
                    3524   ; }
                    3525   ; // search for first free bp or existing same BP
                    3526   ; for (i = 0; i < 8; i++) {
00002112  4282      3527          clr.l     D2
                    3528   SetBreakPoint_13:
00002114  0C82 0000 3529          cmp.l     #8,D2
00002118  0008      
0000211A  6C00 0080 3530          bge       SetBreakPoint_15
                    3531   ; if (BreakPointAddress[i] == BPAddress) {
0000211E  2002      3532          move.l    D2,D0
00002120  E588      3533          lsl.l     #2,D0
00002122  41F9 0B00 3534          lea       _BreakPointAddress.L,A0
00002126  012E      
00002128  B6B0 0800 3535          cmp.l     0(A0,D0.L),D3
0000212C  6610      3536          bne.s     SetBreakPoint_16
                    3537   ; printf("\r\nError: Break Point Already Exists at Address : %08x\r\n", BPAddress);
0000212E  2F03      3538          move.l    D3,-(A7)
00002130  4879 0000 3539          pea       @lab6b_83.L
00002134  552C      
00002136  4E92      3540          jsr       (A2)
00002138  504F      3541          addq.w    #8,A7
                    3542   ; return;
0000213A  6000 0060 3543          bra       SetBreakPoint_15
                    3544   SetBreakPoint_16:
                    3545   ; }
                    3546   ; if (BreakPointSetOrCleared[i] == 0) {
0000213E  2002      3547          move.l    D2,D0
00002140  E588      3548          lsl.l     #2,D0
00002142  2033 0800 3549          move.l    0(A3,D0.L),D0
00002146  6600 004E 3550          bne       SetBreakPoint_18
                    3551   ; // set BP here
                    3552   ; BreakPointSetOrCleared[i] = 1;                                 // mark this breakpoint as set
0000214A  2002      3553          move.l    D2,D0
0000214C  E588      3554          lsl.l     #2,D0
0000214E  27BC 0000 3555          move.l    #1,0(A3,D0.L)
00002152  0001 0800 
                    3556   ; BreakPointInstruction[i] = *ProgramBreakPointAddress;          // copy the user program instruction here so we can put it back afterwards
00002156  2044      3557          move.l    D4,A0
00002158  2002      3558          move.l    D2,D0
0000215A  E388      3559          lsl.l     #1,D0
0000215C  43F9 0B00 3560          lea       _BreakPointInstruction.L,A1
00002160  014E      
00002162  3390 0800 3561          move.w    (A0),0(A1,D0.L)
                    3562   ; printf("\r\nBreak Point Set at Address: [$%08x]", ProgramBreakPointAddress);
00002166  2F04      3563          move.l    D4,-(A7)
00002168  4879 0000 3564          pea       @lab6b_84.L
0000216C  5564      
0000216E  4E92      3565          jsr       (A2)
00002170  504F      3566          addq.w    #8,A7
                    3567   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e);   // put a Trap14 instruction at the user specified address
00002172  2044      3568          move.l    D4,A0
00002174  30BC 4E4E 3569          move.w    #20046,(A0)
                    3570   ; BreakPointAddress[i] = BPAddress;                              // record the address of this break point in the debugger
00002178  2002      3571          move.l    D2,D0
0000217A  E588      3572          lsl.l     #2,D0
0000217C  41F9 0B00 3573          lea       _BreakPointAddress.L,A0
00002180  012E      
00002182  2183 0800 3574          move.l    D3,0(A0,D0.L)
                    3575   ; printf("\r\n");
00002186  4879 0000 3576          pea       @lab6b_1.L
0000218A  4D08      
0000218C  4E92      3577          jsr       (A2)
0000218E  584F      3578          addq.w    #4,A7
                    3579   ; BreakPointDisplay();       // display the break points
00002190  4EB8 1C54 3580          jsr       _BreakPointDisplay
                    3581   ; return;
00002194  6006      3582          bra.s     SetBreakPoint_15
                    3583   SetBreakPoint_18:
00002196  5282      3584          addq.l    #1,D2
00002198  6000 FF7A 3585          bra       SetBreakPoint_13
                    3586   SetBreakPoint_15:
0000219C  4CDF 0C1C 3587          movem.l   (A7)+,D2/D3/D4/A2/A3
000021A0  4E5E      3588          unlk      A6
000021A2  4E75      3589          rts
                    3590   ; }
                    3591   ; }
                    3592   ; }
                    3593   ; void SetWatchPoint(void)
                    3594   ; {
                    3595   _SetWatchPoint:
000021A4  4E56 FFF8 3596          link      A6,#-8
000021A8  48E7 3030 3597          movem.l   D2/D3/A2/A3,-(A7)
000021AC  45F9 0000 3598          lea       _printf.L,A2
000021B0  43B8      
000021B2  47F9 0B00 3599          lea       _WatchPointSetOrCleared.L,A3
000021B6  01A2      
                    3600   ; int i;
                    3601   ; int WPNumber;
                    3602   ; int WPAddress;
                    3603   ; volatile unsigned short int* ProgramWatchPointAddress;
                    3604   ; // see if any free break points
                    3605   ; for (i = 0; i < 8; i++) {
000021B8  4282      3606          clr.l     D2
                    3607   SetWatchPoint_1:
000021BA  0C82 0000 3608          cmp.l     #8,D2
000021BE  0008      
000021C0  6C10      3609          bge.s     SetWatchPoint_3
                    3610   ; if (WatchPointSetOrCleared[i] == 0)
000021C2  2002      3611          move.l    D2,D0
000021C4  E588      3612          lsl.l     #2,D0
000021C6  2033 0800 3613          move.l    0(A3,D0.L),D0
000021CA  6602      3614          bne.s     SetWatchPoint_4
                    3615   ; break;         // if spare WP found allow user to set it
000021CC  6004      3616          bra.s     SetWatchPoint_3
                    3617   SetWatchPoint_4:
000021CE  5282      3618          addq.l    #1,D2
000021D0  60E8      3619          bra       SetWatchPoint_1
                    3620   SetWatchPoint_3:
                    3621   ; }
                    3622   ; if (i == 8) {
000021D2  0C82 0000 3623          cmp.l     #8,D2
000021D6  0008      
000021D8  660E      3624          bne.s     SetWatchPoint_6
                    3625   ; printf("\r\nNo FREE Watch Points.....");
000021DA  4879 0000 3626          pea       @lab6b_85.L
000021DE  558A      
000021E0  4E92      3627          jsr       (A2)
000021E2  584F      3628          addq.w    #4,A7
                    3629   ; return;
000021E4  6000 008C 3630          bra       SetWatchPoint_11
                    3631   SetWatchPoint_6:
                    3632   ; }
                    3633   ; printf("\r\nWatch Point Address: ");
000021E8  4879 0000 3634          pea       @lab6b_86.L
000021EC  55A6      
000021EE  4E92      3635          jsr       (A2)
000021F0  584F      3636          addq.w    #4,A7
                    3637   ; WPAddress = Get8HexDigits(0);
000021F2  42A7      3638          clr.l     -(A7)
000021F4  4EB8 0CA4 3639          jsr       _Get8HexDigits
000021F8  584F      3640          addq.w    #4,A7
000021FA  2600      3641          move.l    D0,D3
                    3642   ; // search for first free wp or existing same wp
                    3643   ; for (i = 0; i < 8; i++) {
000021FC  4282      3644          clr.l     D2
                    3645   SetWatchPoint_9:
000021FE  0C82 0000 3646          cmp.l     #8,D2
00002202  0008      
00002204  6C00 006C 3647          bge       SetWatchPoint_11
                    3648   ; if (WatchPointAddress[i] == WPAddress && WPAddress != 0) {     //so we can set a wp at 0
00002208  2002      3649          move.l    D2,D0
0000220A  E588      3650          lsl.l     #2,D0
0000220C  41F9 0B00 3651          lea       _WatchPointAddress.L,A0
00002210  0182      
00002212  B6B0 0800 3652          cmp.l     0(A0,D0.L),D3
00002216  6614      3653          bne.s     SetWatchPoint_12
00002218  4A83      3654          tst.l     D3
0000221A  6710      3655          beq.s     SetWatchPoint_12
                    3656   ; printf("\r\nError: Watch Point Already Set at Address : %08x\r\n", WPAddress);
0000221C  2F03      3657          move.l    D3,-(A7)
0000221E  4879 0000 3658          pea       @lab6b_87.L
00002222  55BE      
00002224  4E92      3659          jsr       (A2)
00002226  504F      3660          addq.w    #8,A7
                    3661   ; return;
00002228  6000 0048 3662          bra       SetWatchPoint_11
                    3663   SetWatchPoint_12:
                    3664   ; }
                    3665   ; if (WatchPointSetOrCleared[i] == 0) {
0000222C  2002      3666          move.l    D2,D0
0000222E  E588      3667          lsl.l     #2,D0
00002230  2033 0800 3668          move.l    0(A3,D0.L),D0
00002234  6600 0038 3669          bne       SetWatchPoint_14
                    3670   ; WatchPointSetOrCleared[i] = 1;                                 // mark this watchpoint as set
00002238  2002      3671          move.l    D2,D0
0000223A  E588      3672          lsl.l     #2,D0
0000223C  27BC 0000 3673          move.l    #1,0(A3,D0.L)
00002240  0001 0800 
                    3674   ; printf("\r\nWatch Point Set at Address: [$%08x]", WPAddress);
00002244  2F03      3675          move.l    D3,-(A7)
00002246  4879 0000 3676          pea       @lab6b_88.L
0000224A  55F4      
0000224C  4E92      3677          jsr       (A2)
0000224E  504F      3678          addq.w    #8,A7
                    3679   ; WatchPointAddress[i] = WPAddress;                              // record the address of this watch point in the debugger
00002250  2002      3680          move.l    D2,D0
00002252  E588      3681          lsl.l     #2,D0
00002254  41F9 0B00 3682          lea       _WatchPointAddress.L,A0
00002258  0182      
0000225A  2183 0800 3683          move.l    D3,0(A0,D0.L)
                    3684   ; printf("\r\n");
0000225E  4879 0000 3685          pea       @lab6b_1.L
00002262  4D08      
00002264  4E92      3686          jsr       (A2)
00002266  584F      3687          addq.w    #4,A7
                    3688   ; WatchPointDisplay();       // display the break points
00002268  4EB8 1D28 3689          jsr       _WatchPointDisplay
                    3690   ; return;
0000226C  6004      3691          bra.s     SetWatchPoint_11
                    3692   SetWatchPoint_14:
0000226E  5282      3693          addq.l    #1,D2
00002270  608C      3694          bra       SetWatchPoint_9
                    3695   SetWatchPoint_11:
00002272  4CDF 0C0C 3696          movem.l   (A7)+,D2/D3/A2/A3
00002276  4E5E      3697          unlk      A6
00002278  4E75      3698          rts
                    3699   ; }
                    3700   ; }
                    3701   ; }
                    3702   ; void HandleBreakPoint(void)
                    3703   ; {
                    3704   _HandleBreakPoint:
0000227A  4E56 FFFC 3705          link      A6,#-4
0000227E  48E7 0038 3706          movem.l   A2/A3/A4,-(A7)
00002282  45F9 0B00 3707          lea       _i.L,A2
00002286  00C4      
00002288  47F9 0000 3708          lea       _printf.L,A3
0000228C  43B8      
0000228E  49F9 0B00 3709          lea       _PC.L,A4
00002292  0120      
                    3710   ; volatile unsigned short int* ProgramBreakPointAddress;
                    3711   ; // now we have to put the break point back to run the instruction
                    3712   ; // PC will contain the address of the TRAP instruction but advanced by two bytes so lets play with that
                    3713   ; PC = PC - 2;  // ready for user to resume after reaching breakpoint
00002294  5594      3714          subq.l    #2,(A4)
                    3715   ; printf("\r\n\r\n\r\n\r\n@BREAKPOINT");
00002296  4879 0000 3716          pea       @lab6b_89.L
0000229A  561A      
0000229C  4E93      3717          jsr       (A3)
0000229E  584F      3718          addq.w    #4,A7
                    3719   ; printf("\r\nSingle Step : [ON]");
000022A0  4879 0000 3720          pea       @lab6b_90.L
000022A4  562E      
000022A6  4E93      3721          jsr       (A3)
000022A8  584F      3722          addq.w    #4,A7
                    3723   ; printf("\r\nBreakPoints : [Enabled]");
000022AA  4879 0000 3724          pea       @lab6b_91.L
000022AE  5644      
000022B0  4E93      3725          jsr       (A3)
000022B2  584F      3726          addq.w    #4,A7
                    3727   ; // now clear the break point (put original instruction back)
                    3728   ; ProgramBreakPointAddress = PC;
000022B4  2D54 FFFC 3729          move.l    (A4),-4(A6)
                    3730   ; for (i = 0; i < 8; i++) {
000022B8  4292      3731          clr.l     (A2)
                    3732   HandleBreakPoint_1:
000022BA  2012      3733          move.l    (A2),D0
000022BC  0C80 0000 3734          cmp.l     #8,D0
000022C0  0008      
000022C2  6400 0056 3735          bhs       HandleBreakPoint_3
                    3736   ; if (BreakPointAddress[i] == PC) {        // if we have found the breakpoint
000022C6  2012      3737          move.l    (A2),D0
000022C8  E588      3738          lsl.l     #2,D0
000022CA  41F9 0B00 3739          lea       _BreakPointAddress.L,A0
000022CE  012E      
000022D0  2230 0800 3740          move.l    0(A0,D0.L),D1
000022D4  B294      3741          cmp.l     (A4),D1
000022D6  6600 003E 3742          bne       HandleBreakPoint_4
                    3743   ; BreakPointAddress[i] = 0;
000022DA  2012      3744          move.l    (A2),D0
000022DC  E588      3745          lsl.l     #2,D0
000022DE  41F9 0B00 3746          lea       _BreakPointAddress.L,A0
000022E2  012E      
000022E4  42B0 0800 3747          clr.l     0(A0,D0.L)
                    3748   ; BreakPointSetOrCleared[i] = 0;
000022E8  2012      3749          move.l    (A2),D0
000022EA  E588      3750          lsl.l     #2,D0
000022EC  41F9 0B00 3751          lea       _BreakPointSetOrCleared.L,A0
000022F0  015E      
000022F2  42B0 0800 3752          clr.l     0(A0,D0.L)
                    3753   ; *ProgramBreakPointAddress = BreakPointInstruction[i];  // put original instruction back
000022F6  2012      3754          move.l    (A2),D0
000022F8  E388      3755          lsl.l     #1,D0
000022FA  41F9 0B00 3756          lea       _BreakPointInstruction.L,A0
000022FE  014E      
00002300  226E FFFC 3757          move.l    -4(A6),A1
00002304  32B0 0800 3758          move.w    0(A0,D0.L),(A1)
                    3759   ; BreakPointInstruction[i] = 0;
00002308  2012      3760          move.l    (A2),D0
0000230A  E388      3761          lsl.l     #1,D0
0000230C  41F9 0B00 3762          lea       _BreakPointInstruction.L,A0
00002310  014E      
00002312  4270 0800 3763          clr.w     0(A0,D0.L)
                    3764   HandleBreakPoint_4:
00002316  5292      3765          addq.l    #1,(A2)
00002318  60A0      3766          bra       HandleBreakPoint_1
                    3767   HandleBreakPoint_3:
                    3768   ; }
                    3769   ; }
                    3770   ; DumpRegisters();
0000231A  4EB8 14A6 3771          jsr       _DumpRegisters
                    3772   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
0000231E  4879 0000 3773          pea       @lab6b_53.L
00002322  51C0      
00002324  4E93      3774          jsr       (A3)
00002326  584F      3775          addq.w    #4,A7
                    3776   ; printf("\r\nPress <ESC> to Resume User Program\r\n");
00002328  4879 0000 3777          pea       @lab6b_92.L
0000232C  565E      
0000232E  4E93      3778          jsr       (A3)
00002330  584F      3779          addq.w    #4,A7
                    3780   ; menu();
00002332  4EB9 0000 3781          jsr       _menu
00002336  253E      
00002338  4CDF 1C00 3782          movem.l   (A7)+,A2/A3/A4
0000233C  4E5E      3783          unlk      A6
0000233E  4E75      3784          rts
                    3785   ; }
                    3786   ; void UnknownCommand()
                    3787   ; {
                    3788   _UnknownCommand:
                    3789   ; printf("\r\nUnknown Command.....\r\n");
00002340  4879 0000 3790          pea       @lab6b_93.L
00002344  5686      
00002346  4EB9 0000 3791          jsr       _printf
0000234A  43B8      
0000234C  584F      3792          addq.w    #4,A7
                    3793   ; Help();
0000234E  4EB9 0000 3794          jsr       _Help
00002352  2464      
00002354  4E75      3795          rts
                    3796   ; }
                    3797   ; // system when the users program executes a TRAP #15 instruction to halt program and return to debug monitor
                    3798   ; void CallDebugMonitor(void)
                    3799   ; {
                    3800   _CallDebugMonitor:
                    3801   ; printf("\r\nProgram Ended (TRAP #15)....");
00002356  4879 0000 3802          pea       @lab6b_94.L
0000235A  56A0      
0000235C  4EB9 0000 3803          jsr       _printf
00002360  43B8      
00002362  584F      3804          addq.w    #4,A7
                    3805   ; menu();
00002364  4EB9 0000 3806          jsr       _menu
00002368  253E      
0000236A  4E75      3807          rts
                    3808   ; }
                    3809   ; void Breakpoint(void)
                    3810   ; {
                    3811   _Breakpoint:
0000236C  2F02      3812          move.l    D2,-(A7)
                    3813   ; char c;
                    3814   ; c = toupper(_getch());
0000236E  2F00      3815          move.l    D0,-(A7)
00002370  4EB8 0B68 3816          jsr       __getch
00002374  2200      3817          move.l    D0,D1
00002376  201F      3818          move.l    (A7)+,D0
00002378  2F01      3819          move.l    D1,-(A7)
0000237A  4EB9 0000 3820          jsr       _toupper
0000237E  438C      
00002380  584F      3821          addq.w    #4,A7
00002382  1400      3822          move.b    D0,D2
                    3823   ; if (c == (char)('D'))                                      // BreakPoint Display
00002384  0C02 0044 3824          cmp.b     #68,D2
00002388  6608      3825          bne.s     Breakpoint_1
                    3826   ; BreakPointDisplay();
0000238A  4EB8 1C54 3827          jsr       _BreakPointDisplay
0000238E  6000 0054 3828          bra       Breakpoint_10
                    3829   Breakpoint_1:
                    3830   ; else if (c == (char)('K')) {                                 // breakpoint Kill
00002392  0C02 004B 3831          cmp.b     #75,D2
00002396  6630      3832          bne.s     Breakpoint_3
                    3833   ; printf("\r\nKill All Break Points...(y/n)?");
00002398  4879 0000 3834          pea       @lab6b_95.L
0000239C  56C0      
0000239E  4EB9 0000 3835          jsr       _printf
000023A2  43B8      
000023A4  584F      3836          addq.w    #4,A7
                    3837   ; c = toupper(_getch());
000023A6  2F00      3838          move.l    D0,-(A7)
000023A8  4EB8 0B68 3839          jsr       __getch
000023AC  2200      3840          move.l    D0,D1
000023AE  201F      3841          move.l    (A7)+,D0
000023B0  2F01      3842          move.l    D1,-(A7)
000023B2  4EB9 0000 3843          jsr       _toupper
000023B6  438C      
000023B8  584F      3844          addq.w    #4,A7
000023BA  1400      3845          move.b    D0,D2
                    3846   ; if (c == (char)('Y'))
000023BC  0C02 0059 3847          cmp.b     #89,D2
000023C0  6604      3848          bne.s     Breakpoint_5
                    3849   ; KillAllBreakPoints();
000023C2  4EB8 1FEC 3850          jsr       _KillAllBreakPoints
                    3851   Breakpoint_5:
000023C6  601C      3852          bra.s     Breakpoint_10
                    3853   Breakpoint_3:
                    3854   ; }
                    3855   ; else if (c == (char)('S')) {
000023C8  0C02 0053 3856          cmp.b     #83,D2
000023CC  6606      3857          bne.s     Breakpoint_7
                    3858   ; SetBreakPoint();
000023CE  4EB8 2084 3859          jsr       _SetBreakPoint
000023D2  6010      3860          bra.s     Breakpoint_10
                    3861   Breakpoint_7:
                    3862   ; }
                    3863   ; else if (c == (char)('C')) {
000023D4  0C02 0043 3864          cmp.b     #67,D2
000023D8  6606      3865          bne.s     Breakpoint_9
                    3866   ; BreakPointClear();
000023DA  4EB8 1DD4 3867          jsr       _BreakPointClear
000023DE  6004      3868          bra.s     Breakpoint_10
                    3869   Breakpoint_9:
                    3870   ; }
                    3871   ; else
                    3872   ; UnknownCommand();
000023E0  4EB8 2340 3873          jsr       _UnknownCommand
                    3874   Breakpoint_10:
000023E4  241F      3875          move.l    (A7)+,D2
000023E6  4E75      3876          rts
                    3877   ; }
                    3878   ; void Watchpoint(void)
                    3879   ; {
                    3880   _Watchpoint:
000023E8  2F02      3881          move.l    D2,-(A7)
                    3882   ; char c;
                    3883   ; c = toupper(_getch());
000023EA  2F00      3884          move.l    D0,-(A7)
000023EC  4EB8 0B68 3885          jsr       __getch
000023F0  2200      3886          move.l    D0,D1
000023F2  201F      3887          move.l    (A7)+,D0
000023F4  2F01      3888          move.l    D1,-(A7)
000023F6  4EB9 0000 3889          jsr       _toupper
000023FA  438C      
000023FC  584F      3890          addq.w    #4,A7
000023FE  1400      3891          move.b    D0,D2
                    3892   ; if (c == (char)('D'))                                      // WatchPoint Display
00002400  0C02 0044 3893          cmp.b     #68,D2
00002404  6608      3894          bne.s     Watchpoint_1
                    3895   ; WatchPointDisplay();
00002406  4EB8 1D28 3896          jsr       _WatchPointDisplay
0000240A  6000 0054 3897          bra       Watchpoint_10
                    3898   Watchpoint_1:
                    3899   ; else if (c == (char)('K')) {                                 // wtahcpoint Kill
0000240E  0C02 004B 3900          cmp.b     #75,D2
00002412  6630      3901          bne.s     Watchpoint_3
                    3902   ; printf("\r\nKill All Watch Points...(y/n)?");
00002414  4879 0000 3903          pea       @lab6b_96.L
00002418  56E2      
0000241A  4EB9 0000 3904          jsr       _printf
0000241E  43B8      
00002420  584F      3905          addq.w    #4,A7
                    3906   ; c = toupper(_getch());
00002422  2F00      3907          move.l    D0,-(A7)
00002424  4EB8 0B68 3908          jsr       __getch
00002428  2200      3909          move.l    D0,D1
0000242A  201F      3910          move.l    (A7)+,D0
0000242C  2F01      3911          move.l    D1,-(A7)
0000242E  4EB9 0000 3912          jsr       _toupper
00002432  438C      
00002434  584F      3913          addq.w    #4,A7
00002436  1400      3914          move.b    D0,D2
                    3915   ; if (c == (char)('Y'))
00002438  0C02 0059 3916          cmp.b     #89,D2
0000243C  6604      3917          bne.s     Watchpoint_5
                    3918   ; KillAllWatchPoints();
0000243E  4EB8 2054 3919          jsr       _KillAllWatchPoints
                    3920   Watchpoint_5:
00002442  601C      3921          bra.s     Watchpoint_10
                    3922   Watchpoint_3:
                    3923   ; }
                    3924   ; else if (c == (char)('S')) {
00002444  0C02 0053 3925          cmp.b     #83,D2
00002448  6606      3926          bne.s     Watchpoint_7
                    3927   ; SetWatchPoint();
0000244A  4EB8 21A4 3928          jsr       _SetWatchPoint
0000244E  6010      3929          bra.s     Watchpoint_10
                    3930   Watchpoint_7:
                    3931   ; }
                    3932   ; else if (c == (char)('C')) {
00002450  0C02 0043 3933          cmp.b     #67,D2
00002454  6606      3934          bne.s     Watchpoint_9
                    3935   ; WatchPointClear();
00002456  4EB8 1EAE 3936          jsr       _WatchPointClear
0000245A  6004      3937          bra.s     Watchpoint_10
                    3938   Watchpoint_9:
                    3939   ; }
                    3940   ; else
                    3941   ; UnknownCommand();
0000245C  4EB8 2340 3942          jsr       _UnknownCommand
                    3943   Watchpoint_10:
00002460  241F      3944          move.l    (A7)+,D2
00002462  4E75      3945          rts
                    3946   ; }
                    3947   ; void Help(void)
                    3948   ; {
                    3949   _Help:
00002464  48E7 2020 3950          movem.l   D2/A2,-(A7)
00002468  45F9 0000 3951          lea       _printf.L,A2
0000246C  43B8      
                    3952   ; char* banner = "\r\n----------------------------------------------------------------";
0000246E  41F9 0000 3953          lea       @lab6b_97.L,A0
00002472  5704      
00002474  2408      3954          move.l    A0,D2
                    3955   ; printf(banner);
00002476  2F02      3956          move.l    D2,-(A7)
00002478  4E92      3957          jsr       (A2)
0000247A  584F      3958          addq.w    #4,A7
                    3959   ; printf("\r\n  Debugger Command Summary");
0000247C  4879 0000 3960          pea       @lab6b_98.L
00002480  5748      
00002482  4E92      3961          jsr       (A2)
00002484  584F      3962          addq.w    #4,A7
                    3963   ; printf(banner);
00002486  2F02      3964          move.l    D2,-(A7)
00002488  4E92      3965          jsr       (A2)
0000248A  584F      3966          addq.w    #4,A7
                    3967   ; printf("\r\n  .(reg)       - Change Registers: e.g A0-A7,D0-D7,PC,SSP,USP,SR");
0000248C  4879 0000 3968          pea       @lab6b_99.L
00002490  5766      
00002492  4E92      3969          jsr       (A2)
00002494  584F      3970          addq.w    #4,A7
                    3971   ; printf("\r\n  BD/BS/BC/BK  - Break Point: Display/Set/Clear/Kill");
00002496  4879 0000 3972          pea       @lab6b_100.L
0000249A  57AA      
0000249C  4E92      3973          jsr       (A2)
0000249E  584F      3974          addq.w    #4,A7
                    3975   ; printf("\r\n  C            - Copy Program from Flash to Main Memory");
000024A0  4879 0000 3976          pea       @lab6b_101.L
000024A4  57E2      
000024A6  4E92      3977          jsr       (A2)
000024A8  584F      3978          addq.w    #4,A7
                    3979   ; printf("\r\n  D            - Dump Memory Contents to Screen");
000024AA  4879 0000 3980          pea       @lab6b_102.L
000024AE  581C      
000024B0  4E92      3981          jsr       (A2)
000024B2  584F      3982          addq.w    #4,A7
                    3983   ; printf("\r\n  E            - Enter String into Memory");
000024B4  4879 0000 3984          pea       @lab6b_103.L
000024B8  584E      
000024BA  4E92      3985          jsr       (A2)
000024BC  584F      3986          addq.w    #4,A7
                    3987   ; printf("\r\n  F            - Fill Memory with Data");
000024BE  4879 0000 3988          pea       @lab6b_104.L
000024C2  587A      
000024C4  4E92      3989          jsr       (A2)
000024C6  584F      3990          addq.w    #4,A7
                    3991   ; printf("\r\n  G            - Go Program Starting at Address: $%08X", PC);
000024C8  2F39 0B00 3992          move.l    _PC.L,-(A7)
000024CC  0120      
000024CE  4879 0000 3993          pea       @lab6b_105.L
000024D2  58A4      
000024D4  4E92      3994          jsr       (A2)
000024D6  504F      3995          addq.w    #8,A7
                    3996   ; printf("\r\n  L            - Load Program (.HEX file) from Laptop");
000024D8  4879 0000 3997          pea       @lab6b_106.L
000024DC  58DE      
000024DE  4E92      3998          jsr       (A2)
000024E0  584F      3999          addq.w    #4,A7
                    4000   ; printf("\r\n  M            - Memory Examine and Change");
000024E2  4879 0000 4001          pea       @lab6b_107.L
000024E6  5916      
000024E8  4E92      4002          jsr       (A2)
000024EA  584F      4003          addq.w    #4,A7
                    4004   ; printf("\r\n  P            - Program Flash Memory with User Program");
000024EC  4879 0000 4005          pea       @lab6b_108.L
000024F0  5944      
000024F2  4E92      4006          jsr       (A2)
000024F4  584F      4007          addq.w    #4,A7
                    4008   ; printf("\r\n  R            - Display 68000 Registers");
000024F6  4879 0000 4009          pea       @lab6b_109.L
000024FA  597E      
000024FC  4E92      4010          jsr       (A2)
000024FE  584F      4011          addq.w    #4,A7
                    4012   ; printf("\r\n  S            - Toggle ON/OFF Single Step Mode");
00002500  4879 0000 4013          pea       @lab6b_110.L
00002504  59AA      
00002506  4E92      4014          jsr       (A2)
00002508  584F      4015          addq.w    #4,A7
                    4016   ; printf("\r\n  TM           - Test Memory");
0000250A  4879 0000 4017          pea       @lab6b_111.L
0000250E  59DC      
00002510  4E92      4018          jsr       (A2)
00002512  584F      4019          addq.w    #4,A7
                    4020   ; printf("\r\n  TS           - Test Switches: SW7-0");
00002514  4879 0000 4021          pea       @lab6b_112.L
00002518  59FC      
0000251A  4E92      4022          jsr       (A2)
0000251C  584F      4023          addq.w    #4,A7
                    4024   ; printf("\r\n  TD           - Test Displays: LEDs and 7-Segment");
0000251E  4879 0000 4025          pea       @lab6b_113.L
00002522  5A24      
00002524  4E92      4026          jsr       (A2)
00002526  584F      4027          addq.w    #4,A7
                    4028   ; printf("\r\n  WD/WS/WC/WK  - Watch Point: Display/Set/Clear/Kill");
00002528  4879 0000 4029          pea       @lab6b_114.L
0000252C  5A5A      
0000252E  4E92      4030          jsr       (A2)
00002530  584F      4031          addq.w    #4,A7
                    4032   ; printf(banner);
00002532  2F02      4033          move.l    D2,-(A7)
00002534  4E92      4034          jsr       (A2)
00002536  584F      4035          addq.w    #4,A7
00002538  4CDF 0404 4036          movem.l   (A7)+,D2/A2
0000253C  4E75      4037          rts
                    4038   ; }
                    4039   ; void menu(void)
                    4040   ; {
                    4041   _menu:
0000253E  48E7 303C 4042          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
00002542  45F9 0000 4043          lea       _printf.L,A2
00002546  43B8      
00002548  47F9 0B00 4044          lea       _Trace.L,A3
0000254C  00D8      
0000254E  49F9 0B00 4045          lea       _x.L,A4
00002552  00C8      
00002554  4BF9 0B00 4046          lea       _SR.L,A5
00002558  012C      
                    4047   ; char c, c1;
                    4048   ; while (1) {
                    4049   menu_1:
                    4050   ; FlushKeyboard();               // dump unread characters from keyboard
0000255A  4EB8 0BA6 4051          jsr       _FlushKeyboard
                    4052   ; printf("\r\n#");
0000255E  4879 0000 4053          pea       @lab6b_115.L
00002562  5A92      
00002564  4E92      4054          jsr       (A2)
00002566  584F      4055          addq.w    #4,A7
                    4056   ; c = toupper(_getch());
00002568  2F00      4057          move.l    D0,-(A7)
0000256A  4EB8 0B68 4058          jsr       __getch
0000256E  2200      4059          move.l    D0,D1
00002570  201F      4060          move.l    (A7)+,D0
00002572  2F01      4061          move.l    D1,-(A7)
00002574  4EB9 0000 4062          jsr       _toupper
00002578  438C      
0000257A  584F      4063          addq.w    #4,A7
0000257C  1400      4064          move.b    D0,D2
                    4065   ; if (c == (char)('L'))                  // load s record file
0000257E  0C02 004C 4066          cmp.b     #76,D2
00002582  6608      4067          bne.s     menu_4
                    4068   ; Load_SRecordFile();
00002584  4EB8 0E36 4069          jsr       _Load_SRecordFile
00002588  6000 0290 4070          bra       menu_60
                    4071   menu_4:
                    4072   ; else if (c == (char)('D'))             // dump memory
0000258C  0C02 0044 4073          cmp.b     #68,D2
00002590  6608      4074          bne.s     menu_6
                    4075   ; DumpMemory();
00002592  4EB8 0CCC 4076          jsr       _DumpMemory
00002596  6000 0282 4077          bra       menu_60
                    4078   menu_6:
                    4079   ; else if (c == (char)('E'))             // Enter String into memory
0000259A  0C02 0045 4080          cmp.b     #69,D2
0000259E  660A      4081          bne.s     menu_8
                    4082   ; EnterString();
000025A0  4EB9 0000 4083          jsr       _EnterString
000025A4  2962      
000025A6  6000 0272 4084          bra       menu_60
                    4085   menu_8:
                    4086   ; else if (c == (char)('F'))             // fill memory
000025AA  0C02 0046 4087          cmp.b     #70,D2
000025AE  6608      4088          bne.s     menu_10
                    4089   ; FillMemory();
000025B0  4EB8 0DBC 4090          jsr       _FillMemory
000025B4  6000 0264 4091          bra       menu_60
                    4092   menu_10:
                    4093   ; else if (c == (char)('G')) {           // go user program
000025B8  0C02 0047 4094          cmp.b     #71,D2
000025BC  6626      4095          bne.s     menu_12
                    4096   ; printf("\r\nProgram Running.....");
000025BE  4879 0000 4097          pea       @lab6b_116.L
000025C2  5A96      
000025C4  4E92      4098          jsr       (A2)
000025C6  584F      4099          addq.w    #4,A7
                    4100   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop");
000025C8  4879 0000 4101          pea       @lab6b_117.L
000025CC  5AAE      
000025CE  4E92      4102          jsr       (A2)
000025D0  584F      4103          addq.w    #4,A7
                    4104   ; GoFlag = 1;
000025D2  23FC 0000 4105          move.l    #1,_GoFlag.L
000025D6  0001 0B00 
000025DA  00DC      
                    4106   ; go();
000025DC  4EB8 08B8 4107          jsr       _go
000025E0  6000 0238 4108          bra       menu_60
                    4109   menu_12:
                    4110   ; }
                    4111   ; else if (c == (char)('M'))           // memory examine and modify
000025E4  0C02 004D 4112          cmp.b     #77,D2
000025E8  6608      4113          bne.s     menu_14
                    4114   ; MemoryChange();
000025EA  4EB8 0FC4 4115          jsr       _MemoryChange
000025EE  6000 022A 4116          bra       menu_60
                    4117   menu_14:
                    4118   ; else if (c == (char)('P'))            // Program Flash Chip
000025F2  0C02 0050 4119          cmp.b     #80,D2
000025F6  6608      4120          bne.s     menu_16
                    4121   ; ProgramFlashChip();
000025F8  4EB8 12DE 4122          jsr       _ProgramFlashChip
000025FC  6000 021C 4123          bra       menu_60
                    4124   menu_16:
                    4125   ; else if (c == (char)('C'))             // copy flash chip to ram and go
00002600  0C02 0043 4126          cmp.b     #67,D2
00002604  6608      4127          bne.s     menu_18
                    4128   ; LoadFromFlashChip();
00002606  4EB8 13EC 4129          jsr       _LoadFromFlashChip
0000260A  6000 020E 4130          bra       menu_60
                    4131   menu_18:
                    4132   ; else if (c == (char)('R'))             // dump registers
0000260E  0C02 0052 4133          cmp.b     #82,D2
00002612  6608      4134          bne.s     menu_20
                    4135   ; DumpRegisters();
00002614  4EB8 14A6 4136          jsr       _DumpRegisters
00002618  6000 0200 4137          bra       menu_60
                    4138   menu_20:
                    4139   ; else if (c == (char)('.'))           // change registers
0000261C  0C02 002E 4140          cmp.b     #46,D2
00002620  6608      4141          bne.s     menu_22
                    4142   ; ChangeRegisters();
00002622  4EB8 1998 4143          jsr       _ChangeRegisters
00002626  6000 01F2 4144          bra       menu_60
                    4145   menu_22:
                    4146   ; else if (c == (char)('B'))              // breakpoint command
0000262A  0C02 0042 4147          cmp.b     #66,D2
0000262E  6608      4148          bne.s     menu_24
                    4149   ; Breakpoint();
00002630  4EB8 236C 4150          jsr       _Breakpoint
00002634  6000 01E4 4151          bra       menu_60
                    4152   menu_24:
                    4153   ; else if (c == (char)('T')) {          // Test command
00002638  0C02 0054 4154          cmp.b     #84,D2
0000263C  6600 0046 4155          bne       menu_26
                    4156   ; c1 = toupper(_getch());
00002640  2F00      4157          move.l    D0,-(A7)
00002642  4EB8 0B68 4158          jsr       __getch
00002646  2200      4159          move.l    D0,D1
00002648  201F      4160          move.l    (A7)+,D0
0000264A  2F01      4161          move.l    D1,-(A7)
0000264C  4EB9 0000 4162          jsr       _toupper
00002650  438C      
00002652  584F      4163          addq.w    #4,A7
00002654  1600      4164          move.b    D0,D3
                    4165   ; if (c1 == (char)('M'))                    // memory test
00002656  0C03 004D 4166          cmp.b     #77,D3
0000265A  6608      4167          bne.s     menu_28
                    4168   ; MemoryTest();
0000265C  4EB9 0000 4169          jsr       _MemoryTest
00002660  29B2      
00002662  601C      4170          bra.s     menu_33
                    4171   menu_28:
                    4172   ; else if (c1 == (char)('S'))              // Switch Test command
00002664  0C03 0053 4173          cmp.b     #83,D3
00002668  6606      4174          bne.s     menu_30
                    4175   ; SwitchTest();
0000266A  4EB8 0AA4 4176          jsr       _SwitchTest
0000266E  6010      4177          bra.s     menu_33
                    4178   menu_30:
                    4179   ; else if (c1 == (char)('D'))              // display Test command
00002670  0C03 0044 4180          cmp.b     #68,D3
00002674  6606      4181          bne.s     menu_32
                    4182   ; TestLEDS();
00002676  4EB8 0A50 4183          jsr       _TestLEDS
0000267A  6004      4184          bra.s     menu_33
                    4185   menu_32:
                    4186   ; else
                    4187   ; UnknownCommand();
0000267C  4EB8 2340 4188          jsr       _UnknownCommand
                    4189   menu_33:
00002680  6000 0198 4190          bra       menu_60
                    4191   menu_26:
                    4192   ; }
                    4193   ; else if (c == (char)(' ')) {             // Next instruction command
00002684  0C02 0020 4194          cmp.b     #32,D2
00002688  6636      4195          bne.s     menu_34
                    4196   ; DisableBreakPoints();
0000268A  4EB8 1F50 4197          jsr       _DisableBreakPoints
                    4198   ; if (Trace == 1 && GoFlag == 1) {    // if the program is running and trace mode on then 'N' is valid
0000268E  2013      4199          move.l    (A3),D0
00002690  0C80 0000 4200          cmp.l     #1,D0
00002694  0001      
00002696  661A      4201          bne.s     menu_36
00002698  2039 0B00 4202          move.l    _GoFlag.L,D0
0000269C  00DC      
0000269E  0C80 0000 4203          cmp.l     #1,D0
000026A2  0001      
000026A4  660C      4204          bne.s     menu_36
                    4205   ; TraceException = 1;             // generate a trace exception for the next instruction if user wants to single step though next instruction
000026A6  13FC 0001 4206          move.b    #1,4194314
000026AA  0040 000A 
                    4207   ; return;
000026AE  6000 016E 4208          bra       menu_38
                    4209   menu_36:
                    4210   ; }
                    4211   ; else
                    4212   ; printf("\r\nError: Press 'G' first to start program");
000026B2  4879 0000 4213          pea       @lab6b_118.L
000026B6  5ADC      
000026B8  4E92      4214          jsr       (A2)
000026BA  584F      4215          addq.w    #4,A7
000026BC  6000 015C 4216          bra       menu_60
                    4217   menu_34:
                    4218   ; }
                    4219   ; else if (c == (char)('S')) {             // single step
000026C0  0C02 0053 4220          cmp.b     #83,D2
000026C4  6600 008C 4221          bne       menu_39
                    4222   ; if (Trace == 0) {
000026C8  2013      4223          move.l    (A3),D0
000026CA  6600 0050 4224          bne       menu_41
                    4225   ; DisableBreakPoints();
000026CE  4EB8 1F50 4226          jsr       _DisableBreakPoints
                    4227   ; printf("\r\nSingle Step  :[ON]");
000026D2  4879 0000 4228          pea       @lab6b_119.L
000026D6  5B06      
000026D8  4E92      4229          jsr       (A2)
000026DA  584F      4230          addq.w    #4,A7
                    4231   ; printf("\r\nBreak Points :[Disabled]");
000026DC  4879 0000 4232          pea       @lab6b_52.L
000026E0  51A4      
000026E2  4E92      4233          jsr       (A2)
000026E4  584F      4234          addq.w    #4,A7
                    4235   ; SR = SR | (unsigned short int)(0x8000);    // set T bit in status register
000026E6  0055 8000 4236          or.w      #32768,(A5)
                    4237   ; printf("\r\nPress 'G' to Trace Program from address $%X.....", PC);
000026EA  2F39 0B00 4238          move.l    _PC.L,-(A7)
000026EE  0120      
000026F0  4879 0000 4239          pea       @lab6b_120.L
000026F4  5B1C      
000026F6  4E92      4240          jsr       (A2)
000026F8  504F      4241          addq.w    #8,A7
                    4242   ; printf("\r\nPush <RESET Button> to Stop.....");
000026FA  4879 0000 4243          pea       @lab6b_121.L
000026FE  5B50      
00002700  4E92      4244          jsr       (A2)
00002702  584F      4245          addq.w    #4,A7
                    4246   ; DumpRegisters();
00002704  4EB8 14A6 4247          jsr       _DumpRegisters
                    4248   ; Trace = 1;
00002708  26BC 0000 4249          move.l    #1,(A3)
0000270C  0001      
                    4250   ; TraceException = 1;
0000270E  13FC 0001 4251          move.b    #1,4194314
00002712  0040 000A 
                    4252   ; x = *(unsigned int*)(0x00000074);       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
00002716  28B8 0074 4253          move.l    116,(A4)
0000271A  6032      4254          bra.s     menu_42
                    4255   menu_41:
                    4256   ; }
                    4257   ; else {
                    4258   ; Trace = 0;
0000271C  4293      4259          clr.l     (A3)
                    4260   ; TraceException = 0;
0000271E  4239 0040 4261          clr.b     4194314
00002722  000A      
                    4262   ; x = *(unsigned int*)(0x00000074);       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
00002724  28B8 0074 4263          move.l    116,(A4)
                    4264   ; EnableBreakPoints();
00002728  4EB8 1FA4 4265          jsr       _EnableBreakPoints
                    4266   ; SR = SR & (unsigned short int)(0x7FFF);    // clear T bit in status register
0000272C  0255 7FFF 4267          and.w     #32767,(A5)
                    4268   ; printf("\r\nSingle Step : [OFF]");
00002730  4879 0000 4269          pea       @lab6b_122.L
00002734  5B74      
00002736  4E92      4270          jsr       (A2)
00002738  584F      4271          addq.w    #4,A7
                    4272   ; printf("\r\nBreak Points :[Enabled]");
0000273A  4879 0000 4273          pea       @lab6b_123.L
0000273E  5B8A      
00002740  4E92      4274          jsr       (A2)
00002742  584F      4275          addq.w    #4,A7
                    4276   ; printf("\r\nPress <ESC> to Resume User Program.....");
00002744  4879 0000 4277          pea       @lab6b_124.L
00002748  5BA4      
0000274A  4E92      4278          jsr       (A2)
0000274C  584F      4279          addq.w    #4,A7
                    4280   menu_42:
0000274E  6000 00CA 4281          bra       menu_60
                    4282   menu_39:
                    4283   ; }
                    4284   ; }
                    4285   ; else if (c == (char)(0x1b)) {   // if user choses to end trace and run program
00002752  0C02 001B 4286          cmp.b     #27,D2
00002756  6600 0042 4287          bne       menu_43
                    4288   ; Trace = 0;
0000275A  4293      4289          clr.l     (A3)
                    4290   ; TraceException = 0;
0000275C  4239 0040 4291          clr.b     4194314
00002760  000A      
                    4292   ; x = *(unsigned int*)(0x00000074);   // read IRQ 5 vector to reset trace vector generator
00002762  28B8 0074 4293          move.l    116,(A4)
                    4294   ; EnableBreakPoints();
00002766  4EB8 1FA4 4295          jsr       _EnableBreakPoints
                    4296   ; SR = SR & (unsigned short int)(0x7FFF);    // clear T bit in status register
0000276A  0255 7FFF 4297          and.w     #32767,(A5)
                    4298   ; printf("\r\nSingle Step  :[OFF]");
0000276E  4879 0000 4299          pea       @lab6b_125.L
00002772  5BCE      
00002774  4E92      4300          jsr       (A2)
00002776  584F      4301          addq.w    #4,A7
                    4302   ; printf("\r\nBreak Points :[Enabled]");
00002778  4879 0000 4303          pea       @lab6b_123.L
0000277C  5B8A      
0000277E  4E92      4304          jsr       (A2)
00002780  584F      4305          addq.w    #4,A7
                    4306   ; printf("\r\nProgram Running.....");
00002782  4879 0000 4307          pea       @lab6b_116.L
00002786  5A96      
00002788  4E92      4308          jsr       (A2)
0000278A  584F      4309          addq.w    #4,A7
                    4310   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop");
0000278C  4879 0000 4311          pea       @lab6b_117.L
00002790  5AAE      
00002792  4E92      4312          jsr       (A2)
00002794  584F      4313          addq.w    #4,A7
                    4314   ; return;
00002796  6000 0086 4315          bra       menu_38
                    4316   menu_43:
                    4317   ; }
                    4318   ; else if (c == (char)('W'))              // Watchpoint command
0000279A  0C02 0057 4319          cmp.b     #87,D2
0000279E  6608      4320          bne.s     menu_45
                    4321   ; Watchpoint();
000027A0  4EB8 23E8 4322          jsr       _Watchpoint
000027A4  6000 0074 4323          bra       menu_60
                    4324   menu_45:
                    4325   ; else if (c == (char)('1')){  //I2C Write 
000027A8  0C02 0031 4326          cmp.b     #49,D2
000027AC  660A      4327          bne.s     menu_47
                    4328   ; WriteI2C();
000027AE  4EB9 0000 4329          jsr       _WriteI2C
000027B2  30F4      
000027B4  6000 0064 4330          bra       menu_60
                    4331   menu_47:
                    4332   ; }
                    4333   ; else if (c == (char)('2')){  //I2C Read
000027B8  0C02 0032 4334          cmp.b     #50,D2
000027BC  660A      4335          bne.s     menu_49
                    4336   ; ReadI2C();
000027BE  4EB9 0000 4337          jsr       _ReadI2C
000027C2  31E4      
000027C4  6000 0054 4338          bra       menu_60
                    4339   menu_49:
                    4340   ; }
                    4341   ; else if (c == (char)('3')){  //I2C Page Write
000027C8  0C02 0033 4342          cmp.b     #51,D2
000027CC  660A      4343          bne.s     menu_51
                    4344   ; PageWriteI2C();
000027CE  4EB9 0000 4345          jsr       _PageWriteI2C
000027D2  32AA      
000027D4  6000 0044 4346          bra       menu_60
                    4347   menu_51:
                    4348   ; }
                    4349   ; else if (c == (char)('4')){  //I2C Sequential Read
000027D8  0C02 0034 4350          cmp.b     #52,D2
000027DC  6608      4351          bne.s     menu_53
                    4352   ; SeqReadI2C();
000027DE  4EB9 0000 4353          jsr       _SeqReadI2C
000027E2  334C      
000027E4  6034      4354          bra.s     menu_60
                    4355   menu_53:
                    4356   ; }
                    4357   ; else if (c == (char)('5')){  //ADC/DAC Operation
000027E6  0C02 0035 4358          cmp.b     #53,D2
000027EA  6608      4359          bne.s     menu_55
                    4360   ; DACWrite();
000027EC  4EB9 0000 4361          jsr       _DACWrite
000027F0  3CF8      
000027F2  6026      4362          bra.s     menu_60
                    4363   menu_55:
                    4364   ; }
                    4365   ; else if (c == (char)('6')){  //ADC/DAC Operation
000027F4  0C02 0036 4366          cmp.b     #54,D2
000027F8  660E      4367          bne.s     menu_57
                    4368   ; ADCRead(3);
000027FA  4878 0003 4369          pea       3
000027FE  4EB9 0000 4370          jsr       _ADCRead
00002802  3D98      
00002804  584F      4371          addq.w    #4,A7
00002806  6012      4372          bra.s     menu_60
                    4373   menu_57:
                    4374   ; }
                    4375   ; else if (c == (char)('7')){  //Can Bus test
00002808  0C02 0037 4376          cmp.b     #55,D2
0000280C  6608      4377          bne.s     menu_59
                    4378   ; CanBusTest();
0000280E  4EB9 0000 4379          jsr       _CanBusTest
00002812  4142      
00002814  6004      4380          bra.s     menu_60
                    4381   menu_59:
                    4382   ; }
                    4383   ; else
                    4384   ; UnknownCommand();
00002816  4EB8 2340 4385          jsr       _UnknownCommand
                    4386   menu_60:
0000281A  6000 FD3E 4387          bra       menu_1
                    4388   menu_38:
0000281E  4CDF 3C0C 4389          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00002822  4E75      4390          rts
                    4391   ; }
                    4392   ; }
                    4393   ; void PrintErrorMessageandAbort(char* string) {
                    4394   _PrintErrorMessageandAbort:
00002824  4E56 0000 4395          link      A6,#0
                    4396   ; printf("\r\n\r\nProgram ABORT !!!!!!\r\n");
00002828  4879 0000 4397          pea       @lab6b_126.L
0000282C  5BE4      
0000282E  4EB9 0000 4398          jsr       _printf
00002832  43B8      
00002834  584F      4399          addq.w    #4,A7
                    4400   ; printf("%s\r\n", string);
00002836  2F2E 0008 4401          move.l    8(A6),-(A7)
0000283A  4879 0000 4402          pea       @lab6b_127.L
0000283E  5C00      
00002840  4EB9 0000 4403          jsr       _printf
00002844  43B8      
00002846  504F      4404          addq.w    #8,A7
                    4405   ; menu();
00002848  4EB8 253E 4406          jsr       _menu
0000284C  4E5E      4407          unlk      A6
0000284E  4E75      4408          rts
                    4409   ; }
                    4410   ; void IRQMessage(int level) {
                    4411   _IRQMessage:
00002850  4E56 0000 4412          link      A6,#0
                    4413   ; printf("\r\n\r\nProgram ABORT !!!!!");
00002854  4879 0000 4414          pea       @lab6b_128.L
00002858  5C06      
0000285A  4EB9 0000 4415          jsr       _printf
0000285E  43B8      
00002860  584F      4416          addq.w    #4,A7
                    4417   ; printf("\r\nUnhandled Interrupt: IRQ%d !!!!!", level);
00002862  2F2E 0008 4418          move.l    8(A6),-(A7)
00002866  4879 0000 4419          pea       @lab6b_129.L
0000286A  5C1E      
0000286C  4EB9 0000 4420          jsr       _printf
00002870  43B8      
00002872  504F      4421          addq.w    #8,A7
                    4422   ; menu();
00002874  4EB8 253E 4423          jsr       _menu
00002878  4E5E      4424          unlk      A6
0000287A  4E75      4425          rts
                    4426   ; }
                    4427   ; void UnhandledIRQ1(void) {
                    4428   _UnhandledIRQ1:
                    4429   ; IRQMessage(1);
0000287C  4878 0001 4430          pea       1
00002880  4EB8 2850 4431          jsr       _IRQMessage
00002884  584F      4432          addq.w    #4,A7
00002886  4E75      4433          rts
                    4434   ; }
                    4435   ; void UnhandledIRQ2(void) {
                    4436   _UnhandledIRQ2:
                    4437   ; IRQMessage(2);
00002888  4878 0002 4438          pea       2
0000288C  4EB8 2850 4439          jsr       _IRQMessage
00002890  584F      4440          addq.w    #4,A7
00002892  4E75      4441          rts
                    4442   ; }
                    4443   ; void UnhandledIRQ3(void) {
                    4444   _UnhandledIRQ3:
                    4445   ; IRQMessage(3);
00002894  4878 0003 4446          pea       3
00002898  4EB8 2850 4447          jsr       _IRQMessage
0000289C  584F      4448          addq.w    #4,A7
0000289E  4E75      4449          rts
                    4450   ; }
                    4451   ; void UnhandledIRQ4(void) {
                    4452   _UnhandledIRQ4:
                    4453   ; IRQMessage(4);
000028A0  4878 0004 4454          pea       4
000028A4  4EB8 2850 4455          jsr       _IRQMessage
000028A8  584F      4456          addq.w    #4,A7
000028AA  4E75      4457          rts
                    4458   ; }
                    4459   ; void UnhandledIRQ5(void) {
                    4460   _UnhandledIRQ5:
                    4461   ; IRQMessage(5);
000028AC  4878 0005 4462          pea       5
000028B0  4EB8 2850 4463          jsr       _IRQMessage
000028B4  584F      4464          addq.w    #4,A7
000028B6  4E75      4465          rts
                    4466   ; }
                    4467   ; void UnhandledIRQ6(void) {
                    4468   _UnhandledIRQ6:
                    4469   ; PrintErrorMessageandAbort("ADDRESS ERROR: 16 or 32 Bit Transfer to/from an ODD Address....");
000028B8  4879 0000 4470          pea       @lab6b_130.L
000028BC  5C42      
000028BE  4EB8 2824 4471          jsr       _PrintErrorMessageandAbort
000028C2  584F      4472          addq.w    #4,A7
                    4473   ; menu();
000028C4  4EB8 253E 4474          jsr       _menu
000028C8  4E75      4475          rts
                    4476   ; }
                    4477   ; void UnhandledIRQ7(void) {
                    4478   _UnhandledIRQ7:
                    4479   ; IRQMessage(7);
000028CA  4878 0007 4480          pea       7
000028CE  4EB8 2850 4481          jsr       _IRQMessage
000028D2  584F      4482          addq.w    #4,A7
000028D4  4E75      4483          rts
                    4484   ; }
                    4485   ; void UnhandledTrap(void) {
                    4486   _UnhandledTrap:
                    4487   ; PrintErrorMessageandAbort("Unhandled Trap !!!!!");
000028D6  4879 0000 4488          pea       @lab6b_131.L
000028DA  5C82      
000028DC  4EB8 2824 4489          jsr       _PrintErrorMessageandAbort
000028E0  584F      4490          addq.w    #4,A7
000028E2  4E75      4491          rts
                    4492   ; }
                    4493   ; void BusError() {
                    4494   _BusError:
                    4495   ; PrintErrorMessageandAbort("BUS Error!");
000028E4  4879 0000 4496          pea       @lab6b_132.L
000028E8  5C98      
000028EA  4EB8 2824 4497          jsr       _PrintErrorMessageandAbort
000028EE  584F      4498          addq.w    #4,A7
000028F0  4E75      4499          rts
                    4500   ; }
                    4501   ; void AddressError() {
                    4502   _AddressError:
                    4503   ; PrintErrorMessageandAbort("ADDRESS Error!");
000028F2  4879 0000 4504          pea       @lab6b_133.L
000028F6  5CA4      
000028F8  4EB8 2824 4505          jsr       _PrintErrorMessageandAbort
000028FC  584F      4506          addq.w    #4,A7
000028FE  4E75      4507          rts
                    4508   ; }
                    4509   ; void IllegalInstruction() {
                    4510   _IllegalInstruction:
                    4511   ; PrintErrorMessageandAbort("ILLEGAL INSTRUCTION");
00002900  4879 0000 4512          pea       @lab6b_134.L
00002904  5CB4      
00002906  4EB8 2824 4513          jsr       _PrintErrorMessageandAbort
0000290A  584F      4514          addq.w    #4,A7
0000290C  4E75      4515          rts
                    4516   ; }
                    4517   ; void Dividebyzero() {
                    4518   _Dividebyzero:
                    4519   ; PrintErrorMessageandAbort("DIVIDE BY ZERO");
0000290E  4879 0000 4520          pea       @lab6b_135.L
00002912  5CC8      
00002914  4EB8 2824 4521          jsr       _PrintErrorMessageandAbort
00002918  584F      4522          addq.w    #4,A7
0000291A  4E75      4523          rts
                    4524   ; }
                    4525   ; void Check() {
                    4526   _Check:
                    4527   ; PrintErrorMessageandAbort("'CHK' INSTRUCTION");
0000291C  4879 0000 4528          pea       @lab6b_136.L
00002920  5CD8      
00002922  4EB8 2824 4529          jsr       _PrintErrorMessageandAbort
00002926  584F      4530          addq.w    #4,A7
00002928  4E75      4531          rts
                    4532   ; }
                    4533   ; void Trapv() {
                    4534   _Trapv:
                    4535   ; PrintErrorMessageandAbort("TRAPV INSTRUCTION");
0000292A  4879 0000 4536          pea       @lab6b_137.L
0000292E  5CEA      
00002930  4EB8 2824 4537          jsr       _PrintErrorMessageandAbort
00002934  584F      4538          addq.w    #4,A7
00002936  4E75      4539          rts
                    4540   ; }
                    4541   ; void PrivError() {
                    4542   _PrivError:
                    4543   ; PrintErrorMessageandAbort("PRIVILEGE VIOLATION");
00002938  4879 0000 4544          pea       @lab6b_138.L
0000293C  5CFC      
0000293E  4EB8 2824 4545          jsr       _PrintErrorMessageandAbort
00002942  584F      4546          addq.w    #4,A7
00002944  4E75      4547          rts
                    4548   ; }
                    4549   ; void UnitIRQ() {
                    4550   _UnitIRQ:
                    4551   ; PrintErrorMessageandAbort("UNINITIALISED IRQ");
00002946  4879 0000 4552          pea       @lab6b_139.L
0000294A  5D10      
0000294C  4EB8 2824 4553          jsr       _PrintErrorMessageandAbort
00002950  584F      4554          addq.w    #4,A7
00002952  4E75      4555          rts
                    4556   ; }
                    4557   ; void Spurious() {
                    4558   _Spurious:
                    4559   ; PrintErrorMessageandAbort("SPURIOUS IRQ");
00002954  4879 0000 4560          pea       @lab6b_140.L
00002958  5D22      
0000295A  4EB8 2824 4561          jsr       _PrintErrorMessageandAbort
0000295E  584F      4562          addq.w    #4,A7
00002960  4E75      4563          rts
                    4564   ; }
                    4565   ; void EnterString(void)
                    4566   ; {
                    4567   _EnterString:
00002962  4E56 FFFC 4568          link      A6,#-4
00002966  2F02      4569          move.l    D2,-(A7)
                    4570   ; unsigned char* Start;
                    4571   ; unsigned char c;
                    4572   ; printf("\r\nStart Address in Memory: ");
00002968  4879 0000 4573          pea       @lab6b_141.L
0000296C  5D30      
0000296E  4EB9 0000 4574          jsr       _printf
00002972  43B8      
00002974  584F      4575          addq.w    #4,A7
                    4576   ; Start = Get8HexDigits(0);
00002976  42A7      4577          clr.l     -(A7)
00002978  4EB8 0CA4 4578          jsr       _Get8HexDigits
0000297C  584F      4579          addq.w    #4,A7
0000297E  2400      4580          move.l    D0,D2
                    4581   ; printf("\r\nEnter String (ESC to end) :");
00002980  4879 0000 4582          pea       @lab6b_142.L
00002984  5D4C      
00002986  4EB9 0000 4583          jsr       _printf
0000298A  43B8      
0000298C  584F      4584          addq.w    #4,A7
                    4585   ; while ((c = getchar()) != 0x1b)
                    4586   EnterString_1:
0000298E  4EB9 0000 4587          jsr       _getch
00002992  42DA      
00002994  1D40 FFFF 4588          move.b    D0,-1(A6)
00002998  0C00 001B 4589          cmp.b     #27,D0
0000299C  670A      4590          beq.s     EnterString_3
                    4591   ; *Start++ = c;
0000299E  2042      4592          move.l    D2,A0
000029A0  5282      4593          addq.l    #1,D2
000029A2  10AE FFFF 4594          move.b    -1(A6),(A0)
000029A6  60E6      4595          bra       EnterString_1
                    4596   EnterString_3:
                    4597   ; *Start = 0x00;  // terminate with a null
000029A8  2042      4598          move.l    D2,A0
000029AA  4210      4599          clr.b     (A0)
000029AC  241F      4600          move.l    (A7)+,D2
000029AE  4E5E      4601          unlk      A6
000029B0  4E75      4602          rts
                    4603   ; }
                    4604   ; void MemoryTest(void)
                    4605   ; {
                    4606   _MemoryTest:
000029B2  4E56 FFBC 4607          link      A6,#-68
000029B6  48E7 3F3C 4608          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000029BA  45F9 0000 4609          lea       _printf.L,A2
000029BE  43B8      
000029C0  47F8 0CA4 4610          lea       _Get8HexDigits.L,A3
                    4611   ; char data_type_num;
                    4612   ; unsigned int test_data_num;
                    4613   ; unsigned char* StartPtrByte, * EndPtrByte, * TempPtrByte;
                    4614   ; unsigned short int* StartPtrWord, * EndPtrWord, * TempPtrWord;
                    4615   ; unsigned int* StartPtrLongWord, * EndPtrLongWord, * TempPtrLongWord;
                    4616   ; int StartPtrLongWordTruc, EndPtrLongWordTruc;
                    4617   ; unsigned char test_data_byte_list[] = { 0xAA, 0xAB, 0xCC, 0xCD };
000029C4  41EE FFD8 4618          lea       -40(A6),A0
000029C8  43F9 0000 4619          lea       MemoryTest_test_data_byte_list.L,A1
000029CC  6AA6      
000029CE  20D9      4620          move.l    (A1)+,(A0)+
                    4621   ; unsigned char test_data_byte;
                    4622   ; unsigned char read_data_byte;
                    4623   ; unsigned  int test_data_word_list[] = { 0xAAAA, 0xBABA, 0xCCDD, 0xDDDD };
000029D0  41EE FFDE 4624          lea       -34(A6),A0
000029D4  43F9 0000 4625          lea       MemoryTest_test_data_word_list.L,A1
000029D8  6AAA      
000029DA  7003      4626          moveq     #3,D0
000029DC  20D9      4627          move.l    (A1)+,(A0)+
000029DE  51C8 FFFC 4628          dbra      D0,*-2
                    4629   ; unsigned  int test_data_word;
                    4630   ; unsigned int test_data_long_word_list[] = { 0xAAAAAAAA, 0xABABABAB, 0xCCCCDDDD, 0xAABBCCDD };
000029E2  41EE FFEE 4631          lea       -18(A6),A0
000029E6  43F9 0000 4632          lea       MemoryTest_test_data_long_word_list.L,A1
000029EA  6ABA      
000029EC  7003      4633          moveq     #3,D0
000029EE  20D9      4634          move.l    (A1)+,(A0)+
000029F0  51C8 FFFC 4635          dbra      D0,*-2
                    4636   ; unsigned int test_data_long_word;
                    4637   ; unsigned short truncated_data;
                    4638   ; printf("\r\nEnter the value below for the size of the test you would like to use?\n1 = bytes (8 bits)\n2 = words (16 bits)\n3 = long words (32 bits)\n");
000029F4  4879 0000 4639          pea       @lab6b_143.L
000029F8  5D6A      
000029FA  4E92      4640          jsr       (A2)
000029FC  584F      4641          addq.w    #4,A7
                    4642   ; data_type_num = _getch();
000029FE  4EB8 0B68 4643          jsr       __getch
00002A02  1D40 FFBF 4644          move.b    D0,-65(A6)
                    4645   ; switch (data_type_num) {
00002A06  102E FFBF 4646          move.b    -65(A6),D0
00002A0A  4880      4647          ext.w     D0
00002A0C  48C0      4648          ext.l     D0
00002A0E  0C80 0000 4649          cmp.l     #50,D0
00002A12  0032      
00002A14  6700 0218 4650          beq       MemoryTest_4
00002A18  6E0C      4651          bgt.s     MemoryTest_7
00002A1A  0C80 0000 4652          cmp.l     #49,D0
00002A1E  0031      
00002A20  6712      4653          beq.s     MemoryTest_3
00002A22  6000 06BE 4654          bra       MemoryTest_1
                    4655   MemoryTest_7:
00002A26  0C80 0000 4656          cmp.l     #51,D0
00002A2A  0033      
00002A2C  6700 0422 4657          beq       MemoryTest_5
00002A30  6000 06B0 4658          bra       MemoryTest_1
                    4659   MemoryTest_3:
                    4660   ; case (char)('1') :
                    4661   ; printf("\nYou have selcted to use bytes size data to test your memory\n");
00002A34  4879 0000 4662          pea       @lab6b_144.L
00002A38  5DF4      
00002A3A  4E92      4663          jsr       (A2)
00002A3C  584F      4664          addq.w    #4,A7
                    4665   ; printf("Out of the below example test data, please select one by entering the value associated to each example:\n");
00002A3E  4879 0000 4666          pea       @lab6b_145.L
00002A42  5E32      
00002A44  4E92      4667          jsr       (A2)
00002A46  584F      4668          addq.w    #4,A7
                    4669   ; printf("1 = \"AA\"\n2 = \"AB\"\n3 = \"CC\"\n4 = \"CD\"\n");
00002A48  4879 0000 4670          pea       @lab6b_146.L
00002A4C  5E9C      
00002A4E  4E92      4671          jsr       (A2)
00002A50  584F      4672          addq.w    #4,A7
                    4673   ; do {
                    4674   MemoryTest_8:
                    4675   ; test_data_num = (int)(_getch());
00002A52  4EB8 0B68 4676          jsr       __getch
00002A56  2400      4677          move.l    D0,D2
                    4678   ; if (test_data_num != (int)('1') && test_data_num != (int)('2') && test_data_num != (int)('3') && test_data_num != (int)('4')) {
00002A58  0C82 0000 4679          cmp.l     #49,D2
00002A5C  0031      
00002A5E  6722      4680          beq.s     MemoryTest_10
00002A60  0C82 0000 4681          cmp.l     #50,D2
00002A64  0032      
00002A66  671A      4682          beq.s     MemoryTest_10
00002A68  0C82 0000 4683          cmp.l     #51,D2
00002A6C  0033      
00002A6E  6712      4684          beq.s     MemoryTest_10
00002A70  0C82 0000 4685          cmp.l     #52,D2
00002A74  0034      
00002A76  670A      4686          beq.s     MemoryTest_10
                    4687   ; printf("\r\nERROR: You have entered a keyboard input that does not associated with an option above, please try again\r\n");
00002A78  4879 0000 4688          pea       @lab6b_147.L
00002A7C  5EC2      
00002A7E  4E92      4689          jsr       (A2)
00002A80  584F      4690          addq.w    #4,A7
                    4691   MemoryTest_10:
00002A82  0C82 0000 4692          cmp.l     #49,D2
00002A86  0031      
00002A88  6718      4693          beq.s     MemoryTest_12
00002A8A  0C82 0000 4694          cmp.l     #50,D2
00002A8E  0032      
00002A90  6710      4695          beq.s     MemoryTest_12
00002A92  0C82 0000 4696          cmp.l     #51,D2
00002A96  0033      
00002A98  6708      4697          beq.s     MemoryTest_12
00002A9A  0C82 0000 4698          cmp.l     #52,D2
00002A9E  0034      
00002AA0  66B0      4699          bne       MemoryTest_8
                    4700   MemoryTest_12:
                    4701   ; }
                    4702   ; } while (test_data_num != (int)('1') && test_data_num != (int)('2') && test_data_num != (int)('3') && test_data_num != (int)('4'));
                    4703   ; if (test_data_num == (int)('1')) {
00002AA2  0C82 0000 4704          cmp.l     #49,D2
00002AA6  0031      
00002AA8  660A      4705          bne.s     MemoryTest_13
                    4706   ; test_data_byte = test_data_byte_list[0];
00002AAA  1D6E FFD8 4707          move.b    -40+0(A6),-36(A6)
00002AAE  FFDC      
00002AB0  6000 0040 4708          bra       MemoryTest_20
                    4709   MemoryTest_13:
                    4710   ; }
                    4711   ; else if (test_data_num == (int)('2')) {
00002AB4  0C82 0000 4712          cmp.l     #50,D2
00002AB8  0032      
00002ABA  6608      4713          bne.s     MemoryTest_15
                    4714   ; test_data_byte = test_data_byte_list[1];
00002ABC  1D6E FFD9 4715          move.b    -40+1(A6),-36(A6)
00002AC0  FFDC      
00002AC2  602E      4716          bra.s     MemoryTest_20
                    4717   MemoryTest_15:
                    4718   ; }
                    4719   ; else if (test_data_num == (int)('3')) {
00002AC4  0C82 0000 4720          cmp.l     #51,D2
00002AC8  0033      
00002ACA  6608      4721          bne.s     MemoryTest_17
                    4722   ; test_data_byte = test_data_byte_list[2];
00002ACC  1D6E FFDA 4723          move.b    -40+2(A6),-36(A6)
00002AD0  FFDC      
00002AD2  601E      4724          bra.s     MemoryTest_20
                    4725   MemoryTest_17:
                    4726   ; }
                    4727   ; else if (test_data_num == (int)('4')) {
00002AD4  0C82 0000 4728          cmp.l     #52,D2
00002AD8  0034      
00002ADA  6608      4729          bne.s     MemoryTest_19
                    4730   ; test_data_byte = test_data_byte_list[3];
00002ADC  1D6E FFDB 4731          move.b    -40+3(A6),-36(A6)
00002AE0  FFDC      
00002AE2  600E      4732          bra.s     MemoryTest_20
                    4733   MemoryTest_19:
                    4734   ; }
                    4735   ; else {
                    4736   ; printf("\r\nERROR: Option memory complication. Exiting memory test...\r\n");
00002AE4  4879 0000 4737          pea       @lab6b_148.L
00002AE8  5F30      
00002AEA  4E92      4738          jsr       (A2)
00002AEC  584F      4739          addq.w    #4,A7
                    4740   ; return;
00002AEE  6000 05FC 4741          bra       MemoryTest_2
                    4742   MemoryTest_20:
                    4743   ; }
                    4744   ; printf("\r\nPlease enter the start address you would like to use for the test data into memory\r\n");
00002AF2  4879 0000 4745          pea       @lab6b_149.L
00002AF6  5F6E      
00002AF8  4E92      4746          jsr       (A2)
00002AFA  584F      4747          addq.w    #4,A7
                    4748   ; do{
                    4749   MemoryTest_22:
                    4750   ; StartPtrByte = (int)Get8HexDigits(0);
00002AFC  42A7      4751          clr.l     -(A7)
00002AFE  4E93      4752          jsr       (A3)
00002B00  584F      4753          addq.w    #4,A7
00002B02  2A00      4754          move.l    D0,D5
                    4755   ; if(StartPtrByte < (int)(0x09000000) || StartPtrByte > (int)(0x09800000)){
00002B04  0C85 0900 4756          cmp.l     #150994944,D5
00002B08  0000      
00002B0A  6508      4757          blo.s     MemoryTest_26
00002B0C  0C85 0980 4758          cmp.l     #159383552,D5
00002B10  0000      
00002B12  630A      4759          bls.s     MemoryTest_24
                    4760   MemoryTest_26:
                    4761   ; printf("\r\nERROR: Starting Address is outside of 68K memory range. Please try again and ensure the address is withn 0x08020000 - 0x097FFFFF\r\n");
00002B14  4879 0000 4762          pea       @lab6b_150.L
00002B18  5FC6      
00002B1A  4E92      4763          jsr       (A2)
00002B1C  584F      4764          addq.w    #4,A7
                    4765   MemoryTest_24:
00002B1E  0C85 0900 4766          cmp.l     #150994944,D5
00002B22  0000      
00002B24  65D6      4767          blo       MemoryTest_22
00002B26  0C85 0980 4768          cmp.l     #159383552,D5
00002B2A  0000      
00002B2C  62CE      4769          bhi       MemoryTest_22
                    4770   ; }
                    4771   ; } while(StartPtrByte < (int)(0x09000000) || StartPtrByte > (int)(0x09800000));
                    4772   ; printf("\r\nPlease enter the end address you would like to use for the test data in memory\r\n");
00002B2E  4879 0000 4773          pea       @lab6b_151.L
00002B32  604C      
00002B34  4E92      4774          jsr       (A2)
00002B36  584F      4775          addq.w    #4,A7
                    4776   ; do{
                    4777   MemoryTest_27:
                    4778   ; EndPtrByte = (int)Get8HexDigits(0);
00002B38  42A7      4779          clr.l     -(A7)
00002B3A  4E93      4780          jsr       (A3)
00002B3C  584F      4781          addq.w    #4,A7
00002B3E  2D40 FFC0 4782          move.l    D0,-64(A6)
                    4783   ; if(EndPtrByte < (int)(0x09000000) || EndPtrByte > (int)(0x09800000)){
00002B42  202E FFC0 4784          move.l    -64(A6),D0
00002B46  0C80 0900 4785          cmp.l     #150994944,D0
00002B4A  0000      
00002B4C  650C      4786          blo.s     MemoryTest_31
00002B4E  202E FFC0 4787          move.l    -64(A6),D0
00002B52  0C80 0980 4788          cmp.l     #159383552,D0
00002B56  0000      
00002B58  630A      4789          bls.s     MemoryTest_29
                    4790   MemoryTest_31:
                    4791   ; printf("\r\nERROR: End Address is outside of 68K memory range. Please try again and ensure the address is withn 0x08020000 - 0x097FFFFF\r\n");
00002B5A  4879 0000 4792          pea       @lab6b_152.L
00002B5E  60A0      
00002B60  4E92      4793          jsr       (A2)
00002B62  584F      4794          addq.w    #4,A7
                    4795   MemoryTest_29:
00002B64  202E FFC0 4796          move.l    -64(A6),D0
00002B68  0C80 0900 4797          cmp.l     #150994944,D0
00002B6C  0000      
00002B6E  65C8      4798          blo       MemoryTest_27
00002B70  202E FFC0 4799          move.l    -64(A6),D0
00002B74  0C80 0980 4800          cmp.l     #159383552,D0
00002B78  0000      
00002B7A  62BC      4801          bhi       MemoryTest_27
                    4802   ; }
                    4803   ; } while(EndPtrByte < (int)(0x09000000) || EndPtrByte > (int)(0x09800000));
                    4804   ; printf("\r\n\r\nWriting to memory");
00002B7C  4879 0000 4805          pea       @lab6b_153.L
00002B80  6120      
00002B82  4E92      4806          jsr       (A2)
00002B84  584F      4807          addq.w    #4,A7
                    4808   ; TempPtrByte = StartPtrByte;
00002B86  2D45 FFC4 4809          move.l    D5,-60(A6)
                    4810   ; while (StartPtrByte < EndPtrByte) {
                    4811   MemoryTest_32:
00002B8A  BAAE FFC0 4812          cmp.l     -64(A6),D5
00002B8E  6424      4813          bhs.s     MemoryTest_34
                    4814   ; *StartPtrByte = test_data_byte;
00002B90  2045      4815          move.l    D5,A0
00002B92  10AE FFDC 4816          move.b    -36(A6),(A0)
                    4817   ; printf("\r\nWRITE: [%02X to %08x]", test_data_byte, StartPtrByte);
00002B96  2F05      4818          move.l    D5,-(A7)
00002B98  122E FFDC 4819          move.b    -36(A6),D1
00002B9C  C2BC 0000 4820          and.l     #255,D1
00002BA0  00FF      
00002BA2  2F01      4821          move.l    D1,-(A7)
00002BA4  4879 0000 4822          pea       @lab6b_154.L
00002BA8  6136      
00002BAA  4E92      4823          jsr       (A2)
00002BAC  DEFC 000C 4824          add.w     #12,A7
                    4825   ; StartPtrByte++;
00002BB0  5285      4826          addq.l    #1,D5
00002BB2  60D6      4827          bra       MemoryTest_32
                    4828   MemoryTest_34:
                    4829   ; }
                    4830   ; printf("\r\n\r\nStarting memory validation test");
00002BB4  4879 0000 4831          pea       @lab6b_155.L
00002BB8  614E      
00002BBA  4E92      4832          jsr       (A2)
00002BBC  584F      4833          addq.w    #4,A7
                    4834   ; StartPtrByte = TempPtrByte;
00002BBE  2A2E FFC4 4835          move.l    -60(A6),D5
                    4836   ; printf("\r\nVerifying the addresses [%08x to %08x] contains test data [%02X].....", StartPtrByte, EndPtrByte, test_data_byte);
00002BC2  122E FFDC 4837          move.b    -36(A6),D1
00002BC6  C2BC 0000 4838          and.l     #255,D1
00002BCA  00FF      
00002BCC  2F01      4839          move.l    D1,-(A7)
00002BCE  2F2E FFC0 4840          move.l    -64(A6),-(A7)
00002BD2  2F05      4841          move.l    D5,-(A7)
00002BD4  4879 0000 4842          pea       @lab6b_156.L
00002BD8  6172      
00002BDA  4E92      4843          jsr       (A2)
00002BDC  DEFC 0010 4844          add.w     #16,A7
                    4845   ; while (StartPtrByte < EndPtrByte) {
                    4846   MemoryTest_35:
00002BE0  BAAE FFC0 4847          cmp.l     -64(A6),D5
00002BE4  6400 003A 4848          bhs       MemoryTest_37
                    4849   ; if (*StartPtrByte != test_data_byte) {
00002BE8  2045      4850          move.l    D5,A0
00002BEA  1010      4851          move.b    (A0),D0
00002BEC  B02E FFDC 4852          cmp.b     -36(A6),D0
00002BF0  672A      4853          beq.s     MemoryTest_38
                    4854   ; printf("\r\nERROR: Data within memory does not match selected test data! [Address: %08x Exact Data: %02X Expected Data: %02X] Exiting memory test...\r\n", StartPtrByte, *StartPtrByte, test_data_byte);
00002BF2  122E FFDC 4855          move.b    -36(A6),D1
00002BF6  C2BC 0000 4856          and.l     #255,D1
00002BFA  00FF      
00002BFC  2F01      4857          move.l    D1,-(A7)
00002BFE  2045      4858          move.l    D5,A0
00002C00  1210      4859          move.b    (A0),D1
00002C02  C2BC 0000 4860          and.l     #255,D1
00002C06  00FF      
00002C08  2F01      4861          move.l    D1,-(A7)
00002C0A  2F05      4862          move.l    D5,-(A7)
00002C0C  4879 0000 4863          pea       @lab6b_157.L
00002C10  61BA      
00002C12  4E92      4864          jsr       (A2)
00002C14  DEFC 0010 4865          add.w     #16,A7
                    4866   ; return;
00002C18  6000 04D2 4867          bra       MemoryTest_2
                    4868   MemoryTest_38:
                    4869   ; }
                    4870   ; StartPtrByte++;
00002C1C  5285      4871          addq.l    #1,D5
00002C1E  60C0      4872          bra       MemoryTest_35
                    4873   MemoryTest_37:
                    4874   ; }
                    4875   ; printf("\r\nPASS: Memory Validation test has passed!\r\n");
00002C20  4879 0000 4876          pea       @lab6b_158.L
00002C24  6248      
00002C26  4E92      4877          jsr       (A2)
00002C28  584F      4878          addq.w    #4,A7
                    4879   ; break;
00002C2A  6000 04C0 4880          bra       MemoryTest_2
                    4881   MemoryTest_4:
                    4882   ; case (char)('2') :
                    4883   ; printf("\r\nYou have selcted to use word size data to test your memory");
00002C2E  4879 0000 4884          pea       @lab6b_159.L
00002C32  6276      
00002C34  4E92      4885          jsr       (A2)
00002C36  584F      4886          addq.w    #4,A7
                    4887   ; printf("\r\nOut of the below example test data, please select one by entering the value associated to each example:");
00002C38  4879 0000 4888          pea       @lab6b_160.L
00002C3C  62B4      
00002C3E  4E92      4889          jsr       (A2)
00002C40  584F      4890          addq.w    #4,A7
                    4891   ; printf("\r\n1 = \"AAAA\"\n2 = \"BABA\"\n3 = \"CCDD\"\n4 = \"DDDD\"\r\n");
00002C42  4879 0000 4892          pea       @lab6b_161.L
00002C46  631E      
00002C48  4E92      4893          jsr       (A2)
00002C4A  584F      4894          addq.w    #4,A7
                    4895   ; do {
                    4896   MemoryTest_40:
                    4897   ; test_data_num = (int)(_getch());
00002C4C  4EB8 0B68 4898          jsr       __getch
00002C50  2400      4899          move.l    D0,D2
                    4900   ; if (test_data_num != (int)('1') && test_data_num != (int)('2') && test_data_num != (int)('3') && test_data_num != (int)('4')) {
00002C52  0C82 0000 4901          cmp.l     #49,D2
00002C56  0031      
00002C58  6722      4902          beq.s     MemoryTest_42
00002C5A  0C82 0000 4903          cmp.l     #50,D2
00002C5E  0032      
00002C60  671A      4904          beq.s     MemoryTest_42
00002C62  0C82 0000 4905          cmp.l     #51,D2
00002C66  0033      
00002C68  6712      4906          beq.s     MemoryTest_42
00002C6A  0C82 0000 4907          cmp.l     #52,D2
00002C6E  0034      
00002C70  670A      4908          beq.s     MemoryTest_42
                    4909   ; printf("\r\nERROR: You have entered a keyboard input that does not associated with an option above, please try again\r\n");
00002C72  4879 0000 4910          pea       @lab6b_147.L
00002C76  5EC2      
00002C78  4E92      4911          jsr       (A2)
00002C7A  584F      4912          addq.w    #4,A7
                    4913   MemoryTest_42:
00002C7C  0C82 0000 4914          cmp.l     #49,D2
00002C80  0031      
00002C82  6718      4915          beq.s     MemoryTest_44
00002C84  0C82 0000 4916          cmp.l     #50,D2
00002C88  0032      
00002C8A  6710      4917          beq.s     MemoryTest_44
00002C8C  0C82 0000 4918          cmp.l     #51,D2
00002C90  0033      
00002C92  6708      4919          beq.s     MemoryTest_44
00002C94  0C82 0000 4920          cmp.l     #52,D2
00002C98  0034      
00002C9A  66B0      4921          bne       MemoryTest_40
                    4922   MemoryTest_44:
                    4923   ; }
                    4924   ; } while (test_data_num != (int)('1') && test_data_num != (int)('2') && test_data_num != (int)('3') && test_data_num != (int)('4'));
                    4925   ; if (test_data_num == (int)('1')) {
00002C9C  0C82 0000 4926          cmp.l     #49,D2
00002CA0  0031      
00002CA2  6608      4927          bne.s     MemoryTest_45
                    4928   ; test_data_word = test_data_word_list[0];
00002CA4  2A6E FFDE 4929          move.l    -34+0(A6),A5
00002CA8  6000 003A 4930          bra       MemoryTest_52
                    4931   MemoryTest_45:
                    4932   ; }
                    4933   ; else if (test_data_num == (int)('2')) {
00002CAC  0C82 0000 4934          cmp.l     #50,D2
00002CB0  0032      
00002CB2  6606      4935          bne.s     MemoryTest_47
                    4936   ; test_data_word = test_data_word_list[1];
00002CB4  2A6E FFE2 4937          move.l    -34+4(A6),A5
00002CB8  602A      4938          bra.s     MemoryTest_52
                    4939   MemoryTest_47:
                    4940   ; }
                    4941   ; else if (test_data_num == (int)('3')) {
00002CBA  0C82 0000 4942          cmp.l     #51,D2
00002CBE  0033      
00002CC0  6606      4943          bne.s     MemoryTest_49
                    4944   ; test_data_word = test_data_word_list[2];
00002CC2  2A6E FFE6 4945          move.l    -34+8(A6),A5
00002CC6  601C      4946          bra.s     MemoryTest_52
                    4947   MemoryTest_49:
                    4948   ; }
                    4949   ; else if (test_data_num == (int)('4')) {
00002CC8  0C82 0000 4950          cmp.l     #52,D2
00002CCC  0034      
00002CCE  6606      4951          bne.s     MemoryTest_51
                    4952   ; test_data_word = test_data_word_list[3];
00002CD0  2A6E FFEA 4953          move.l    -34+12(A6),A5
00002CD4  600E      4954          bra.s     MemoryTest_52
                    4955   MemoryTest_51:
                    4956   ; }
                    4957   ; else {
                    4958   ; printf("\r\nERROR: Option memory complication. Exiting memory test...\r\n");
00002CD6  4879 0000 4959          pea       @lab6b_148.L
00002CDA  5F30      
00002CDC  4E92      4960          jsr       (A2)
00002CDE  584F      4961          addq.w    #4,A7
                    4962   ; return;
00002CE0  6000 040A 4963          bra       MemoryTest_2
                    4964   MemoryTest_52:
                    4965   ; }
                    4966   ; do {
                    4967   MemoryTest_53:
                    4968   ; printf("\r\nPlease enter the start address you would like to use for the test data into memory (Ensure to enter an even number)\r\n");
00002CE4  4879 0000 4969          pea       @lab6b_162.L
00002CE8  634E      
00002CEA  4E92      4970          jsr       (A2)
00002CEC  584F      4971          addq.w    #4,A7
                    4972   ; StartPtrWord = Get8HexDigits(0);
00002CEE  42A7      4973          clr.l     -(A7)
00002CF0  4E93      4974          jsr       (A3)
00002CF2  584F      4975          addq.w    #4,A7
00002CF4  2800      4976          move.l    D0,D4
                    4977   ; while(StartPtrWord < (int)(0x09000000) || StartPtrWord > (int)(0x09800000)){
                    4978   MemoryTest_55:
00002CF6  0C84 0900 4979          cmp.l     #150994944,D4
00002CFA  0000      
00002CFC  6508      4980          blo.s     MemoryTest_58
00002CFE  0C84 0980 4981          cmp.l     #159383552,D4
00002D02  0000      
00002D04  6314      4982          bls.s     MemoryTest_57
                    4983   MemoryTest_58:
                    4984   ; printf("\r\nERROR: Starting Address is outside of 68K memory range. Please try again and ensure the address is withn 0x09000000 - 0x097FFFFF\r\n");
00002D06  4879 0000 4985          pea       @lab6b_163.L
00002D0A  63C6      
00002D0C  4E92      4986          jsr       (A2)
00002D0E  584F      4987          addq.w    #4,A7
                    4988   ; StartPtrWord = Get8HexDigits(0);
00002D10  42A7      4989          clr.l     -(A7)
00002D12  4E93      4990          jsr       (A3)
00002D14  584F      4991          addq.w    #4,A7
00002D16  2800      4992          move.l    D0,D4
00002D18  60DC      4993          bra       MemoryTest_55
                    4994   MemoryTest_57:
                    4995   ; }
                    4996   ; if (StartPtrWord % 2 != 0) {
00002D1A  2F04      4997          move.l    D4,-(A7)
00002D1C  4878 0002 4998          pea       2
00002D20  4EB9 0000 4999          jsr       ULDIV
00002D24  41CC      
00002D26  202F 0004 5000          move.l    4(A7),D0
00002D2A  504F      5001          addq.w    #8,A7
00002D2C  4A80      5002          tst.l     D0
00002D2E  670A      5003          beq.s     MemoryTest_59
                    5004   ; printf("\r\nERROR: The address you have entered is not even. Please try again\r\n");
00002D30  4879 0000 5005          pea       @lab6b_164.L
00002D34  644C      
00002D36  4E92      5006          jsr       (A2)
00002D38  584F      5007          addq.w    #4,A7
                    5008   MemoryTest_59:
00002D3A  2F04      5009          move.l    D4,-(A7)
00002D3C  4878 0002 5010          pea       2
00002D40  4EB9 0000 5011          jsr       ULDIV
00002D44  41CC      
00002D46  202F 0004 5012          move.l    4(A7),D0
00002D4A  504F      5013          addq.w    #8,A7
00002D4C  4A80      5014          tst.l     D0
00002D4E  6694      5015          bne       MemoryTest_53
                    5016   ; }
                    5017   ; } while (StartPtrWord % 2 != 0);
                    5018   ; do {
                    5019   MemoryTest_61:
                    5020   ; printf("\r\nPlease enter the end address you would like to use for the test data in memory (Ensure to enter an even number)\r\n");
00002D50  4879 0000 5021          pea       @lab6b_165.L
00002D54  6492      
00002D56  4E92      5022          jsr       (A2)
00002D58  584F      5023          addq.w    #4,A7
                    5024   ; EndPtrWord = Get8HexDigits(0);
00002D5A  42A7      5025          clr.l     -(A7)
00002D5C  4E93      5026          jsr       (A3)
00002D5E  584F      5027          addq.w    #4,A7
00002D60  2840      5028          move.l    D0,A4
                    5029   ; while(EndPtrWord < (int)(0x09000000) || EndPtrWord > (int)(0x09800000)){
                    5030   MemoryTest_63:
00002D62  200C      5031          move.l    A4,D0
00002D64  0C80 0900 5032          cmp.l     #150994944,D0
00002D68  0000      
00002D6A  650A      5033          blo.s     MemoryTest_66
00002D6C  200C      5034          move.l    A4,D0
00002D6E  0C80 0980 5035          cmp.l     #159383552,D0
00002D72  0000      
00002D74  6314      5036          bls.s     MemoryTest_65
                    5037   MemoryTest_66:
                    5038   ; printf("\r\nERROR: End Address is outside of 68K memory range. Please try again and ensure the address is withn 0x09000000 - 0x097FFFFF\r\n");
00002D76  4879 0000 5039          pea       @lab6b_166.L
00002D7A  6506      
00002D7C  4E92      5040          jsr       (A2)
00002D7E  584F      5041          addq.w    #4,A7
                    5042   ; EndPtrWord = Get8HexDigits(0);
00002D80  42A7      5043          clr.l     -(A7)
00002D82  4E93      5044          jsr       (A3)
00002D84  584F      5045          addq.w    #4,A7
00002D86  2840      5046          move.l    D0,A4
00002D88  60D8      5047          bra       MemoryTest_63
                    5048   MemoryTest_65:
                    5049   ; }
                    5050   ; if (EndPtrWord % 2 != 0) {
00002D8A  2F0C      5051          move.l    A4,-(A7)
00002D8C  4878 0002 5052          pea       2
00002D90  4EB9 0000 5053          jsr       ULDIV
00002D94  41CC      
00002D96  202F 0004 5054          move.l    4(A7),D0
00002D9A  504F      5055          addq.w    #8,A7
00002D9C  4A80      5056          tst.l     D0
00002D9E  670A      5057          beq.s     MemoryTest_67
                    5058   ; printf("\r\nERROR: The address you have entered is not even. Please try again\r\n");
00002DA0  4879 0000 5059          pea       @lab6b_164.L
00002DA4  644C      
00002DA6  4E92      5060          jsr       (A2)
00002DA8  584F      5061          addq.w    #4,A7
                    5062   MemoryTest_67:
00002DAA  2F0C      5063          move.l    A4,-(A7)
00002DAC  4878 0002 5064          pea       2
00002DB0  4EB9 0000 5065          jsr       ULDIV
00002DB4  41CC      
00002DB6  202F 0004 5066          move.l    4(A7),D0
00002DBA  504F      5067          addq.w    #8,A7
00002DBC  4A80      5068          tst.l     D0
00002DBE  6690      5069          bne       MemoryTest_61
                    5070   ; }
                    5071   ; } while (EndPtrWord % 2 != 0);
                    5072   ; printf("\r\n\r\nWriting to memory");
00002DC0  4879 0000 5073          pea       @lab6b_153.L
00002DC4  6120      
00002DC6  4E92      5074          jsr       (A2)
00002DC8  584F      5075          addq.w    #4,A7
                    5076   ; TempPtrWord = StartPtrWord;
00002DCA  2D44 FFC8 5077          move.l    D4,-56(A6)
                    5078   ; while (StartPtrWord < EndPtrWord) {
                    5079   MemoryTest_69:
00002DCE  B88C      5080          cmp.l     A4,D4
00002DD0  6418      5081          bhs.s     MemoryTest_71
                    5082   ; *StartPtrWord = test_data_word;
00002DD2  2044      5083          move.l    D4,A0
00002DD4  308D      5084          move.w    A5,(A0)
                    5085   ; printf("\r\nWRITE: [%04X to %08x]", test_data_word, StartPtrWord);
00002DD6  2F04      5086          move.l    D4,-(A7)
00002DD8  2F0D      5087          move.l    A5,-(A7)
00002DDA  4879 0000 5088          pea       @lab6b_167.L
00002DDE  6586      
00002DE0  4E92      5089          jsr       (A2)
00002DE2  DEFC 000C 5090          add.w     #12,A7
                    5091   ; StartPtrWord++;
00002DE6  5484      5092          addq.l    #2,D4
00002DE8  60E4      5093          bra       MemoryTest_69
                    5094   MemoryTest_71:
                    5095   ; }
                    5096   ; printf("\r\n\r\nStarting memory validation test");
00002DEA  4879 0000 5097          pea       @lab6b_155.L
00002DEE  614E      
00002DF0  4E92      5098          jsr       (A2)
00002DF2  584F      5099          addq.w    #4,A7
                    5100   ; StartPtrWord = TempPtrWord;
00002DF4  282E FFC8 5101          move.l    -56(A6),D4
                    5102   ; printf("\r\nVerifying the addresses [%08x to %08x] contains test data [%02X].....", StartPtrWord, EndPtrWord, test_data_word);
00002DF8  2F0D      5103          move.l    A5,-(A7)
00002DFA  2F0C      5104          move.l    A4,-(A7)
00002DFC  2F04      5105          move.l    D4,-(A7)
00002DFE  4879 0000 5106          pea       @lab6b_156.L
00002E02  6172      
00002E04  4E92      5107          jsr       (A2)
00002E06  DEFC 0010 5108          add.w     #16,A7
                    5109   ; while (StartPtrWord < EndPtrWord) {
                    5110   MemoryTest_72:
00002E0A  B88C      5111          cmp.l     A4,D4
00002E0C  6400 0034 5112          bhs       MemoryTest_74
                    5113   ; if (*StartPtrWord != test_data_word) {
00002E10  2044      5114          move.l    D4,A0
00002E12  3010      5115          move.w    (A0),D0
00002E14  C0BC 0000 5116          and.l     #65535,D0
00002E18  FFFF      
00002E1A  B08D      5117          cmp.l     A5,D0
00002E1C  6720      5118          beq.s     MemoryTest_75
                    5119   ; printf("\r\nERROR: Data within memory does not match selected test data! [Address: %08x Exact Data: %02X Expected Data: %02X] Exiting memory test...", StartPtrWord, *StartPtrWord, test_data_word);
00002E1E  2F0D      5120          move.l    A5,-(A7)
00002E20  2044      5121          move.l    D4,A0
00002E22  3210      5122          move.w    (A0),D1
00002E24  C2BC 0000 5123          and.l     #65535,D1
00002E28  FFFF      
00002E2A  2F01      5124          move.l    D1,-(A7)
00002E2C  2F04      5125          move.l    D4,-(A7)
00002E2E  4879 0000 5126          pea       @lab6b_168.L
00002E32  659E      
00002E34  4E92      5127          jsr       (A2)
00002E36  DEFC 0010 5128          add.w     #16,A7
                    5129   ; return;
00002E3A  6000 02B0 5130          bra       MemoryTest_2
                    5131   MemoryTest_75:
                    5132   ; }
                    5133   ; StartPtrWord++;
00002E3E  5484      5134          addq.l    #2,D4
00002E40  60C8      5135          bra       MemoryTest_72
                    5136   MemoryTest_74:
                    5137   ; }
                    5138   ; printf("\r\nPASS: Memory Validation test has passed!\r\n");
00002E42  4879 0000 5139          pea       @lab6b_158.L
00002E46  6248      
00002E48  4E92      5140          jsr       (A2)
00002E4A  584F      5141          addq.w    #4,A7
                    5142   ; break;
00002E4C  6000 029E 5143          bra       MemoryTest_2
                    5144   MemoryTest_5:
                    5145   ; case (char)('3') :
                    5146   ; printf("\r\nYou have selcted to use bytes size data to test your memory");
00002E50  4879 0000 5147          pea       @lab6b_169.L
00002E54  662A      
00002E56  4E92      5148          jsr       (A2)
00002E58  584F      5149          addq.w    #4,A7
                    5150   ; printf("\r\nOut of the below example test data, please select one by entering the value associated to each example:");
00002E5A  4879 0000 5151          pea       @lab6b_160.L
00002E5E  62B4      
00002E60  4E92      5152          jsr       (A2)
00002E62  584F      5153          addq.w    #4,A7
                    5154   ; printf("\r\n1 = \"AAAAAAAA\"\n2 = \"ABABABAB\"\n3 = \"CCCCDDDD\"\n4 = \"AABBCCDD\"\r\n");
00002E64  4879 0000 5155          pea       @lab6b_170.L
00002E68  6668      
00002E6A  4E92      5156          jsr       (A2)
00002E6C  584F      5157          addq.w    #4,A7
                    5158   ; do {
                    5159   MemoryTest_77:
                    5160   ; test_data_num = (int)(_getch());
00002E6E  4EB8 0B68 5161          jsr       __getch
00002E72  2400      5162          move.l    D0,D2
                    5163   ; if (test_data_num != (int)('1') && test_data_num != (int)('2') && test_data_num != (int)('3') && test_data_num != (int)('4')) {
00002E74  0C82 0000 5164          cmp.l     #49,D2
00002E78  0031      
00002E7A  6722      5165          beq.s     MemoryTest_79
00002E7C  0C82 0000 5166          cmp.l     #50,D2
00002E80  0032      
00002E82  671A      5167          beq.s     MemoryTest_79
00002E84  0C82 0000 5168          cmp.l     #51,D2
00002E88  0033      
00002E8A  6712      5169          beq.s     MemoryTest_79
00002E8C  0C82 0000 5170          cmp.l     #52,D2
00002E90  0034      
00002E92  670A      5171          beq.s     MemoryTest_79
                    5172   ; printf("\r\nERROR: You have entered a keyboard input that does not associated with an option above, please try again\r\n");
00002E94  4879 0000 5173          pea       @lab6b_147.L
00002E98  5EC2      
00002E9A  4E92      5174          jsr       (A2)
00002E9C  584F      5175          addq.w    #4,A7
                    5176   MemoryTest_79:
00002E9E  0C82 0000 5177          cmp.l     #49,D2
00002EA2  0031      
00002EA4  6718      5178          beq.s     MemoryTest_81
00002EA6  0C82 0000 5179          cmp.l     #50,D2
00002EAA  0032      
00002EAC  6710      5180          beq.s     MemoryTest_81
00002EAE  0C82 0000 5181          cmp.l     #51,D2
00002EB2  0033      
00002EB4  6708      5182          beq.s     MemoryTest_81
00002EB6  0C82 0000 5183          cmp.l     #52,D2
00002EBA  0034      
00002EBC  66B0      5184          bne       MemoryTest_77
                    5185   MemoryTest_81:
                    5186   ; }
                    5187   ; } while (test_data_num != (int)('1') && test_data_num != (int)('2') && test_data_num != (int)('3') && test_data_num != (int)('4'));
                    5188   ; if (test_data_num == (int)('1')) {
00002EBE  0C82 0000 5189          cmp.l     #49,D2
00002EC2  0031      
00002EC4  6608      5190          bne.s     MemoryTest_82
                    5191   ; test_data_long_word = test_data_long_word_list[0];
00002EC6  2C2E FFEE 5192          move.l    -18+0(A6),D6
00002ECA  6000 003A 5193          bra       MemoryTest_89
                    5194   MemoryTest_82:
                    5195   ; }
                    5196   ; else if (test_data_num == (int)('2')) {
00002ECE  0C82 0000 5197          cmp.l     #50,D2
00002ED2  0032      
00002ED4  6606      5198          bne.s     MemoryTest_84
                    5199   ; test_data_long_word = test_data_long_word_list[1];
00002ED6  2C2E FFF2 5200          move.l    -18+4(A6),D6
00002EDA  602A      5201          bra.s     MemoryTest_89
                    5202   MemoryTest_84:
                    5203   ; }
                    5204   ; else if (test_data_num == (int)('3')) {
00002EDC  0C82 0000 5205          cmp.l     #51,D2
00002EE0  0033      
00002EE2  6606      5206          bne.s     MemoryTest_86
                    5207   ; test_data_long_word = test_data_long_word_list[2];
00002EE4  2C2E FFF6 5208          move.l    -18+8(A6),D6
00002EE8  601C      5209          bra.s     MemoryTest_89
                    5210   MemoryTest_86:
                    5211   ; }
                    5212   ; else if (test_data_num == (int)('4')) {
00002EEA  0C82 0000 5213          cmp.l     #52,D2
00002EEE  0034      
00002EF0  6606      5214          bne.s     MemoryTest_88
                    5215   ; test_data_long_word = test_data_long_word_list[3];
00002EF2  2C2E FFFA 5216          move.l    -18+12(A6),D6
00002EF6  600E      5217          bra.s     MemoryTest_89
                    5218   MemoryTest_88:
                    5219   ; }
                    5220   ; else {
                    5221   ; printf("\r\nERROR: Option memory complication. Exiting memory test...\r\n");
00002EF8  4879 0000 5222          pea       @lab6b_148.L
00002EFC  5F30      
00002EFE  4E92      5223          jsr       (A2)
00002F00  584F      5224          addq.w    #4,A7
                    5225   ; return;
00002F02  6000 01E8 5226          bra       MemoryTest_2
                    5227   MemoryTest_89:
                    5228   ; }
                    5229   ; do {
                    5230   MemoryTest_90:
                    5231   ; printf("\r\nPlease enter the start address you would like to use for the test data into memory (Ensure to enter an even number)\r\n");
00002F06  4879 0000 5232          pea       @lab6b_162.L
00002F0A  634E      
00002F0C  4E92      5233          jsr       (A2)
00002F0E  584F      5234          addq.w    #4,A7
                    5235   ; StartPtrLongWord = Get8HexDigits(0);
00002F10  42A7      5236          clr.l     -(A7)
00002F12  4E93      5237          jsr       (A3)
00002F14  584F      5238          addq.w    #4,A7
00002F16  2600      5239          move.l    D0,D3
                    5240   ; while(StartPtrLongWord < (int)(0x09000000) || StartPtrLongWord > (int)(0x09800000)){
                    5241   MemoryTest_92:
00002F18  0C83 0900 5242          cmp.l     #150994944,D3
00002F1C  0000      
00002F1E  6508      5243          blo.s     MemoryTest_95
00002F20  0C83 0980 5244          cmp.l     #159383552,D3
00002F24  0000      
00002F26  6314      5245          bls.s     MemoryTest_94
                    5246   MemoryTest_95:
                    5247   ; printf("\r\nERROR: Starting Address is outside of 68K memory range. Please try again and ensure the address is withn 0x09000000 - 0x097FFFFF\r\n");
00002F28  4879 0000 5248          pea       @lab6b_163.L
00002F2C  63C6      
00002F2E  4E92      5249          jsr       (A2)
00002F30  584F      5250          addq.w    #4,A7
                    5251   ; StartPtrLongWord = Get8HexDigits(0);
00002F32  42A7      5252          clr.l     -(A7)
00002F34  4E93      5253          jsr       (A3)
00002F36  584F      5254          addq.w    #4,A7
00002F38  2600      5255          move.l    D0,D3
00002F3A  60DC      5256          bra       MemoryTest_92
                    5257   MemoryTest_94:
                    5258   ; }
                    5259   ; if (StartPtrLongWord % 2 != 0) {
00002F3C  2F03      5260          move.l    D3,-(A7)
00002F3E  4878 0002 5261          pea       2
00002F42  4EB9 0000 5262          jsr       ULDIV
00002F46  41CC      
00002F48  202F 0004 5263          move.l    4(A7),D0
00002F4C  504F      5264          addq.w    #8,A7
00002F4E  4A80      5265          tst.l     D0
00002F50  670A      5266          beq.s     MemoryTest_96
                    5267   ; printf("\r\nERROR: The address you have entered is not even. Please try again\r\n");
00002F52  4879 0000 5268          pea       @lab6b_164.L
00002F56  644C      
00002F58  4E92      5269          jsr       (A2)
00002F5A  584F      5270          addq.w    #4,A7
                    5271   MemoryTest_96:
00002F5C  2F03      5272          move.l    D3,-(A7)
00002F5E  4878 0002 5273          pea       2
00002F62  4EB9 0000 5274          jsr       ULDIV
00002F66  41CC      
00002F68  202F 0004 5275          move.l    4(A7),D0
00002F6C  504F      5276          addq.w    #8,A7
00002F6E  4A80      5277          tst.l     D0
00002F70  6694      5278          bne       MemoryTest_90
                    5279   ; }
                    5280   ; } while (StartPtrLongWord % 2 != 0);
                    5281   ; do {
                    5282   MemoryTest_98:
                    5283   ; printf("\r\nPlease enter the end address you would like to use for the test data in memory (Ensure to enter an even number)\r\n");
00002F72  4879 0000 5284          pea       @lab6b_165.L
00002F76  6492      
00002F78  4E92      5285          jsr       (A2)
00002F7A  584F      5286          addq.w    #4,A7
                    5287   ; EndPtrLongWord = Get8HexDigits(0);
00002F7C  42A7      5288          clr.l     -(A7)
00002F7E  4E93      5289          jsr       (A3)
00002F80  584F      5290          addq.w    #4,A7
00002F82  2E00      5291          move.l    D0,D7
                    5292   ; while(EndPtrLongWord < (int)(0x09000000) || EndPtrLongWord > (int)(0x09800000)){
                    5293   MemoryTest_100:
00002F84  0C87 0900 5294          cmp.l     #150994944,D7
00002F88  0000      
00002F8A  6508      5295          blo.s     MemoryTest_103
00002F8C  0C87 0980 5296          cmp.l     #159383552,D7
00002F90  0000      
00002F92  6314      5297          bls.s     MemoryTest_102
                    5298   MemoryTest_103:
                    5299   ; printf("\r\nERROR: End Address is outside of 68K memory range. Please try again and ensure the address is withn 0x09000000 - 0x097FFFFF\r\n");
00002F94  4879 0000 5300          pea       @lab6b_166.L
00002F98  6506      
00002F9A  4E92      5301          jsr       (A2)
00002F9C  584F      5302          addq.w    #4,A7
                    5303   ; EndPtrLongWord = Get8HexDigits(0);
00002F9E  42A7      5304          clr.l     -(A7)
00002FA0  4E93      5305          jsr       (A3)
00002FA2  584F      5306          addq.w    #4,A7
00002FA4  2E00      5307          move.l    D0,D7
00002FA6  60DC      5308          bra       MemoryTest_100
                    5309   MemoryTest_102:
                    5310   ; }
                    5311   ; if (EndPtrLongWord % 2 != 0) {
00002FA8  2F07      5312          move.l    D7,-(A7)
00002FAA  4878 0002 5313          pea       2
00002FAE  4EB9 0000 5314          jsr       ULDIV
00002FB2  41CC      
00002FB4  202F 0004 5315          move.l    4(A7),D0
00002FB8  504F      5316          addq.w    #8,A7
00002FBA  4A80      5317          tst.l     D0
00002FBC  670A      5318          beq.s     MemoryTest_104
                    5319   ; printf("\r\nERROR: The address you have entered is not even. Please try again\r\n");
00002FBE  4879 0000 5320          pea       @lab6b_164.L
00002FC2  644C      
00002FC4  4E92      5321          jsr       (A2)
00002FC6  584F      5322          addq.w    #4,A7
                    5323   MemoryTest_104:
00002FC8  2F07      5324          move.l    D7,-(A7)
00002FCA  4878 0002 5325          pea       2
00002FCE  4EB9 0000 5326          jsr       ULDIV
00002FD2  41CC      
00002FD4  202F 0004 5327          move.l    4(A7),D0
00002FD8  504F      5328          addq.w    #8,A7
00002FDA  4A80      5329          tst.l     D0
00002FDC  6694      5330          bne       MemoryTest_98
                    5331   ; }
                    5332   ; } while (EndPtrLongWord % 2 != 0);
                    5333   ; printf("\r\n\r\nWriting to memory");
00002FDE  4879 0000 5334          pea       @lab6b_153.L
00002FE2  6120      
00002FE4  4E92      5335          jsr       (A2)
00002FE6  584F      5336          addq.w    #4,A7
                    5337   ; StartPtrLongWordTruc = StartPtrLongWord;
00002FE8  2D43 FFD0 5338          move.l    D3,-48(A6)
                    5339   ; EndPtrLongWordTruc = EndPtrLongWord;
00002FEC  2D47 FFD4 5340          move.l    D7,-44(A6)
                    5341   ; TempPtrLongWord = StartPtrLongWord;
00002FF0  2D43 FFCC 5342          move.l    D3,-52(A6)
                    5343   ; if((EndPtrLongWordTruc-StartPtrLongWordTruc) % 0x4 != 0){
00002FF4  202E FFD4 5344          move.l    -44(A6),D0
00002FF8  90AE FFD0 5345          sub.l     -48(A6),D0
00002FFC  2F00      5346          move.l    D0,-(A7)
00002FFE  4878 0004 5347          pea       4
00003002  4EB9 0000 5348          jsr       LDIV
00003006  41DE      
00003008  202F 0004 5349          move.l    4(A7),D0
0000300C  504F      5350          addq.w    #8,A7
0000300E  4A80      5351          tst.l     D0
00003010  670E      5352          beq.s     MemoryTest_106
                    5353   ; printf("\r\nWARNING: Memory will contain truncated data"); 
00003012  4879 0000 5354          pea       @lab6b_171.L
00003016  66A8      
00003018  4E92      5355          jsr       (A2)
0000301A  584F      5356          addq.w    #4,A7
                    5357   ; truncated_data = test_data_long_word;   
0000301C  3D46 FFFE 5358          move.w    D6,-2(A6)
                    5359   MemoryTest_106:
                    5360   ; }
                    5361   ; while (StartPtrLongWord < EndPtrLongWord) {
                    5362   MemoryTest_108:
00003020  B687      5363          cmp.l     D7,D3
00003022  6400 0050 5364          bhs       MemoryTest_110
                    5365   ; if(EndPtrLongWordTruc - StartPtrLongWordTruc < 4){
00003026  202E FFD4 5366          move.l    -44(A6),D0
0000302A  90AE FFD0 5367          sub.l     -48(A6),D0
0000302E  0C80 0000 5368          cmp.l     #4,D0
00003032  0004      
00003034  6C22      5369          bge.s     MemoryTest_111
                    5370   ; StartPtrWord = StartPtrLongWord;
00003036  2803      5371          move.l    D3,D4
                    5372   ; *StartPtrWord = test_data_long_word;
00003038  2044      5373          move.l    D4,A0
0000303A  3086      5374          move.w    D6,(A0)
                    5375   ; printf("\r\nWRITE: [%08X to %08x]", *StartPtrWord, StartPtrWord);
0000303C  2F04      5376          move.l    D4,-(A7)
0000303E  2044      5377          move.l    D4,A0
00003040  3210      5378          move.w    (A0),D1
00003042  C2BC 0000 5379          and.l     #65535,D1
00003046  FFFF      
00003048  2F01      5380          move.l    D1,-(A7)
0000304A  4879 0000 5381          pea       @lab6b_172.L
0000304E  66D6      
00003050  4E92      5382          jsr       (A2)
00003052  DEFC 000C 5383          add.w     #12,A7
00003056  6014      5384          bra.s     MemoryTest_112
                    5385   MemoryTest_111:
                    5386   ; }else{
                    5387   ; *StartPtrLongWord = test_data_long_word;
00003058  2043      5388          move.l    D3,A0
0000305A  2086      5389          move.l    D6,(A0)
                    5390   ; printf("\r\nWRITE: [%08X to %08x]", test_data_long_word, StartPtrLongWord);
0000305C  2F03      5391          move.l    D3,-(A7)
0000305E  2F06      5392          move.l    D6,-(A7)
00003060  4879 0000 5393          pea       @lab6b_172.L
00003064  66D6      
00003066  4E92      5394          jsr       (A2)
00003068  DEFC 000C 5395          add.w     #12,A7
                    5396   MemoryTest_112:
                    5397   ; }
                    5398   ; StartPtrLongWord++;
0000306C  5883      5399          addq.l    #4,D3
                    5400   ; StartPtrLongWordTruc = StartPtrLongWord;
0000306E  2D43 FFD0 5401          move.l    D3,-48(A6)
00003072  60AC      5402          bra       MemoryTest_108
                    5403   MemoryTest_110:
                    5404   ; }
                    5405   ; printf("\r\n\r\nStarting memory validation test");
00003074  4879 0000 5406          pea       @lab6b_155.L
00003078  614E      
0000307A  4E92      5407          jsr       (A2)
0000307C  584F      5408          addq.w    #4,A7
                    5409   ; StartPtrLongWord = TempPtrLongWord;
0000307E  262E FFCC 5410          move.l    -52(A6),D3
                    5411   ; truncated_data = test_data_long_word;
00003082  3D46 FFFE 5412          move.w    D6,-2(A6)
                    5413   ; printf("\r\nVerifying the addresses [%08x to %08x] contains test data [%02X].....", StartPtrLongWord, EndPtrLongWord, test_data_long_word);
00003086  2F06      5414          move.l    D6,-(A7)
00003088  2F07      5415          move.l    D7,-(A7)
0000308A  2F03      5416          move.l    D3,-(A7)
0000308C  4879 0000 5417          pea       @lab6b_156.L
00003090  6172      
00003092  4E92      5418          jsr       (A2)
00003094  DEFC 0010 5419          add.w     #16,A7
                    5420   ; while (StartPtrLongWord < EndPtrLongWord) {
                    5421   MemoryTest_113:
00003098  B687      5422          cmp.l     D7,D3
0000309A  6400 003A 5423          bhs       MemoryTest_115
                    5424   ; if(EndPtrLongWordTruc - StartPtrLongWordTruc < 4){
0000309E  202E FFD4 5425          move.l    -44(A6),D0
000030A2  90AE FFD0 5426          sub.l     -48(A6),D0
000030A6  0C80 0000 5427          cmp.l     #4,D0
000030AA  0004      
000030AC  6C04      5428          bge.s     MemoryTest_116
                    5429   ; StartPtrWord = StartPtrLongWord;
000030AE  2803      5430          move.l    D3,D4
000030B0  601C      5431          bra.s     MemoryTest_118
                    5432   MemoryTest_116:
                    5433   ; }else{
                    5434   ; if (*StartPtrLongWord != test_data_long_word) {
000030B2  2043      5435          move.l    D3,A0
000030B4  BC90      5436          cmp.l     (A0),D6
000030B6  6716      5437          beq.s     MemoryTest_118
                    5438   ; printf("\r\nERROR: Data within memory does not match selected test data! [Address: %08x Exact Data: %08X Expected Data: %08X] Exiting memory test...\r\n", StartPtrLongWord, *StartPtrLongWord, test_data_long_word);
000030B8  2F06      5439          move.l    D6,-(A7)
000030BA  2043      5440          move.l    D3,A0
000030BC  2F10      5441          move.l    (A0),-(A7)
000030BE  2F03      5442          move.l    D3,-(A7)
000030C0  4879 0000 5443          pea       @lab6b_173.L
000030C4  66EE      
000030C6  4E92      5444          jsr       (A2)
000030C8  DEFC 0010 5445          add.w     #16,A7
                    5446   ; return;
000030CC  601E      5447          bra.s     MemoryTest_2
                    5448   MemoryTest_118:
                    5449   ; }
                    5450   ; }
                    5451   ; StartPtrLongWord++;
000030CE  5883      5452          addq.l    #4,D3
                    5453   ; StartPtrLongWordTruc = StartPtrLongWord;
000030D0  2D43 FFD0 5454          move.l    D3,-48(A6)
000030D4  60C2      5455          bra       MemoryTest_113
                    5456   MemoryTest_115:
                    5457   ; }
                    5458   ; printf("\r\nPASS: Memory Validation test has passed!\r\n");
000030D6  4879 0000 5459          pea       @lab6b_158.L
000030DA  6248      
000030DC  4E92      5460          jsr       (A2)
000030DE  584F      5461          addq.w    #4,A7
                    5462   ; break;
000030E0  600A      5463          bra.s     MemoryTest_2
                    5464   MemoryTest_1:
                    5465   ; default:
                    5466   ; printf("\r\nYou failed to select a data type to use! Click open memory test again to try again.\r\n");
000030E2  4879 0000 5467          pea       @lab6b_174.L
000030E6  677C      
000030E8  4E92      5468          jsr       (A2)
000030EA  584F      5469          addq.w    #4,A7
                    5470   MemoryTest_2:
000030EC  4CDF 3CFC 5471          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
000030F0  4E5E      5472          unlk      A6
000030F2  4E75      5473          rts
                    5474   ; }   
                    5475   ; }
                    5476   ; void WriteI2C(void){
                    5477   _WriteI2C:
000030F4  48E7 3C20 5478          movem.l   D2/D3/D4/D5/A2,-(A7)
000030F8  45F9 0000 5479          lea       _printf.L,A2
000030FC  43B8      
                    5480   ; unsigned int Address;
                    5481   ; unsigned char AddressLSB;
                    5482   ; unsigned char AddressMSB;
                    5483   ; unsigned char c;
                    5484   ; printf("\r\nI2C Write:");
000030FE  4879 0000 5485          pea       @lab6b_175.L
00003102  67D4      
00003104  4E92      5486          jsr       (A2)
00003106  584F      5487          addq.w    #4,A7
                    5488   ; printf("\r\nEnter Address: ");
00003108  4879 0000 5489          pea       @lab6b_19.L
0000310C  4ED2      
0000310E  4E92      5490          jsr       (A2)
00003110  584F      5491          addq.w    #4,A7
                    5492   ; Address = Get8HexDigits(0);
00003112  42A7      5493          clr.l     -(A7)
00003114  4EB8 0CA4 5494          jsr       _Get8HexDigits
00003118  584F      5495          addq.w    #4,A7
0000311A  2400      5496          move.l    D0,D2
                    5497   ; if(Address > 0x1FFFF ){ //Chip is 128kB therefore can not be greater
0000311C  0C82 0001 5498          cmp.l     #131071,D2
00003120  FFFF      
00003122  630E      5499          bls.s     WriteI2C_1
                    5500   ; printf("\r\nEntered Address is invalid, please enter a smaller valued address. Returning back to the debug monitor menu");
00003124  4879 0000 5501          pea       @lab6b_176.L
00003128  67E2      
0000312A  4E92      5502          jsr       (A2)
0000312C  584F      5503          addq.w    #4,A7
                    5504   ; return;
0000312E  6000 00AE 5505          bra       WriteI2C_3
                    5506   WriteI2C_1:
                    5507   ; } 
                    5508   ; printf("\r\nEnter Data: ");
00003132  4879 0000 5509          pea       @lab6b_177.L
00003136  6850      
00003138  4E92      5510          jsr       (A2)
0000313A  584F      5511          addq.w    #4,A7
                    5512   ; c = Get2HexDigits(0);
0000313C  42A7      5513          clr.l     -(A7)
0000313E  4EB8 0C04 5514          jsr       _Get2HexDigits
00003142  584F      5515          addq.w    #4,A7
00003144  1A00      5516          move.b    D0,D5
                    5517   ; if(Address > 0xFFFF){ //Chip is consisted of 2 x 64kB blocks which is the high and low block
00003146  0C82 0000 5518          cmp.l     #65535,D2
0000314A  FFFF      
0000314C  6300 0052 5519          bls       WriteI2C_4
                    5520   ; //Adjusting address values to high block and onwards
                    5521   ; AddressMSB = ((Address - 0x10000) >> 8) & 0xFF;
00003150  2002      5522          move.l    D2,D0
00003152  0480 0001 5523          sub.l     #65536,D0
00003156  0000      
00003158  E088      5524          lsr.l     #8,D0
0000315A  C0BC 0000 5525          and.l     #255,D0
0000315E  00FF      
00003160  1800      5526          move.b    D0,D4
                    5527   ; AddressLSB = (Address - 0x10000) & 0xFF;    
00003162  2002      5528          move.l    D2,D0
00003164  0480 0001 5529          sub.l     #65536,D0
00003168  0000      
0000316A  C0BC 0000 5530          and.l     #255,D0
0000316E  00FF      
00003170  1600      5531          move.b    D0,D3
                    5532   ; WriteI2CInteraction(1, Address, AddressMSB, AddressLSB, c, 0);
00003172  42A7      5533          clr.l     -(A7)
00003174  CABC 0000 5534          and.l     #255,D5
00003178  00FF      
0000317A  2F05      5535          move.l    D5,-(A7)
0000317C  C6BC 0000 5536          and.l     #255,D3
00003180  00FF      
00003182  2F03      5537          move.l    D3,-(A7)
00003184  C8BC 0000 5538          and.l     #255,D4
00003188  00FF      
0000318A  2F04      5539          move.l    D4,-(A7)
0000318C  2F02      5540          move.l    D2,-(A7)
0000318E  4878 0001 5541          pea       1
00003192  4EB9 0000 5542          jsr       _WriteI2CInteraction
00003196  36FC      
00003198  DEFC 0018 5543          add.w     #24,A7
0000319C  6000 0040 5544          bra       WriteI2C_5
                    5545   WriteI2C_4:
                    5546   ; }else{
                    5547   ; AddressMSB = (Address >> 8) & 0xFF;
000031A0  2002      5548          move.l    D2,D0
000031A2  E088      5549          lsr.l     #8,D0
000031A4  C0BC 0000 5550          and.l     #255,D0
000031A8  00FF      
000031AA  1800      5551          move.b    D0,D4
                    5552   ; AddressLSB = Address & 0xFF;
000031AC  2002      5553          move.l    D2,D0
000031AE  C0BC 0000 5554          and.l     #255,D0
000031B2  00FF      
000031B4  1600      5555          move.b    D0,D3
                    5556   ; WriteI2CInteraction(0, Address, AddressMSB, AddressLSB, c, 0);
000031B6  42A7      5557          clr.l     -(A7)
000031B8  CABC 0000 5558          and.l     #255,D5
000031BC  00FF      
000031BE  2F05      5559          move.l    D5,-(A7)
000031C0  C6BC 0000 5560          and.l     #255,D3
000031C4  00FF      
000031C6  2F03      5561          move.l    D3,-(A7)
000031C8  C8BC 0000 5562          and.l     #255,D4
000031CC  00FF      
000031CE  2F04      5563          move.l    D4,-(A7)
000031D0  2F02      5564          move.l    D2,-(A7)
000031D2  42A7      5565          clr.l     -(A7)
000031D4  4EB9 0000 5566          jsr       _WriteI2CInteraction
000031D8  36FC      
000031DA  DEFC 0018 5567          add.w     #24,A7
                    5568   WriteI2C_5:
                    5569   ; }
                    5570   ; return;
                    5571   WriteI2C_3:
000031DE  4CDF 043C 5572          movem.l   (A7)+,D2/D3/D4/D5/A2
000031E2  4E75      5573          rts
                    5574   ; }
                    5575   ; void ReadI2C(void){
                    5576   _ReadI2C:
000031E4  48E7 3820 5577          movem.l   D2/D3/D4/A2,-(A7)
000031E8  45F9 0000 5578          lea       _printf.L,A2
000031EC  43B8      
                    5579   ; unsigned int Address;
                    5580   ; unsigned char AddressLSB;
                    5581   ; unsigned char AddressMSB;
                    5582   ; printf("\r\nI2C Read:");
000031EE  4879 0000 5583          pea       @lab6b_178.L
000031F2  6860      
000031F4  4E92      5584          jsr       (A2)
000031F6  584F      5585          addq.w    #4,A7
                    5586   ; printf("\r\nEnter Address: ");
000031F8  4879 0000 5587          pea       @lab6b_19.L
000031FC  4ED2      
000031FE  4E92      5588          jsr       (A2)
00003200  584F      5589          addq.w    #4,A7
                    5590   ; Address = Get8HexDigits(0);
00003202  42A7      5591          clr.l     -(A7)
00003204  4EB8 0CA4 5592          jsr       _Get8HexDigits
00003208  584F      5593          addq.w    #4,A7
0000320A  2400      5594          move.l    D0,D2
                    5595   ; if(Address > 0x1FFFF){ //Chip is 128kB therefore can not be greater
0000320C  0C82 0001 5596          cmp.l     #131071,D2
00003210  FFFF      
00003212  630E      5597          bls.s     ReadI2C_1
                    5598   ; printf("\r\nEntered Address is invalid, please enter a smaller valued address. Returning back to the debug monitor menu");
00003214  4879 0000 5599          pea       @lab6b_176.L
00003218  67E2      
0000321A  4E92      5600          jsr       (A2)
0000321C  584F      5601          addq.w    #4,A7
                    5602   ; return;
0000321E  6000 0084 5603          bra       ReadI2C_3
                    5604   ReadI2C_1:
                    5605   ; } 
                    5606   ; if(Address > 0xFFFF){ //Chip is consisted of 2 x 64kB blocks which is the high and low block
00003222  0C82 0000 5607          cmp.l     #65535,D2
00003226  FFFF      
00003228  6300 0046 5608          bls       ReadI2C_4
                    5609   ; //Adjusting address values to high block and onwards
                    5610   ; AddressMSB = ((Address - 0x10000) >> 8) & 0xFF;
0000322C  2002      5611          move.l    D2,D0
0000322E  0480 0001 5612          sub.l     #65536,D0
00003232  0000      
00003234  E088      5613          lsr.l     #8,D0
00003236  C0BC 0000 5614          and.l     #255,D0
0000323A  00FF      
0000323C  1800      5615          move.b    D0,D4
                    5616   ; AddressLSB = (Address - 0x10000) & 0xFF;    
0000323E  2002      5617          move.l    D2,D0
00003240  0480 0001 5618          sub.l     #65536,D0
00003244  0000      
00003246  C0BC 0000 5619          and.l     #255,D0
0000324A  00FF      
0000324C  1600      5620          move.b    D0,D3
                    5621   ; ReadI2CByteInteraction(1, Address, AddressMSB, AddressLSB);
0000324E  C6BC 0000 5622          and.l     #255,D3
00003252  00FF      
00003254  2F03      5623          move.l    D3,-(A7)
00003256  C8BC 0000 5624          and.l     #255,D4
0000325A  00FF      
0000325C  2F04      5625          move.l    D4,-(A7)
0000325E  2F02      5626          move.l    D2,-(A7)
00003260  4878 0001 5627          pea       1
00003264  4EB9 0000 5628          jsr       _ReadI2CByteInteraction
00003268  3A4E      
0000326A  DEFC 0010 5629          add.w     #16,A7
0000326E  6034      5630          bra.s     ReadI2C_5
                    5631   ReadI2C_4:
                    5632   ; }else{
                    5633   ; AddressMSB = (Address >> 8) & 0xFF;
00003270  2002      5634          move.l    D2,D0
00003272  E088      5635          lsr.l     #8,D0
00003274  C0BC 0000 5636          and.l     #255,D0
00003278  00FF      
0000327A  1800      5637          move.b    D0,D4
                    5638   ; AddressLSB = Address & 0xFF;
0000327C  2002      5639          move.l    D2,D0
0000327E  C0BC 0000 5640          and.l     #255,D0
00003282  00FF      
00003284  1600      5641          move.b    D0,D3
                    5642   ; ReadI2CByteInteraction(0, Address, AddressMSB, AddressLSB);
00003286  C6BC 0000 5643          and.l     #255,D3
0000328A  00FF      
0000328C  2F03      5644          move.l    D3,-(A7)
0000328E  C8BC 0000 5645          and.l     #255,D4
00003292  00FF      
00003294  2F04      5646          move.l    D4,-(A7)
00003296  2F02      5647          move.l    D2,-(A7)
00003298  42A7      5648          clr.l     -(A7)
0000329A  4EB9 0000 5649          jsr       _ReadI2CByteInteraction
0000329E  3A4E      
000032A0  DEFC 0010 5650          add.w     #16,A7
                    5651   ReadI2C_5:
                    5652   ; }
                    5653   ; return;
                    5654   ReadI2C_3:
000032A4  4CDF 041C 5655          movem.l   (A7)+,D2/D3/D4/A2
000032A8  4E75      5656          rts
                    5657   ; }
                    5658   ; void PageWriteI2C(void){
                    5659   _PageWriteI2C:
000032AA  4E56 FFFC 5660          link      A6,#-4
000032AE  48E7 3020 5661          movem.l   D2/D3/A2,-(A7)
000032B2  45F9 0000 5662          lea       _printf.L,A2
000032B6  43B8      
                    5663   ; unsigned int AddressFrom;
                    5664   ; unsigned int AddressTo;
                    5665   ; unsigned char c;
                    5666   ; printf("\r\nI2C Page Write:");
000032B8  4879 0000 5667          pea       @lab6b_179.L
000032BC  686C      
000032BE  4E92      5668          jsr       (A2)
000032C0  584F      5669          addq.w    #4,A7
                    5670   ; printf("\r\nEnter Address From: ");
000032C2  4879 0000 5671          pea       @lab6b_180.L
000032C6  687E      
000032C8  4E92      5672          jsr       (A2)
000032CA  584F      5673          addq.w    #4,A7
                    5674   ; AddressFrom = Get8HexDigits(0);
000032CC  42A7      5675          clr.l     -(A7)
000032CE  4EB8 0CA4 5676          jsr       _Get8HexDigits
000032D2  584F      5677          addq.w    #4,A7
000032D4  2600      5678          move.l    D0,D3
                    5679   ; if(AddressFrom > 0x1FFFF ){ //Chip is 128kB therefore can not be greater
000032D6  0C83 0001 5680          cmp.l     #131071,D3
000032DA  FFFF      
000032DC  630E      5681          bls.s     PageWriteI2C_1
                    5682   ; printf("\r\nEntered Address is invalid, please enter a smaller valued address. Returning back to the debug monitor menu");
000032DE  4879 0000 5683          pea       @lab6b_176.L
000032E2  67E2      
000032E4  4E92      5684          jsr       (A2)
000032E6  584F      5685          addq.w    #4,A7
                    5686   ; return;
000032E8  6000 005A 5687          bra       PageWriteI2C_3
                    5688   PageWriteI2C_1:
                    5689   ; } 
                    5690   ; printf("\r\nEnter Address To: ");
000032EC  4879 0000 5691          pea       @lab6b_181.L
000032F0  6896      
000032F2  4E92      5692          jsr       (A2)
000032F4  584F      5693          addq.w    #4,A7
                    5694   ; AddressTo = Get8HexDigits(0);
000032F6  42A7      5695          clr.l     -(A7)
000032F8  4EB8 0CA4 5696          jsr       _Get8HexDigits
000032FC  584F      5697          addq.w    #4,A7
000032FE  2400      5698          move.l    D0,D2
                    5699   ; if(AddressTo > 0x1FFFF ){ //Chip is 128kB therefore can not be greater
00003300  0C82 0001 5700          cmp.l     #131071,D2
00003304  FFFF      
00003306  630C      5701          bls.s     PageWriteI2C_4
                    5702   ; printf("\r\nEntered Address is invalid, please enter a smaller valued address. Returning back to the debug monitor menu");
00003308  4879 0000 5703          pea       @lab6b_176.L
0000330C  67E2      
0000330E  4E92      5704          jsr       (A2)
00003310  584F      5705          addq.w    #4,A7
                    5706   ; return;
00003312  6030      5707          bra.s     PageWriteI2C_3
                    5708   PageWriteI2C_4:
                    5709   ; } 
                    5710   ; printf("\r\nEnter Data: ");
00003314  4879 0000 5711          pea       @lab6b_177.L
00003318  6850      
0000331A  4E92      5712          jsr       (A2)
0000331C  584F      5713          addq.w    #4,A7
                    5714   ; c = Get2HexDigits(0);
0000331E  42A7      5715          clr.l     -(A7)
00003320  4EB8 0C04 5716          jsr       _Get2HexDigits
00003324  584F      5717          addq.w    #4,A7
00003326  1D40 FFFF 5718          move.b    D0,-1(A6)
                    5719   ; PageWriteI2CInteraction(AddressFrom, AddressTo, c);
0000332A  122E FFFF 5720          move.b    -1(A6),D1
0000332E  C2BC 0000 5721          and.l     #255,D1
00003332  00FF      
00003334  2F01      5722          move.l    D1,-(A7)
00003336  2F02      5723          move.l    D2,-(A7)
00003338  2F03      5724          move.l    D3,-(A7)
0000333A  4EB9 0000 5725          jsr       _PageWriteI2CInteraction
0000333E  37A0      
00003340  DEFC 000C 5726          add.w     #12,A7
                    5727   ; return;
                    5728   PageWriteI2C_3:
00003344  4CDF 040C 5729          movem.l   (A7)+,D2/D3/A2
00003348  4E5E      5730          unlk      A6
0000334A  4E75      5731          rts
                    5732   ; }
                    5733   ; void SeqReadI2C(void){
                    5734   _SeqReadI2C:
0000334C  48E7 3020 5735          movem.l   D2/D3/A2,-(A7)
00003350  45F9 0000 5736          lea       _printf.L,A2
00003354  43B8      
                    5737   ; int AddressFrom;
                    5738   ; int AddressTo;
                    5739   ; printf("\r\nI2C Seq Read:");
00003356  4879 0000 5740          pea       @lab6b_182.L
0000335A  68AC      
0000335C  4E92      5741          jsr       (A2)
0000335E  584F      5742          addq.w    #4,A7
                    5743   ; printf("\r\nEnter Address From: ");
00003360  4879 0000 5744          pea       @lab6b_180.L
00003364  687E      
00003366  4E92      5745          jsr       (A2)
00003368  584F      5746          addq.w    #4,A7
                    5747   ; AddressFrom = Get8HexDigits(0);
0000336A  42A7      5748          clr.l     -(A7)
0000336C  4EB8 0CA4 5749          jsr       _Get8HexDigits
00003370  584F      5750          addq.w    #4,A7
00003372  2400      5751          move.l    D0,D2
                    5752   ; if(AddressFrom > 0x1FFFF){ //Chip is 128kB therefore can not be greater
00003374  0C82 0001 5753          cmp.l     #131071,D2
00003378  FFFF      
0000337A  6F0E      5754          ble.s     SeqReadI2C_1
                    5755   ; printf("\r\nEntered Address is invalid, please enter a smaller valued address. Returning back to the debug monitor menu");
0000337C  4879 0000 5756          pea       @lab6b_176.L
00003380  67E2      
00003382  4E92      5757          jsr       (A2)
00003384  584F      5758          addq.w    #4,A7
                    5759   ; return;
00003386  6000 005A 5760          bra       SeqReadI2C_3
                    5761   SeqReadI2C_1:
                    5762   ; } 
                    5763   ; printf("\r\nEnter Address To: ");
0000338A  4879 0000 5764          pea       @lab6b_181.L
0000338E  6896      
00003390  4E92      5765          jsr       (A2)
00003392  584F      5766          addq.w    #4,A7
                    5767   ; AddressTo = Get8HexDigits(0);
00003394  42A7      5768          clr.l     -(A7)
00003396  4EB8 0CA4 5769          jsr       _Get8HexDigits
0000339A  584F      5770          addq.w    #4,A7
0000339C  2600      5771          move.l    D0,D3
                    5772   ; if(AddressTo > 0x1FFFF){ //Chip is 128kB therefore can not be greater
0000339E  0C83 0001 5773          cmp.l     #131071,D3
000033A2  FFFF      
000033A4  6F0C      5774          ble.s     SeqReadI2C_4
                    5775   ; printf("\r\nEntered Address is invalid, please enter a smaller valued address. Returning back to the debug monitor menu");
000033A6  4879 0000 5776          pea       @lab6b_176.L
000033AA  67E2      
000033AC  4E92      5777          jsr       (A2)
000033AE  584F      5778          addq.w    #4,A7
                    5779   ; return;
000033B0  6030      5780          bra.s     SeqReadI2C_3
                    5781   SeqReadI2C_4:
                    5782   ; } 
                    5783   ; if(AddressFrom > 0xFFFF){ //Chip is consisted of 2 x 64kB blocks which is the high and low block
000033B2  0C82 0000 5784          cmp.l     #65535,D2
000033B6  FFFF      
000033B8  6316      5785          bls.s     SeqReadI2C_6
                    5786   ; ReadI2CSequential(1, AddressTo, AddressFrom, AddressFrom);
000033BA  2F02      5787          move.l    D2,-(A7)
000033BC  2F02      5788          move.l    D2,-(A7)
000033BE  2F03      5789          move.l    D3,-(A7)
000033C0  4878 0001 5790          pea       1
000033C4  4EB9 0000 5791          jsr       _ReadI2CSequential
000033C8  3B1C      
000033CA  DEFC 0010 5792          add.w     #16,A7
000033CE  6012      5793          bra.s     SeqReadI2C_7
                    5794   SeqReadI2C_6:
                    5795   ; }
                    5796   ; else{
                    5797   ; ReadI2CSequential(0, AddressTo, AddressFrom, AddressFrom);
000033D0  2F02      5798          move.l    D2,-(A7)
000033D2  2F02      5799          move.l    D2,-(A7)
000033D4  2F03      5800          move.l    D3,-(A7)
000033D6  42A7      5801          clr.l     -(A7)
000033D8  4EB9 0000 5802          jsr       _ReadI2CSequential
000033DC  3B1C      
000033DE  DEFC 0010 5803          add.w     #16,A7
                    5804   SeqReadI2C_7:
                    5805   ; }
                    5806   ; return;
                    5807   SeqReadI2C_3:
000033E2  4CDF 040C 5808          movem.l   (A7)+,D2/D3/A2
000033E6  4E75      5809          rts
                    5810   ; }
                    5811   ; // initialisation for Can controller 0
                    5812   ; // void Init_CanBus_Controller0(void)
                    5813   ; // {
                    5814   ; //     // TODO - put your Canbus initialisation code for CanController 0 here
                    5815   ; //     // See section 4.2.1 in the application note for details (PELICAN MODE)
                    5816   ; //     /* define interrupt priority & control (level-activated, see chapter 4.2.5) */
                    5817   ; //     // PX0 = PRIORITY_HIGH; /* CAN HAS A HIGH PRIORITY INTERRUPT */
                    5818   ; //     // IT0 = INTLEVELACT; /* set interrupt0 to level activated */
                    5819   ; //     // /* enable the communication interface of the SJA1000 */
                    5820   ; //     // CS = ENABLE_N; /* Enable the SJA1000 interface */
                    5821   ; //     // /* disable interrupts, if used (not necessary after power-on) */
                    5822   ; //     // EA = DISABLE; /* disable all interrupts */
                    5823   ; //     // SJAIntEn = DISABLE; /* disable external interrupt from SJA1000 */
                    5824   ; //     // /* set reset mode/request (Note: after power-on SJA1000 is in BasicCAN mode)
                    5825   ; //     // leave loop after a time out and signal an error */
                    5826   ; //     while ((Can0_ModeControlReg & RM_RR_Bit) == ClrByte){
                    5827   ; //     /* other bits than the reset mode/request bit are unchanged */
                    5828   ; //         Can0_ModeControlReg = Can0_ModeControlReg | RM_RR_Bit;
                    5829   ; //     }
                    5830   ; //     // Set clock divide register to use pelican mode and bypass CAN input comparator (possible only in reset mode)
                    5831   ; //     Can0_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
                    5832   ; //     /* disable CAN interrupts, if required (always necessary after power-on)
                    5833   ; //     (write to SJA1000 Interrupt Enable / Control Register) */
                    5834   ; //     Can0_InterruptEnReg = ClrIntEnSJA;
                    5835   ; //     /* define acceptance code and mask */
                    5836   ; //     Can0_AcceptCode0Reg = ClrByte;
                    5837   ; //     Can0_AcceptCode1Reg = ClrByte;
                    5838   ; //     Can0_AcceptCode2Reg = ClrByte;
                    5839   ; //     Can0_AcceptCode3Reg = ClrByte;
                    5840   ; //     Can0_AcceptMask0Reg = DontCare; /* every identifier is accepted */
                    5841   ; //     Can0_AcceptMask1Reg = DontCare; /* every identifier is accepted */
                    5842   ; //     Can0_AcceptMask2Reg = DontCare; /* every identifier is accepted */
                    5843   ; //     Can0_AcceptMask3Reg = DontCare; /* every identifier is accepted */
                    5844   ; //     /* configure bus timing */
                    5845   ; //     /* bit-rate = 100 kbit/s @ 25 MHz, the bus is sampled once */
                    5846   ; //     Can0_BusTiming0Reg = BTR0;
                    5847   ; //     Can0_BusTiming1Reg = BTR1;
                    5848   ; //     /* configure CAN outputs: float on TX1, Push/Pull on TX0, normal output mode */
                    5849   ; //     Can0_OutControlReg = Tx0Float | Tx0PshPull | NormalMode;
                    5850   ; //     // Set mode control to clr
                    5851   ; //     do {
                    5852   ; //         Can0_ModeControlReg = ClrByte;
                    5853   ; //     } while ((Can0_ModeControlReg & RM_RR_Bit) != ClrByte);
                    5854   ; // }
                    5855   ; // // initialisation for Can controller 1
                    5856   ; // void Init_CanBus_Controller1(void)
                    5857   ; // {
                    5858   ; //     // TODO - put your Canbus initialisation code for CanController 1 here
                    5859   ; //     // See section 4.2.1 in the application note for details (PELICAN MODE)
                    5860   ; //     while ((Can1_ModeControlReg & RM_RR_Bit) == ClrByte){
                    5861   ; //     /* other bits than the reset mode/request bit are unchanged */
                    5862   ; //         Can1_ModeControlReg = Can1_ModeControlReg | RM_RR_Bit;
                    5863   ; //     }
                    5864   ; //     // Set clock divide register to use pelican mode and bypass CAN input comparator (possible only in reset mode)
                    5865   ; //     Can1_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
                    5866   ; //     /* disable CAN interrupts, if required (always necessary after power-on)
                    5867   ; //     (write to SJA1000 Interrupt Enable / Control Register) */
                    5868   ; //     Can1_InterruptEnReg = ClrIntEnSJA;
                    5869   ; //     /* define acceptance code and mask */
                    5870   ; //     Can1_AcceptCode0Reg = ClrByte;
                    5871   ; //     Can1_AcceptCode1Reg = ClrByte;
                    5872   ; //     Can1_AcceptCode2Reg = ClrByte;
                    5873   ; //     Can1_AcceptCode3Reg = ClrByte;
                    5874   ; //     Can1_AcceptMask0Reg = DontCare; /* every identifier is accepted */
                    5875   ; //     Can1_AcceptMask1Reg = DontCare; /* every identifier is accepted */
                    5876   ; //     Can1_AcceptMask2Reg = DontCare; /* every identifier is accepted */
                    5877   ; //     Can1_AcceptMask3Reg = DontCare; /* every identifier is accepted */
                    5878   ; //     /* configure bus timing */
                    5879   ; //     /* bit-rate = 100 kbit/s @ 25 MHz, the bus is sampled once */
                    5880   ; //     Can1_BusTiming0Reg = BTR0;
                    5881   ; //     Can1_BusTiming1Reg = BTR1;
                    5882   ; //     /* configure CAN outputs: float on TX1, Push/Pull on TX0, normal output mode */
                    5883   ; //     Can1_OutControlReg = Tx0Float | Tx0PshPull | NormalMode;
                    5884   ; //     // Set mode control to clr
                    5885   ; //     do {
                    5886   ; //         Can1_ModeControlReg = ClrByte;
                    5887   ; //     } while ((Can1_ModeControlReg & RM_RR_Bit) != ClrByte);
                    5888   ; // }
                    5889   ; // // Transmit for sending a message via Can controller 0
                    5890   ; // void CanBus0_Transmit(void)
                    5891   ; // {
                    5892   ; //     // TODO - put your Canbus transmit code for CanController 0 here
                    5893   ; //     // See section 4.2.2 in the application note for details (PELICAN MODE)
                    5894   ; //     /* wait until the Transmit Buffer is released */
                    5895   ; //     do
                    5896   ; //     {
                    5897   ; //     /* start a polling timer and run some tasks while waiting
                    5898   ; //     break the loop and signal an error if time too long */
                    5899   ; //     } while((Can0_StatusReg & TBS_Bit ) != TBS_Bit );
                    5900   ; //     /* Transmit Buffer is released, a message may be written into the buffer */
                    5901   ; //     /* in this example a Standard Frame message shall be transmitted */
                    5902   ; //     Can0_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
                    5903   ; //     Can0_TxBuffer1 = 0xA5; /* ID1 = A5, (1010 0101) */
                    5904   ; //     Can0_TxBuffer2 = 0x20; /* ID2 = 20, (0010 0000) */
                    5905   ; //     Can0_TxBuffer3 = 0x31; /* data1 = 51 */
                    5906   ; //     Can0_TxBuffer4 = 0x41; /* data2 = 52*/
                    5907   ; //     Can0_TxBuffer10 = 0x11; /* data8 = 58 */
                    5908   ; //     /* Start the transmission */
                    5909   ; //     Can0_CommandReg = TR_Bit ; /* Set Transmission Request bit */
                    5910   ; // }
                    5911   ; // // Transmit for sending a message via Can controller 1
                    5912   ; // void CanBus1_Transmit(void)
                    5913   ; // {
                    5914   ; //     // TODO - put your Canbus transmit code for CanController 1 here
                    5915   ; //     // See section 4.2.2 in the application note for details (PELICAN MODE)
                    5916   ; //     /* wait until the Transmit Buffer is released */
                    5917   ; //     do
                    5918   ; //     {
                    5919   ; //     /* start a polling timer and run some tasks while waiting
                    5920   ; //     break the loop and signal an error if time too long */
                    5921   ; //     } while((Can1_StatusReg & TBS_Bit ) != TBS_Bit );
                    5922   ; //     /* Transmit Buffer is released, a message may be written into the buffer */
                    5923   ; //     /* in this example a Standard Frame message shall be transmitted */
                    5924   ; //     Can1_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
                    5925   ; //     Can1_TxBuffer1 = 0xA5; /* ID1 = A5, (1010 0101) */
                    5926   ; //     Can1_TxBuffer2 = 0x20; /* ID2 = 20, (0010 0000) */
                    5927   ; //     Can1_TxBuffer3 = 0x32; /* data1 = 51 */
                    5928   ; //     Can1_TxBuffer4 = 0x42; /* data2 = 52*/
                    5929   ; //     Can1_TxBuffer10 = 0x12; /* data8 = 58 */
                    5930   ; //     /* Start the transmission */
                    5931   ; //     Can1_CommandReg = TR_Bit ; /* Set Transmission Request bit */
                    5932   ; // }
                    5933   ; // // Receive for reading a received message via Can controller 0
                    5934   ; // void CanBus0_Receive(void)
                    5935   ; // {
                    5936   ; //     // TODO - put your Canbus receive code for CanController 0 here
                    5937   ; //     // See section 4.2.4 in the application note for details (PELICAN MODE)
                    5938   ; //     unsigned char numArray[2];
                    5939   ; //     unsigned char dataArray[10];
                    5940   ; //     do{ }while((Can0_StatusReg & RBS_Bit) != RBS_Bit);
                    5941   ; //     numArray[0] = Can0_RxBuffer1 & 0xff;
                    5942   ; //     numArray[1] = Can0_RxBuffer2 & 0xff;
                    5943   ; //     //data bits
                    5944   ; //     dataArray[0] = Can0_RxBuffer3;
                    5945   ; //     dataArray[1] = Can0_RxBuffer4;
                    5946   ; //     dataArray[8] = Can0_RxBuffer10;
                    5947   ; //     Can0_CommandReg = RRB_Bit;
                    5948   ; //     printf("Can0 recieve data at index 0: %d\n", dataArray[0]);
                    5949   ; //     printf("Can0 recieve data at index 1: %d\n", dataArray[1]);
                    5950   ; //     printf("Can0 recieve data at index 8: %d\n", dataArray[8]);
                    5951   ; // }
                    5952   ; // // Receive for reading a received message via Can controller 1
                    5953   ; // void CanBus1_Receive(void)
                    5954   ; // {
                    5955   ; //     // TODO - put your Canbus receive code for CanController 0 here
                    5956   ; //     // See section 4.2.4 in the application note for details (PELICAN MODE)
                    5957   ; //     unsigned char numArray[2];
                    5958   ; //     unsigned char dataArray[10];
                    5959   ; //     do{ }while((Can1_StatusReg & RBS_Bit) != RBS_Bit);
                    5960   ; //     numArray[0] = Can1_RxBuffer1 & 0xff;
                    5961   ; //     numArray[1] = Can1_RxBuffer2 & 0xff;
                    5962   ; //     //data bits
                    5963   ; //     dataArray[0] = Can1_RxBuffer3;
                    5964   ; //     dataArray[1] = Can1_RxBuffer4;
                    5965   ; //     dataArray[8] = Can1_RxBuffer10;
                    5966   ; //     Can1_CommandReg = RRB_Bit;
                    5967   ; //     printf("Can1 recieve data at index 0: %d\n", dataArray[0]);
                    5968   ; //     printf("Can1 recieve data at index 1: %d\n", dataArray[1]);
                    5969   ; //     printf("Can1 recieve data at index 8: %d\n", dataArray[8]);
                    5970   ; // }
                    5971   ; // void CanBusTest(void)
                    5972   ; // {
                    5973   ; //     // initialise the two Can controllers
                    5974   ; //     Init_CanBus_Controller0();
                    5975   ; //     Init_CanBus_Controller1();
                    5976   ; //     printf("\r\n\r\n---- CANBUS Test ----\r\n") ;
                    5977   ; //     // simple application to alternately transmit and receive messages from each of two nodes
                    5978   ; //     while (1) {
                    5979   ; //         for (i = 0; i < 500; i++) {
                    5980   ; //             Wait1ms();
                    5981   ; //         }
                    5982   ; //         CanBus0_Transmit() ;       // transmit a message via Controller 0
                    5983   ; //         CanBus1_Receive() ;        // receive a message via Controller 1 (and display it)
                    5984   ; //         printf("\r\n") ;
                    5985   ; //         for (i = 0; i < 500; i++) {
                    5986   ; //             Wait1ms();
                    5987   ; //         }
                    5988   ; //         CanBus1_Transmit() ;        // transmit a message via Controller 1
                    5989   ; //         CanBus0_Receive() ;         // receive a message via Controller 0 (and display it)
                    5990   ; //         printf("\r\n") ;
                    5991   ; //     }
                    5992   ; // }
                    5993   ; void Timer_ISR_1()
                    5994   ; {
                    5995   _Timer_ISR_1:
000033E8  48E7 0030 5996          movem.l   A2/A3,-(A7)
000033EC  45F9 0000 5997          lea       _CanBus0_Transmit.L,A2
000033F0  3F90      
000033F2  47F9 0000 5998          lea       _ADCRead.L,A3
000033F6  3D98      
                    5999   ; Init_CanBus_Controller0();
000033F8  4EB9 0000 6000          jsr       _Init_CanBus_Controller0
000033FC  3E70      
                    6001   ; Init_CanBus_Controller1();
000033FE  4EB9 0000 6002          jsr       _Init_CanBus_Controller1
00003402  3F00      
                    6003   ; if(Timer1Status == 1) {         // Did Timer 1 produce the Interrupt?
00003404  1039 0040 6004          move.b    4194354,D0
00003408  0032      
0000340A  0C00 0001 6005          cmp.b     #1,D0
0000340E  6600 00B6 6006          bne       Timer_ISR_1_1
                    6007   ; CanBus0_Transmit(0, PortA); // every 100ms
00003412  1239 0040 6008          move.b    4194304,D1
00003416  0000      
00003418  4881      6009          ext.w     D1
0000341A  48C1      6010          ext.l     D1
0000341C  2F01      6011          move.l    D1,-(A7)
0000341E  42A7      6012          clr.l     -(A7)
00003420  4E92      6013          jsr       (A2)
00003422  504F      6014          addq.w    #8,A7
                    6015   ; if (Timer1Count % 2 == 0) {
00003424  1039 0B00 6016          move.b    _Timer1Count.L,D0
00003428  0546      
0000342A  C0BC 0000 6017          and.l     #65535,D0
0000342E  FFFF      
00003430  80FC 0002 6018          divu.w    #2,D0
00003434  4840      6019          swap      D0
00003436  4A00      6020          tst.b     D0
00003438  661C      6021          bne.s     Timer_ISR_1_3
                    6022   ; CanBus0_Transmit(1, ADCRead(1)); // read the value of the ADC potentiometer(from Lab 5) every 200ms
0000343A  2F00      6023          move.l    D0,-(A7)
0000343C  4878 0001 6024          pea       1
00003440  4E93      6025          jsr       (A3)
00003442  584F      6026          addq.w    #4,A7
00003444  2200      6027          move.l    D0,D1
00003446  201F      6028          move.l    (A7)+,D0
00003448  4881      6029          ext.w     D1
0000344A  48C1      6030          ext.l     D1
0000344C  2F01      6031          move.l    D1,-(A7)
0000344E  4878 0001 6032          pea       1
00003452  4E92      6033          jsr       (A2)
00003454  504F      6034          addq.w    #8,A7
                    6035   Timer_ISR_1_3:
                    6036   ; }
                    6037   ; if (Timer1Count % 5 == 0) {
00003456  1039 0B00 6038          move.b    _Timer1Count.L,D0
0000345A  0546      
0000345C  C0BC 0000 6039          and.l     #65535,D0
00003460  FFFF      
00003462  80FC 0005 6040          divu.w    #5,D0
00003466  4840      6041          swap      D0
00003468  4A00      6042          tst.b     D0
0000346A  661C      6043          bne.s     Timer_ISR_1_5
                    6044   ; CanBus0_Transmit(2, ADCRead(2));
0000346C  2F00      6045          move.l    D0,-(A7)
0000346E  4878 0002 6046          pea       2
00003472  4E93      6047          jsr       (A3)
00003474  584F      6048          addq.w    #4,A7
00003476  2200      6049          move.l    D0,D1
00003478  201F      6050          move.l    (A7)+,D0
0000347A  4881      6051          ext.w     D1
0000347C  48C1      6052          ext.l     D1
0000347E  2F01      6053          move.l    D1,-(A7)
00003480  4878 0002 6054          pea       2
00003484  4E92      6055          jsr       (A2)
00003486  504F      6056          addq.w    #8,A7
                    6057   Timer_ISR_1_5:
                    6058   ; }
                    6059   ; if (Timer1Count % 20 == 0) {
00003488  1039 0B00 6060          move.b    _Timer1Count.L,D0
0000348C  0546      
0000348E  C0BC 0000 6061          and.l     #65535,D0
00003492  FFFF      
00003494  80FC 0014 6062          divu.w    #20,D0
00003498  4840      6063          swap      D0
0000349A  4A00      6064          tst.b     D0
0000349C  661A      6065          bne.s     Timer_ISR_1_7
                    6066   ; CanBus0_Transmit(3, ADCRead(0));
0000349E  2F00      6067          move.l    D0,-(A7)
000034A0  42A7      6068          clr.l     -(A7)
000034A2  4E93      6069          jsr       (A3)
000034A4  584F      6070          addq.w    #4,A7
000034A6  2200      6071          move.l    D0,D1
000034A8  201F      6072          move.l    (A7)+,D0
000034AA  4881      6073          ext.w     D1
000034AC  48C1      6074          ext.l     D1
000034AE  2F01      6075          move.l    D1,-(A7)
000034B0  4878 0003 6076          pea       3
000034B4  4E92      6077          jsr       (A2)
000034B6  504F      6078          addq.w    #8,A7
                    6079   Timer_ISR_1_7:
                    6080   ; }
                    6081   ; Timer1Control = 3;      	// reset the timer to clear the interrupt, enable interrupts and allow counter to run
000034B8  13FC 0003 6082          move.b    #3,4194354
000034BC  0040 0032 
                    6083   ; Timer1Count++ ;     
000034C0  5239 0B00 6084          addq.b    #1,_Timer1Count.L
000034C4  0546      
                    6085   Timer_ISR_1_1:
000034C6  4CDF 0C00 6086          movem.l   (A7)+,A2/A3
000034CA  4E75      6087          rts
                    6088   ; }
                    6089   ; }
                    6090   ; void main(void)
                    6091   ; {
                    6092   _main:
000034CC  4E56 FFF0 6093          link      A6,#-16
000034D0  48E7 3030 6094          movem.l   D2/D3/A2/A3,-(A7)
000034D4  45F8 0A30 6095          lea       _InstallExceptionHandler.L,A2
000034D8  47F9 0000 6096          lea       _printf.L,A3
000034DC  43B8      
                    6097   ; char c;
                    6098   ; int i, j;
                    6099   ; char* BugMessage = "DE1-68k Bug V1.77";
000034DE  41F9 0000 6100          lea       @lab6b_183.L,A0
000034E2  68BC      
000034E4  2608      6101          move.l    A0,D3
                    6102   ; char* CopyrightMessage = "Copyright (C) PJ Davies 2016";
000034E6  41F9 0000 6103          lea       @lab6b_184.L,A0
000034EA  68CE      
000034EC  2D48 FFF8 6104          move.l    A0,-8(A6)
                    6105   ; char* NameAndStudentNumber = "\r\n\r\nKenny Wakaba - 91378315\r\nJacob Yang - 24940835";
000034F0  41F9 0000 6106          lea       @lab6b_185.L,A0
000034F4  68EC      
000034F6  2D48 FFFC 6107          move.l    A0,-4(A6)
                    6108   ; // KillAllBreakPoints();
                    6109   ; // i = x = y = z = PortA_Count = 0;
                    6110   ; // Trace = GoFlag = 0;                       // used in tracing/single stepping
                    6111   ; // Echo = 1;
                    6112   ; // d0 = d1 = d2 = d3 = d4 = d5 = d6 = d7 = 0;
                    6113   ; // a0 = a1 = a2 = a3 = a4 = a5 = a6 = 0;
                    6114   ; // PC = ProgramStart, SSP = TopOfStack, USP = TopOfStack;
                    6115   ; // SR = 0x2000;                            // clear interrupts enable tracing  uses IRQ6
                    6116   ; // Initialise Breakpoint variables
                    6117   ; // for (i = 0; i < 8; i++) {
                    6118   ; //     BreakPointAddress[i] = 0;               //array of 8 breakpoint addresses
                    6119   ; //     WatchPointAddress[i] = 0;
                    6120   ; //     BreakPointInstruction[i] = 0;           // to hold the instruction at the break point
                    6121   ; //     BreakPointSetOrCleared[i] = 0;          // indicates if break point set
                    6122   ; //     WatchPointSetOrCleared[i] = 0;
                    6123   ; // }
                    6124   ; Init_RS232();     // initialise the RS232 port
000034FA  4EB8 0B12 6125          jsr       _Init_RS232
                    6126   ; Init_LCD();
000034FE  4EB8 095E 6127          jsr       _Init_LCD
                    6128   ; Init_CanBus_Controller0();
00003502  4EB9 0000 6129          jsr       _Init_CanBus_Controller0
00003506  3E70      
                    6130   ; Init_CanBus_Controller1();
00003508  4EB9 0000 6131          jsr       _Init_CanBus_Controller1
0000350C  3F00      
                    6132   ; for (i = 32; i < 48; i++)
0000350E  7420      6133          moveq     #32,D2
                    6134   main_1:
00003510  0C82 0000 6135          cmp.l     #48,D2
00003514  0030      
00003516  6C0E      6136          bge.s     main_3
                    6137   ; InstallExceptionHandler(UnhandledTrap, i);		        // install Trap exception handler on vector 32-47
00003518  2F02      6138          move.l    D2,-(A7)
0000351A  4878 28D6 6139          pea       _UnhandledTrap.L
0000351E  4E92      6140          jsr       (A2)
00003520  504F      6141          addq.w    #8,A7
00003522  5282      6142          addq.l    #1,D2
00003524  60EA      6143          bra       main_1
                    6144   main_3:
                    6145   ; InstallExceptionHandler(menu, 47);		                   // TRAP #15 call debug and end program
00003526  4878 002F 6146          pea       47
0000352A  4878 253E 6147          pea       _menu.L
0000352E  4E92      6148          jsr       (A2)
00003530  504F      6149          addq.w    #8,A7
                    6150   ; InstallExceptionHandler(UnhandledIRQ1, 25);		      // install handler for interrupts
00003532  4878 0019 6151          pea       25
00003536  4878 287C 6152          pea       _UnhandledIRQ1.L
0000353A  4E92      6153          jsr       (A2)
0000353C  504F      6154          addq.w    #8,A7
                    6155   ; InstallExceptionHandler(UnhandledIRQ2, 26);		      // install handler for interrupts
0000353E  4878 001A 6156          pea       26
00003542  4878 2888 6157          pea       _UnhandledIRQ2.L
00003546  4E92      6158          jsr       (A2)
00003548  504F      6159          addq.w    #8,A7
                    6160   ; // InstallExceptionHandler(UnhandledIRQ3, 27);		      // install handler for interrupts
                    6161   ; InstallExceptionHandler(UnhandledIRQ4, 28);		      // install handler for interrupts
0000354A  4878 001C 6162          pea       28
0000354E  4878 28A0 6163          pea       _UnhandledIRQ4.L
00003552  4E92      6164          jsr       (A2)
00003554  504F      6165          addq.w    #8,A7
                    6166   ; InstallExceptionHandler(UnhandledIRQ5, 29);		      // install handler for interrupts
00003556  4878 001D 6167          pea       29
0000355A  4878 28AC 6168          pea       _UnhandledIRQ5.L
0000355E  4E92      6169          jsr       (A2)
00003560  504F      6170          addq.w    #8,A7
                    6171   ; InstallExceptionHandler(UnhandledIRQ6, 30);		      // install handler for interrupts
00003562  4878 001E 6172          pea       30
00003566  4878 28B8 6173          pea       _UnhandledIRQ6.L
0000356A  4E92      6174          jsr       (A2)
0000356C  504F      6175          addq.w    #8,A7
                    6176   ; InstallExceptionHandler(UnhandledIRQ7, 31);		      // install handler for interrupts
0000356E  4878 001F 6177          pea       31
00003572  4878 28CA 6178          pea       _UnhandledIRQ7.L
00003576  4E92      6179          jsr       (A2)
00003578  504F      6180          addq.w    #8,A7
                    6181   ; InstallExceptionHandler(HandleBreakPoint, 46);		           // install Trap 14 Break Point exception handler on vector 46
0000357A  4878 002E 6182          pea       46
0000357E  4878 227A 6183          pea       _HandleBreakPoint.L
00003582  4E92      6184          jsr       (A2)
00003584  504F      6185          addq.w    #8,A7
                    6186   ; InstallExceptionHandler(DumpRegistersandPause, 29);		   // install TRACE handler for IRQ5 on vector 29
00003586  4878 001D 6187          pea       29
0000358A  4878 195A 6188          pea       _DumpRegistersandPause.L
0000358E  4E92      6189          jsr       (A2)
00003590  504F      6190          addq.w    #8,A7
                    6191   ; InstallExceptionHandler(BusError, 2);                          // install Bus error handler
00003592  4878 0002 6192          pea       2
00003596  4878 28E4 6193          pea       _BusError.L
0000359A  4E92      6194          jsr       (A2)
0000359C  504F      6195          addq.w    #8,A7
                    6196   ; InstallExceptionHandler(AddressError, 3);                      // install address error handler (doesn't work on soft core 68k implementation)
0000359E  4878 0003 6197          pea       3
000035A2  4878 28F2 6198          pea       _AddressError.L
000035A6  4E92      6199          jsr       (A2)
000035A8  504F      6200          addq.w    #8,A7
                    6201   ; InstallExceptionHandler(IllegalInstruction, 4);                // install illegal instruction exception handler
000035AA  4878 0004 6202          pea       4
000035AE  4878 2900 6203          pea       _IllegalInstruction.L
000035B2  4E92      6204          jsr       (A2)
000035B4  504F      6205          addq.w    #8,A7
                    6206   ; InstallExceptionHandler(Dividebyzero, 5);                      // install /0 exception handler
000035B6  4878 0005 6207          pea       5
000035BA  4878 290E 6208          pea       _Dividebyzero.L
000035BE  4E92      6209          jsr       (A2)
000035C0  504F      6210          addq.w    #8,A7
                    6211   ; InstallExceptionHandler(Check, 6);                             // install check instruction exception handler
000035C2  4878 0006 6212          pea       6
000035C6  4878 291C 6213          pea       _Check.L
000035CA  4E92      6214          jsr       (A2)
000035CC  504F      6215          addq.w    #8,A7
                    6216   ; InstallExceptionHandler(Trapv, 7);                             // install trapv instruction exception handler
000035CE  4878 0007 6217          pea       7
000035D2  4878 292A 6218          pea       _Trapv.L
000035D6  4E92      6219          jsr       (A2)
000035D8  504F      6220          addq.w    #8,A7
                    6221   ; InstallExceptionHandler(PrivError, 8);                         // install Priv Violation exception handler
000035DA  4878 0008 6222          pea       8
000035DE  4878 2938 6223          pea       _PrivError.L
000035E2  4E92      6224          jsr       (A2)
000035E4  504F      6225          addq.w    #8,A7
                    6226   ; InstallExceptionHandler(UnitIRQ, 15);                          // install uninitialised IRQ exception handler
000035E6  4878 000F 6227          pea       15
000035EA  4878 2946 6228          pea       _UnitIRQ.L
000035EE  4E92      6229          jsr       (A2)
000035F0  504F      6230          addq.w    #8,A7
                    6231   ; InstallExceptionHandler(Check, 24);                            // install spurious IRQ exception handler
000035F2  4878 0018 6232          pea       24
000035F6  4878 291C 6233          pea       _Check.L
000035FA  4E92      6234          jsr       (A2)
000035FC  504F      6235          addq.w    #8,A7
                    6236   ; InstallExceptionHandler(Timer_ISR_1, 27);
000035FE  4878 001B 6237          pea       27
00003602  4878 33E8 6238          pea       _Timer_ISR_1.L
00003606  4E92      6239          jsr       (A2)
00003608  504F      6240          addq.w    #8,A7
                    6241   ; // FlushKeyboard();                        // dump unread characters from keyboard
                    6242   ; // TraceException = 0;                     // clear trace exception port to remove any software generated single step/trace
                    6243   ; //Initialize SPI
                    6244   ; //SPI_Init();
                    6245   ; //Initialize I2C
                    6246   ; I2C_Init();
0000360A  4EB9 0000 6247          jsr       _I2C_Init
0000360E  36EE      
                    6248   ; // test for auto flash boot and run from Flash by reading switch 9 on DE1-soc board. If set, copy program from flash into Dram and run
                    6249   ; while (((char)(PortB & 0x02)) == (char)(0x02)) {
                    6250   main_4:
00003610  1039 0040 6251          move.b    4194306,D0
00003614  0002      
00003616  C03C 0002 6252          and.b     #2,D0
0000361A  0C00 0002 6253          cmp.b     #2,D0
0000361E  662A      6254          bne.s     main_6
                    6255   ; LoadFromFlashChip();
00003620  4EB8 13EC 6256          jsr       _LoadFromFlashChip
                    6257   ; printf("\r\nRunning.....");
00003624  4879 0000 6258          pea       @lab6b_186.L
00003628  6920      
0000362A  4E93      6259          jsr       (A3)
0000362C  584F      6260          addq.w    #4,A7
                    6261   ; Oline1("Running.....");
0000362E  4879 0000 6262          pea       @lab6b_187.L
00003632  6930      
00003634  4EB8 0A02 6263          jsr       _Oline1
00003638  584F      6264          addq.w    #4,A7
                    6265   ; GoFlag = 1;
0000363A  23FC 0000 6266          move.l    #1,_GoFlag.L
0000363E  0001 0B00 
00003642  00DC      
                    6267   ; go();
00003644  4EB8 08B8 6268          jsr       _go
00003648  60C6      6269          bra       main_4
                    6270   main_6:
                    6271   ; }
                    6272   ; // otherwise start the debug monitor
                    6273   ; Oline0(BugMessage);
0000364A  2F03      6274          move.l    D3,-(A7)
0000364C  4EB8 09D4 6275          jsr       _Oline0
00003650  584F      6276          addq.w    #4,A7
                    6277   ; Oline1("By: PJ Davies");
00003652  4879 0000 6278          pea       @lab6b_188.L
00003656  693E      
00003658  4EB8 0A02 6279          jsr       _Oline1
0000365C  584F      6280          addq.w    #4,A7
                    6281   ; printf("\r\n%s", BugMessage);
0000365E  2F03      6282          move.l    D3,-(A7)
00003660  4879 0000 6283          pea       @lab6b_189.L
00003664  694C      
00003666  4E93      6284          jsr       (A3)
00003668  504F      6285          addq.w    #8,A7
                    6286   ; printf("\r\n%s", CopyrightMessage);
0000366A  2F2E FFF8 6287          move.l    -8(A6),-(A7)
0000366E  4879 0000 6288          pea       @lab6b_189.L
00003672  694C      
00003674  4E93      6289          jsr       (A3)
00003676  504F      6290          addq.w    #8,A7
                    6291   ; printf("\r\n%s", NameAndStudentNumber);
00003678  2F2E FFFC 6292          move.l    -4(A6),-(A7)
0000367C  4879 0000 6293          pea       @lab6b_189.L
00003680  694C      
00003682  4E93      6294          jsr       (A3)
00003684  504F      6295          addq.w    #8,A7
                    6296   ; menu();
00003686  4EB8 253E 6297          jsr       _menu
0000368A  4CDF 0C0C 6298          movem.l   (A7)+,D2/D3/A2/A3
0000368E  4E5E      6299          unlk      A6
00003690  4E75      6300          rts
                    6301   ; }
                    6302   ; D:\CPEN412\M68K\PROGRAMS\DEMOCO\I2C.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    6303   ; #include <stdio.h>
                    6304   ; #include "I2C.H"
                    6305   ; void Enable_SCL(void){
                    6306   _Enable_SCL:
                    6307   ; I2C_CLK_PRESCALE_LOW = 0x31;
00003692  13FC 0031 6308          move.b    #49,4227072
00003696  0040 8000 
                    6309   ; I2C_CLK_PRESCALE_HIGH = 0x00;
0000369A  4239 0040 6310          clr.b     4227074
0000369E  8002      
000036A0  4E75      6311          rts
                    6312   ; }
                    6313   ; void WaitTIP(void){
                    6314   _WaitTIP:
000036A2  4E56 FFFC 6315          link      A6,#-4
                    6316   ; int TIP_bit;
                    6317   ; do{
                    6318   WaitTIP_1:
                    6319   ; TIP_bit = (I2C_STAT >> 1) & 0x01; // this flag represents acknowledge from the addressed slave | 1 = No acknowledge received | 0 = Acknowledge received
000036A6  1039 0040 6320          move.b    4227080,D0
000036AA  8008      
000036AC  C0BC 0000 6321          and.l     #255,D0
000036B0  00FF      
000036B2  E288      6322          lsr.l     #1,D0
000036B4  C0BC 0000 6323          and.l     #1,D0
000036B8  0001      
000036BA  2D40 FFFC 6324          move.l    D0,-4(A6)
000036BE  202E FFFC 6325          move.l    -4(A6),D0
000036C2  66E2      6326          bne       WaitTIP_1
000036C4  4E5E      6327          unlk      A6
000036C6  4E75      6328          rts
                    6329   ; }while(TIP_bit != 0);
                    6330   ; }
                    6331   ; void WaitACK(void){
                    6332   _WaitACK:
000036C8  4E56 FFFC 6333          link      A6,#-4
                    6334   ; int ACK;
                    6335   ; do{
                    6336   WaitACK_1:
                    6337   ; ACK = (I2C_STAT >> 7) & 0x01;
000036CC  1039 0040 6338          move.b    4227080,D0
000036D0  8008      
000036D2  C0BC 0000 6339          and.l     #255,D0
000036D6  00FF      
000036D8  EE88      6340          lsr.l     #7,D0
000036DA  C0BC 0000 6341          and.l     #1,D0
000036DE  0001      
000036E0  2D40 FFFC 6342          move.l    D0,-4(A6)
000036E4  202E FFFC 6343          move.l    -4(A6),D0
000036E8  66E2      6344          bne       WaitACK_1
000036EA  4E5E      6345          unlk      A6
000036EC  4E75      6346          rts
                    6347   ; }while(ACK != 0);
                    6348   ; }
                    6349   ; ///////////////////////////////////
                    6350   ; // I2C controller initialization //
                    6351   ; ///////////////////////////////////
                    6352   ; void I2C_Init(void){
                    6353   _I2C_Init:
                    6354   ; Enable_SCL();
000036EE  4EB8 3692 6355          jsr       _Enable_SCL
                    6356   ; Enable_I2C_Controller();
000036F2  13FC 0080 6357          move.b    #128,4227076
000036F6  0040 8004 
000036FA  4E75      6358          rts
                    6359   ; }
                    6360   ; ///////////////////////////////////////////////
                    6361   ; // write a single byte to the EEPROM via I2C //
                    6362   ; ///////////////////////////////////////////////
                    6363   ; void WriteI2CInteraction(int block, unsigned int Address, unsigned char AddressMSB, unsigned char AddressLSB, unsigned char data, int flag){
                    6364   _WriteI2CInteraction:
000036FC  4E56 0000 6365          link      A6,#0
00003700  48E7 2030 6366          movem.l   D2/A2/A3,-(A7)
00003704  45F8 36A2 6367          lea       _WaitTIP.L,A2
00003708  47F8 36C8 6368          lea       _WaitACK.L,A3
                    6369   ; unsigned char controlByte;
                    6370   ; // determine the block of interest 
                    6371   ; if (block == 1) {
0000370C  202E 0008 6372          move.l    8(A6),D0
00003710  0C80 0000 6373          cmp.l     #1,D0
00003714  0001      
00003716  6606      6374          bne.s     WriteI2CInteraction_1
                    6375   ; controlByte = EEPROM_Write_Block_1;
00003718  143C 00A2 6376          move.b    #162,D2
0000371C  6004      6377          bra.s     WriteI2CInteraction_2
                    6378   WriteI2CInteraction_1:
                    6379   ; } 
                    6380   ; else {
                    6381   ; controlByte = EEPROM_Write_Block_0;
0000371E  143C 00A0 6382          move.b    #160,D2
                    6383   WriteI2CInteraction_2:
                    6384   ; }
                    6385   ; // wait for TIP
                    6386   ; WaitTIP();
00003722  4E92      6387          jsr       (A2)
                    6388   ; // store the data to TX register
                    6389   ; I2C_TX = controlByte;
00003724  13C2 0040 6390          move.b    D2,4227078
00003728  8006      
                    6391   ; // command to generate start condition, write, and clear pending interrupt 
                    6392   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
0000372A  13FC 0091 6393          move.b    #145,4227080
0000372E  0040 8008 
                    6394   ; //Wait for TIP bit in Status Register
                    6395   ; WaitTIP();
00003732  4E92      6396          jsr       (A2)
                    6397   ; //Wait RxACK bit in Status Register
                    6398   ; WaitACK();
00003734  4E93      6399          jsr       (A3)
                    6400   ; // send the most significant byte of the address
                    6401   ; I2C_TX = AddressMSB;
00003736  13EE 0013 6402          move.b    19(A6),4227078
0000373A  0040 8006 
                    6403   ; // command to write and clear pending interrupt 
                    6404   ; I2C_CMD = I2C_CMD_Slave_Write;
0000373E  13FC 0011 6405          move.b    #17,4227080
00003742  0040 8008 
                    6406   ; WaitTIP();
00003746  4E92      6407          jsr       (A2)
                    6408   ; WaitACK();
00003748  4E93      6409          jsr       (A3)
                    6410   ; // send the least significant byte of the address
                    6411   ; I2C_TX = AddressLSB;
0000374A  13EE 0017 6412          move.b    23(A6),4227078
0000374E  0040 8006 
                    6413   ; I2C_CMD = I2C_CMD_Slave_Write;
00003752  13FC 0011 6414          move.b    #17,4227080
00003756  0040 8008 
                    6415   ; WaitTIP();
0000375A  4E92      6416          jsr       (A2)
                    6417   ; WaitACK();
0000375C  4E93      6418          jsr       (A3)
                    6419   ; // send data
                    6420   ; I2C_TX = data;
0000375E  13EE 001B 6421          move.b    27(A6),4227078
00003762  0040 8006 
                    6422   ; I2C_CMD = I2C_CMD_Slave_Write_Stop;
00003766  13FC 0051 6423          move.b    #81,4227080
0000376A  0040 8008 
                    6424   ; WaitTIP();
0000376E  4E92      6425          jsr       (A2)
                    6426   ; WaitACK();
00003770  4E93      6427          jsr       (A3)
                    6428   ; if(flag == 0){
00003772  202E 001C 6429          move.l    28(A6),D0
00003776  6620      6430          bne.s     WriteI2CInteraction_3
                    6431   ; printf("\r\nWrote [%x] to Address[%x]", data, Address);
00003778  2F2E 000C 6432          move.l    12(A6),-(A7)
0000377C  122E 001B 6433          move.b    27(A6),D1
00003780  C2BC 0000 6434          and.l     #255,D1
00003784  00FF      
00003786  2F01      6435          move.l    D1,-(A7)
00003788  4879 0000 6436          pea       @i2c_1.L
0000378C  6952      
0000378E  4EB9 0000 6437          jsr       _printf
00003792  43B8      
00003794  DEFC 000C 6438          add.w     #12,A7
                    6439   WriteI2CInteraction_3:
00003798  4CDF 0C04 6440          movem.l   (A7)+,D2/A2/A3
0000379C  4E5E      6441          unlk      A6
0000379E  4E75      6442          rts
                    6443   ; }
                    6444   ; }
                    6445   ; //////////////////////////////////////////////////
                    6446   ; // write up to 128k bytes to the EEPROM via I2C //
                    6447   ; //////////////////////////////////////////////////
                    6448   ; void PageWriteI2CInteraction(unsigned int AddressFrom, unsigned int AddressTo, unsigned char data){
                    6449   _PageWriteI2CInteraction:
000037A0  4E56 FFF4 6450          link      A6,#-12
000037A4  48E7 3F3C 6451          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000037A8  242E 0008 6452          move.l    8(A6),D2
000037AC  45F8 36A2 6453          lea       _WaitTIP.L,A2
000037B0  47F8 36C8 6454          lea       _WaitACK.L,A3
000037B4  1E2E 0013 6455          move.b    19(A6),D7
000037B8  CEBC 0000 6456          and.l     #255,D7
000037BC  00FF      
000037BE  286E 000C 6457          move.l    12(A6),A4
                    6458   ; int flag = 0;
000037C2  3A7C 0000 6459          move.w    #0,A5
                    6460   ; int flag_special = 0;
000037C6  42AE FFF6 6461          clr.l     -10(A6)
                    6462   ; int i = 0;
000037CA  4283      6463          clr.l     D3
                    6464   ; unsigned char controlByte;
                    6465   ; unsigned char AddressFromMSB;
                    6466   ; unsigned char AddressFromLSB;
                    6467   ; unsigned char AddressRange;
                    6468   ; unsigned int AddressFrom_Initial;
                    6469   ; AddressFrom_Initial = AddressFrom;
000037CC  2D42 FFFC 6470          move.l    D2,-4(A6)
                    6471   ; while(AddressFrom < AddressTo){
                    6472   PageWriteI2CInteraction_1:
000037D0  B48C      6473          cmp.l     A4,D2
000037D2  6400 0178 6474          bhs       PageWriteI2CInteraction_3
                    6475   ; if (AddressFrom + 128 > AddressTo) {
000037D6  2002      6476          move.l    D2,D0
000037D8  0680 0000 6477          add.l     #128,D0
000037DC  0080      
000037DE  B08C      6478          cmp.l     A4,D0
000037E0  6304      6479          bls.s     PageWriteI2CInteraction_4
                    6480   ; flag = 1;
000037E2  3A7C 0001 6481          move.w    #1,A5
                    6482   PageWriteI2CInteraction_4:
                    6483   ; }
                    6484   ; if (AddressFrom > 0xFFFF) {
000037E6  0C82 0000 6485          cmp.l     #65535,D2
000037EA  FFFF      
000037EC  6328      6486          bls.s     PageWriteI2CInteraction_6
                    6487   ; controlByte = EEPROM_Write_Block_1;
000037EE  1C3C 00A2 6488          move.b    #162,D6
                    6489   ; AddressFromMSB = ((AddressFrom - 0x10000) >> 8) & 0xFF;
000037F2  2002      6490          move.l    D2,D0
000037F4  0480 0001 6491          sub.l     #65536,D0
000037F8  0000      
000037FA  E088      6492          lsr.l     #8,D0
000037FC  C0BC 0000 6493          and.l     #255,D0
00003800  00FF      
00003802  1A00      6494          move.b    D0,D5
                    6495   ; AddressFromLSB = (AddressFrom - 0x10000) & 0xFF;
00003804  2002      6496          move.l    D2,D0
00003806  0480 0001 6497          sub.l     #65536,D0
0000380A  0000      
0000380C  C0BC 0000 6498          and.l     #255,D0
00003810  00FF      
00003812  1800      6499          move.b    D0,D4
00003814  601A      6500          bra.s     PageWriteI2CInteraction_7
                    6501   PageWriteI2CInteraction_6:
                    6502   ; }
                    6503   ; else {
                    6504   ; controlByte = EEPROM_Write_Block_0;
00003816  1C3C 00A0 6505          move.b    #160,D6
                    6506   ; AddressFromMSB = (AddressFrom >> 8) & 0xFF;
0000381A  2002      6507          move.l    D2,D0
0000381C  E088      6508          lsr.l     #8,D0
0000381E  C0BC 0000 6509          and.l     #255,D0
00003822  00FF      
00003824  1A00      6510          move.b    D0,D5
                    6511   ; AddressFromLSB = AddressFrom & 0xFF;
00003826  2002      6512          move.l    D2,D0
00003828  C0BC 0000 6513          and.l     #255,D0
0000382C  00FF      
0000382E  1800      6514          move.b    D0,D4
                    6515   PageWriteI2CInteraction_7:
                    6516   ; }
                    6517   ; WaitTIP();
00003830  4E92      6518          jsr       (A2)
                    6519   ; I2C_TX = controlByte;
00003832  13C6 0040 6520          move.b    D6,4227078
00003836  8006      
                    6521   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
00003838  13FC 0091 6522          move.b    #145,4227080
0000383C  0040 8008 
                    6523   ; WaitTIP();
00003840  4E92      6524          jsr       (A2)
                    6525   ; WaitACK();
00003842  4E93      6526          jsr       (A3)
                    6527   ; I2C_TX = AddressFromMSB;
00003844  13C5 0040 6528          move.b    D5,4227078
00003848  8006      
                    6529   ; I2C_CMD = I2C_CMD_Slave_Write;
0000384A  13FC 0011 6530          move.b    #17,4227080
0000384E  0040 8008 
                    6531   ; WaitTIP();
00003852  4E92      6532          jsr       (A2)
                    6533   ; WaitACK();
00003854  4E93      6534          jsr       (A3)
                    6535   ; I2C_TX = AddressFromLSB;
00003856  13C4 0040 6536          move.b    D4,4227078
0000385A  8006      
                    6537   ; I2C_CMD = I2C_CMD_Slave_Write;
0000385C  13FC 0011 6538          move.b    #17,4227080
00003860  0040 8008 
                    6539   ; WaitTIP();
00003864  4E92      6540          jsr       (A2)
                    6541   ; WaitACK();
00003866  4E93      6542          jsr       (A3)
                    6543   ; if(flag == 0){
00003868  200D      6544          move.l    A5,D0
0000386A  6600 0052 6545          bne       PageWriteI2CInteraction_8
                    6546   ; for (i = 0; i < 128; i++){  // limit write to 128 bytes
0000386E  4283      6547          clr.l     D3
                    6548   PageWriteI2CInteraction_10:
00003870  0C83 0000 6549          cmp.l     #128,D3
00003874  0080      
00003876  6C00 0042 6550          bge       PageWriteI2CInteraction_12
                    6551   ; I2C_TX = data;
0000387A  13C7 0040 6552          move.b    D7,4227078
0000387E  8006      
                    6553   ; I2C_CMD = I2C_CMD_Slave_Write;
00003880  13FC 0011 6554          move.b    #17,4227080
00003884  0040 8008 
                    6555   ; WaitTIP();
00003888  4E92      6556          jsr       (A2)
                    6557   ; WaitACK();
0000388A  4E93      6558          jsr       (A3)
                    6559   ; if((AddressFrom + i) % 128 == 0){
0000388C  2002      6560          move.l    D2,D0
0000388E  D083      6561          add.l     D3,D0
00003890  2F00      6562          move.l    D0,-(A7)
00003892  4878 0080 6563          pea       128
00003896  4EB9 0000 6564          jsr       ULDIV
0000389A  41CC      
0000389C  202F 0004 6565          move.l    4(A7),D0
000038A0  504F      6566          addq.w    #8,A7
000038A2  4A80      6567          tst.l     D0
000038A4  6602      6568          bne.s     PageWriteI2CInteraction_13
                    6569   ; break;
000038A6  6012      6570          bra.s     PageWriteI2CInteraction_12
                    6571   PageWriteI2CInteraction_13:
                    6572   ; }
                    6573   ; // check if need to switch blocks
                    6574   ; if(AddressFrom + i == 0xFFFF){
000038A8  2002      6575          move.l    D2,D0
000038AA  D083      6576          add.l     D3,D0
000038AC  0C80 0000 6577          cmp.l     #65535,D0
000038B0  FFFF      
000038B2  6602      6578          bne.s     PageWriteI2CInteraction_15
                    6579   ; break;
000038B4  6004      6580          bra.s     PageWriteI2CInteraction_12
                    6581   PageWriteI2CInteraction_15:
000038B6  5283      6582          addq.l    #1,D3
000038B8  60B6      6583          bra       PageWriteI2CInteraction_10
                    6584   PageWriteI2CInteraction_12:
000038BA  6000 005C 6585          bra       PageWriteI2CInteraction_19
                    6586   PageWriteI2CInteraction_8:
                    6587   ; }
                    6588   ; }
                    6589   ; }
                    6590   ; else {
                    6591   ; AddressRange = AddressTo - AddressFrom;
000038BE  200C      6592          move.l    A4,D0
000038C0  9082      6593          sub.l     D2,D0
000038C2  1D40 FFFB 6594          move.b    D0,-5(A6)
                    6595   ; for(i = 0; i < AddressRange; i++){                
000038C6  4283      6596          clr.l     D3
                    6597   PageWriteI2CInteraction_17:
000038C8  102E FFFB 6598          move.b    -5(A6),D0
000038CC  C0BC 0000 6599          and.l     #255,D0
000038D0  00FF      
000038D2  B680      6600          cmp.l     D0,D3
000038D4  6400 0042 6601          bhs       PageWriteI2CInteraction_19
                    6602   ; I2C_TX = data;
000038D8  13C7 0040 6603          move.b    D7,4227078
000038DC  8006      
                    6604   ; I2C_CMD = I2C_CMD_Slave_Write;
000038DE  13FC 0011 6605          move.b    #17,4227080
000038E2  0040 8008 
                    6606   ; WaitTIP();
000038E6  4E92      6607          jsr       (A2)
                    6608   ; WaitACK();
000038E8  4E93      6609          jsr       (A3)
                    6610   ; if((AddressFrom + i) % 128 == 0){
000038EA  2002      6611          move.l    D2,D0
000038EC  D083      6612          add.l     D3,D0
000038EE  2F00      6613          move.l    D0,-(A7)
000038F0  4878 0080 6614          pea       128
000038F4  4EB9 0000 6615          jsr       ULDIV
000038F8  41CC      
000038FA  202F 0004 6616          move.l    4(A7),D0
000038FE  504F      6617          addq.w    #8,A7
00003900  4A80      6618          tst.l     D0
00003902  6602      6619          bne.s     PageWriteI2CInteraction_20
                    6620   ; break;
00003904  6012      6621          bra.s     PageWriteI2CInteraction_19
                    6622   PageWriteI2CInteraction_20:
                    6623   ; }
                    6624   ; // check if need to switch blocks
                    6625   ; if(AddressFrom + i == 0xFFFF){
00003906  2002      6626          move.l    D2,D0
00003908  D083      6627          add.l     D3,D0
0000390A  0C80 0000 6628          cmp.l     #65535,D0
0000390E  FFFF      
00003910  6602      6629          bne.s     PageWriteI2CInteraction_22
                    6630   ; break;
00003912  6004      6631          bra.s     PageWriteI2CInteraction_19
                    6632   PageWriteI2CInteraction_22:
00003914  5283      6633          addq.l    #1,D3
00003916  60B0      6634          bra       PageWriteI2CInteraction_17
                    6635   PageWriteI2CInteraction_19:
                    6636   ; }
                    6637   ; }
                    6638   ; }
                    6639   ; I2C_CMD = I2C_CMD_Slave_Write_Stop;
00003918  13FC 0051 6640          move.b    #81,4227080
0000391C  0040 8008 
                    6641   ; WaitTIP();
00003920  4E92      6642          jsr       (A2)
                    6643   ; WaitACK();
00003922  4E93      6644          jsr       (A3)
                    6645   ; do {
                    6646   PageWriteI2CInteraction_24:
                    6647   ; I2C_TX = controlByte;
00003924  13C6 0040 6648          move.b    D6,4227078
00003928  8006      
                    6649   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
0000392A  13FC 0091 6650          move.b    #145,4227080
0000392E  0040 8008 
                    6651   ; WaitTIP();
00003932  4E92      6652          jsr       (A2)
00003934  1039 0040 6653          move.b    4227080,D0
00003938  8008      
0000393A  EE08      6654          lsr.b     #7,D0
0000393C  C03C 0001 6655          and.b     #1,D0
00003940  66E2      6656          bne       PageWriteI2CInteraction_24
                    6657   ; } while (((I2C_STAT >> 7) & 0x01) != 0); // wait for acknowledgement from the slave
                    6658   ; AddressFrom += (i + 1);
00003942  2003      6659          move.l    D3,D0
00003944  5280      6660          addq.l    #1,D0
00003946  D480      6661          add.l     D0,D2
00003948  6000 FE86 6662          bra       PageWriteI2CInteraction_1
                    6663   PageWriteI2CInteraction_3:
                    6664   ; }
                    6665   ; // special case for end address being the first byte of the next/last page
                    6666   ; if (((AddressFrom + i) % 128 == 0) && (flag == 1)) {
0000394C  2002      6667          move.l    D2,D0
0000394E  D083      6668          add.l     D3,D0
00003950  2F00      6669          move.l    D0,-(A7)
00003952  4878 0080 6670          pea       128
00003956  4EB9 0000 6671          jsr       ULDIV
0000395A  41CC      
0000395C  202F 0004 6672          move.l    4(A7),D0
00003960  504F      6673          addq.w    #8,A7
00003962  4A80      6674          tst.l     D0
00003964  6600 00C2 6675          bne       PageWriteI2CInteraction_29
00003968  200D      6676          move.l    A5,D0
0000396A  0C80 0000 6677          cmp.l     #1,D0
0000396E  0001      
00003970  6600 00B6 6678          bne       PageWriteI2CInteraction_29
                    6679   ; if((AddressFrom + i) > 0xFFFF){
00003974  2002      6680          move.l    D2,D0
00003976  D083      6681          add.l     D3,D0
00003978  0C80 0000 6682          cmp.l     #65535,D0
0000397C  FFFF      
0000397E  6300 005E 6683          bls       PageWriteI2CInteraction_28
                    6684   ; controlByte = EEPROM_Write_Block_1;
00003982  1C3C 00A2 6685          move.b    #162,D6
                    6686   ; AddressFromMSB = (((AddressFrom + i) - 0x10000) >> 8) & 0xFF;
00003986  2002      6687          move.l    D2,D0
00003988  D083      6688          add.l     D3,D0
0000398A  0480 0001 6689          sub.l     #65536,D0
0000398E  0000      
00003990  E088      6690          lsr.l     #8,D0
00003992  C0BC 0000 6691          and.l     #255,D0
00003996  00FF      
00003998  1A00      6692          move.b    D0,D5
                    6693   ; AddressFromLSB = ((AddressFrom + i) - 0x10000) & 0xFF;
0000399A  2002      6694          move.l    D2,D0
0000399C  D083      6695          add.l     D3,D0
0000399E  0480 0001 6696          sub.l     #65536,D0
000039A2  0000      
000039A4  C0BC 0000 6697          and.l     #255,D0
000039A8  00FF      
000039AA  1800      6698          move.b    D0,D4
                    6699   ; WriteI2CInteraction(1, (AddressFrom + i), AddressFromMSB, AddressFromLSB, data, 1);
000039AC  4878 0001 6700          pea       1
000039B0  CEBC 0000 6701          and.l     #255,D7
000039B4  00FF      
000039B6  2F07      6702          move.l    D7,-(A7)
000039B8  C8BC 0000 6703          and.l     #255,D4
000039BC  00FF      
000039BE  2F04      6704          move.l    D4,-(A7)
000039C0  CABC 0000 6705          and.l     #255,D5
000039C4  00FF      
000039C6  2F05      6706          move.l    D5,-(A7)
000039C8  2202      6707          move.l    D2,D1
000039CA  D283      6708          add.l     D3,D1
000039CC  2F01      6709          move.l    D1,-(A7)
000039CE  4878 0001 6710          pea       1
000039D2  4EB8 36FC 6711          jsr       _WriteI2CInteraction
000039D6  DEFC 0018 6712          add.w     #24,A7
000039DA  6000 004C 6713          bra       PageWriteI2CInteraction_29
                    6714   PageWriteI2CInteraction_28:
                    6715   ; }
                    6716   ; else {
                    6717   ; controlByte = EEPROM_Write_Block_0;
000039DE  1C3C 00A0 6718          move.b    #160,D6
                    6719   ; AddressFromMSB = ((AddressFrom + i) >> 8) & 0xFF;
000039E2  2002      6720          move.l    D2,D0
000039E4  D083      6721          add.l     D3,D0
000039E6  E088      6722          lsr.l     #8,D0
000039E8  C0BC 0000 6723          and.l     #255,D0
000039EC  00FF      
000039EE  1A00      6724          move.b    D0,D5
                    6725   ; AddressFromLSB = (AddressFrom + i) & 0xFF;
000039F0  2002      6726          move.l    D2,D0
000039F2  D083      6727          add.l     D3,D0
000039F4  C0BC 0000 6728          and.l     #255,D0
000039F8  00FF      
000039FA  1800      6729          move.b    D0,D4
                    6730   ; WriteI2CInteraction(0, (AddressFrom + i), AddressFromMSB, AddressFromLSB, data, 1);
000039FC  4878 0001 6731          pea       1
00003A00  CEBC 0000 6732          and.l     #255,D7
00003A04  00FF      
00003A06  2F07      6733          move.l    D7,-(A7)
00003A08  C8BC 0000 6734          and.l     #255,D4
00003A0C  00FF      
00003A0E  2F04      6735          move.l    D4,-(A7)
00003A10  CABC 0000 6736          and.l     #255,D5
00003A14  00FF      
00003A16  2F05      6737          move.l    D5,-(A7)
00003A18  2202      6738          move.l    D2,D1
00003A1A  D283      6739          add.l     D3,D1
00003A1C  2F01      6740          move.l    D1,-(A7)
00003A1E  42A7      6741          clr.l     -(A7)
00003A20  4EB8 36FC 6742          jsr       _WriteI2CInteraction
00003A24  DEFC 0018 6743          add.w     #24,A7
                    6744   PageWriteI2CInteraction_29:
                    6745   ; }
                    6746   ; }
                    6747   ; printf("\r\nWrote [%x] from Address[%x] to Address[%x]", data, AddressFrom_Initial, AddressTo);
00003A28  2F0C      6748          move.l    A4,-(A7)
00003A2A  2F2E FFFC 6749          move.l    -4(A6),-(A7)
00003A2E  CEBC 0000 6750          and.l     #255,D7
00003A32  00FF      
00003A34  2F07      6751          move.l    D7,-(A7)
00003A36  4879 0000 6752          pea       @i2c_2.L
00003A3A  696E      
00003A3C  4EB9 0000 6753          jsr       _printf
00003A40  43B8      
00003A42  DEFC 0010 6754          add.w     #16,A7
00003A46  4CDF 3CFC 6755          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00003A4A  4E5E      6756          unlk      A6
00003A4C  4E75      6757          rts
                    6758   ; }
                    6759   ; ///////////////////////////////////////////////
                    6760   ; // read a single byte to the EEPROM via I2C //
                    6761   ; ///////////////////////////////////////////////
                    6762   ; void ReadI2CByteInteraction(int block, unsigned int Address, unsigned char AddressMSB, unsigned char AddressLSB){
                    6763   _ReadI2CByteInteraction:
00003A4E  4E56 FFFC 6764          link      A6,#-4
00003A52  48E7 3030 6765          movem.l   D2/D3/A2/A3,-(A7)
00003A56  45F8 36A2 6766          lea       _WaitTIP.L,A2
00003A5A  47F8 36C8 6767          lea       _WaitACK.L,A3
                    6768   ; unsigned char controleByte_ForWrite;
                    6769   ; unsigned char controlByte_ForRead;
                    6770   ; unsigned char readData;
                    6771   ; if(block == 1){
00003A5E  202E 0008 6772          move.l    8(A6),D0
00003A62  0C80 0000 6773          cmp.l     #1,D0
00003A66  0001      
00003A68  660A      6774          bne.s     ReadI2CByteInteraction_1
                    6775   ; controleByte_ForWrite= 162;
00003A6A  163C 00A2 6776          move.b    #162,D3
                    6777   ; controlByte_ForRead = 163;
00003A6E  143C 00A3 6778          move.b    #163,D2
00003A72  6008      6779          bra.s     ReadI2CByteInteraction_2
                    6780   ReadI2CByteInteraction_1:
                    6781   ; }else{
                    6782   ; controleByte_ForWrite = 160;
00003A74  163C 00A0 6783          move.b    #160,D3
                    6784   ; controlByte_ForRead = 161;
00003A78  143C 00A1 6785          move.b    #161,D2
                    6786   ReadI2CByteInteraction_2:
                    6787   ; }
                    6788   ; WaitTIP();
00003A7C  4E92      6789          jsr       (A2)
                    6790   ; I2C_TX = controleByte_ForWrite;
00003A7E  13C3 0040 6791          move.b    D3,4227078
00003A82  8006      
                    6792   ; I2C_CMD = 145;
00003A84  13FC 0091 6793          move.b    #145,4227080
00003A88  0040 8008 
                    6794   ; WaitTIP();
00003A8C  4E92      6795          jsr       (A2)
                    6796   ; WaitACK();
00003A8E  4E93      6797          jsr       (A3)
                    6798   ; I2C_TX = AddressMSB;
00003A90  13EE 0013 6799          move.b    19(A6),4227078
00003A94  0040 8006 
                    6800   ; I2C_CMD = 17;
00003A98  13FC 0011 6801          move.b    #17,4227080
00003A9C  0040 8008 
                    6802   ; WaitTIP();
00003AA0  4E92      6803          jsr       (A2)
                    6804   ; WaitACK();
00003AA2  4E93      6805          jsr       (A3)
                    6806   ; I2C_TX = AddressLSB;
00003AA4  13EE 0017 6807          move.b    23(A6),4227078
00003AA8  0040 8006 
                    6808   ; I2C_CMD = 17;
00003AAC  13FC 0011 6809          move.b    #17,4227080
00003AB0  0040 8008 
                    6810   ; WaitTIP();
00003AB4  4E92      6811          jsr       (A2)
                    6812   ; WaitACK();
00003AB6  4E93      6813          jsr       (A3)
                    6814   ; I2C_TX = controlByte_ForRead;
00003AB8  13C2 0040 6815          move.b    D2,4227078
00003ABC  8006      
                    6816   ; I2C_CMD = 145;
00003ABE  13FC 0091 6817          move.b    #145,4227080
00003AC2  0040 8008 
                    6818   ; WaitTIP();
00003AC6  4E92      6819          jsr       (A2)
                    6820   ; WaitACK();
00003AC8  4E93      6821          jsr       (A3)
                    6822   ; I2C_CMD = 105;
00003ACA  13FC 0069 6823          move.b    #105,4227080
00003ACE  0040 8008 
                    6824   ; WaitTIP();
00003AD2  4E92      6825          jsr       (A2)
                    6826   ; while((I2C_STAT & 0x01) != 0x01) {
                    6827   ReadI2CByteInteraction_3:
00003AD4  1039 0040 6828          move.b    4227080,D0
00003AD8  8008      
00003ADA  C03C 0001 6829          and.b     #1,D0
00003ADE  0C00 0001 6830          cmp.b     #1,D0
00003AE2  6702      6831          beq.s     ReadI2CByteInteraction_5
                    6832   ; }
00003AE4  60EE      6833          bra       ReadI2CByteInteraction_3
                    6834   ReadI2CByteInteraction_5:
                    6835   ; I2C_STAT = 0;
00003AE6  4239 0040 6836          clr.b     4227080
00003AEA  8008      
                    6837   ; readData = I2C_RX;
00003AEC  1D79 0040 6838          move.b    4227078,-1(A6)
00003AF0  8006 FFFF 
                    6839   ; printf("\r\nRead [%x] from Address[%x]", readData, Address);
00003AF4  2F2E 000C 6840          move.l    12(A6),-(A7)
00003AF8  122E FFFF 6841          move.b    -1(A6),D1
00003AFC  C2BC 0000 6842          and.l     #255,D1
00003B00  00FF      
00003B02  2F01      6843          move.l    D1,-(A7)
00003B04  4879 0000 6844          pea       @i2c_3.L
00003B08  699C      
00003B0A  4EB9 0000 6845          jsr       _printf
00003B0E  43B8      
00003B10  DEFC 000C 6846          add.w     #12,A7
                    6847   ; return;
00003B14  4CDF 0C0C 6848          movem.l   (A7)+,D2/D3/A2/A3
00003B18  4E5E      6849          unlk      A6
00003B1A  4E75      6850          rts
                    6851   ; }
                    6852   ; //////////////////////////////////////////////////
                    6853   ; // read up to 128k bytes to the EEPROM via I2C //
                    6854   ; //////////////////////////////////////////////////
                    6855   ; void ReadI2CSequential(int block, int AddressTo, int AddressFrom,  unsigned int ChipAddress){
                    6856   _ReadI2CSequential:
00003B1C  4E56 FFF8 6857          link      A6,#-8
00003B20  48E7 3F3C 6858          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00003B24  45F8 36A2 6859          lea       _WaitTIP.L,A2
00003B28  47F8 36C8 6860          lea       _WaitACK.L,A3
00003B2C  242E 0014 6861          move.l    20(A6),D2
                    6862   ; unsigned char controleWriteByte;
                    6863   ; unsigned char controlReadByte;
                    6864   ; unsigned char readData;
                    6865   ; unsigned char AddressLSB;
                    6866   ; unsigned char AddressMSB;
                    6867   ; int i;
                    6868   ; int size;
                    6869   ; int block_change_flag = 0;
00003B30  387C 0000 6870          move.w    #0,A4
                    6871   ; int block_address;
                    6872   ; size = AddressTo - AddressFrom;
00003B34  202E 000C 6873          move.l    12(A6),D0
00003B38  90AE 0010 6874          sub.l     16(A6),D0
00003B3C  2D40 FFFC 6875          move.l    D0,-4(A6)
                    6876   ; AddressMSB = (ChipAddress >> 8) & 0xFF;
00003B40  2002      6877          move.l    D2,D0
00003B42  E088      6878          lsr.l     #8,D0
00003B44  C0BC 0000 6879          and.l     #255,D0
00003B48  00FF      
00003B4A  1C00      6880          move.b    D0,D6
                    6881   ; AddressLSB = ChipAddress & 0xFF;
00003B4C  2002      6882          move.l    D2,D0
00003B4E  C0BC 0000 6883          and.l     #255,D0
00003B52  00FF      
00003B54  1A00      6884          move.b    D0,D5
                    6885   ; if(block == 1){
00003B56  202E 0008 6886          move.l    8(A6),D0
00003B5A  0C80 0000 6887          cmp.l     #1,D0
00003B5E  0001      
00003B60  662C      6888          bne.s     ReadI2CSequential_1
                    6889   ; controleWriteByte = EEPROM_Write_Block_1;
00003B62  183C 00A2 6890          move.b    #162,D4
                    6891   ; controlReadByte = EEPROM_Read_Block_1;
00003B66  163C 00A3 6892          move.b    #163,D3
                    6893   ; AddressMSB = ((ChipAddress-0x10000) >> 8) & 0xFF;
00003B6A  2002      6894          move.l    D2,D0
00003B6C  0480 0001 6895          sub.l     #65536,D0
00003B70  0000      
00003B72  E088      6896          lsr.l     #8,D0
00003B74  C0BC 0000 6897          and.l     #255,D0
00003B78  00FF      
00003B7A  1C00      6898          move.b    D0,D6
                    6899   ; AddressLSB = (ChipAddress-0x10000) & 0xFF;
00003B7C  2002      6900          move.l    D2,D0
00003B7E  0480 0001 6901          sub.l     #65536,D0
00003B82  0000      
00003B84  C0BC 0000 6902          and.l     #255,D0
00003B88  00FF      
00003B8A  1A00      6903          move.b    D0,D5
00003B8C  6008      6904          bra.s     ReadI2CSequential_2
                    6905   ReadI2CSequential_1:
                    6906   ; }else{
                    6907   ; controleWriteByte = EEPROM_Write_Block_0;
00003B8E  183C 00A0 6908          move.b    #160,D4
                    6909   ; controlReadByte = EEPROM_Read_Block_0;
00003B92  163C 00A1 6910          move.b    #161,D3
                    6911   ReadI2CSequential_2:
                    6912   ; }
                    6913   ; WaitTIP();
00003B96  4E92      6914          jsr       (A2)
                    6915   ; I2C_TX = controleWriteByte;
00003B98  13C4 0040 6916          move.b    D4,4227078
00003B9C  8006      
                    6917   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
00003B9E  13FC 0091 6918          move.b    #145,4227080
00003BA2  0040 8008 
                    6919   ; WaitTIP();
00003BA6  4E92      6920          jsr       (A2)
                    6921   ; WaitACK();
00003BA8  4E93      6922          jsr       (A3)
                    6923   ; I2C_TX = AddressMSB;
00003BAA  13C6 0040 6924          move.b    D6,4227078
00003BAE  8006      
                    6925   ; I2C_CMD = I2C_CMD_Slave_Write;
00003BB0  13FC 0011 6926          move.b    #17,4227080
00003BB4  0040 8008 
                    6927   ; WaitTIP();
00003BB8  4E92      6928          jsr       (A2)
                    6929   ; WaitACK();
00003BBA  4E93      6930          jsr       (A3)
                    6931   ; I2C_TX = AddressLSB;
00003BBC  13C5 0040 6932          move.b    D5,4227078
00003BC0  8006      
                    6933   ; I2C_CMD = I2C_CMD_Slave_Write;
00003BC2  13FC 0011 6934          move.b    #17,4227080
00003BC6  0040 8008 
                    6935   ; WaitTIP();
00003BCA  4E92      6936          jsr       (A2)
                    6937   ; WaitACK();
00003BCC  4E93      6938          jsr       (A3)
                    6939   ; I2C_TX = controlReadByte;
00003BCE  13C3 0040 6940          move.b    D3,4227078
00003BD2  8006      
                    6941   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
00003BD4  13FC 0091 6942          move.b    #145,4227080
00003BD8  0040 8008 
                    6943   ; WaitTIP();
00003BDC  4E92      6944          jsr       (A2)
                    6945   ; WaitACK();
00003BDE  4E93      6946          jsr       (A3)
                    6947   ; block_address = ChipAddress;
00003BE0  2E02      6948          move.l    D2,D7
                    6949   ; for (i = 0; i < size; i++){
00003BE2  3A7C 0000 6950          move.w    #0,A5
                    6951   ReadI2CSequential_3:
00003BE6  200D      6952          move.l    A5,D0
00003BE8  B0AE FFFC 6953          cmp.l     -4(A6),D0
00003BEC  6C00 00E2 6954          bge       ReadI2CSequential_5
                    6955   ; if(block_address == 0x10000){ // if need to switch blocks 
00003BF0  0C87 0001 6956          cmp.l     #65536,D7
00003BF4  0000      
00003BF6  6624      6957          bne.s     ReadI2CSequential_6
                    6958   ; I2C_CMD = I2C_CMD_Slave_Read_Ack;
00003BF8  13FC 0029 6959          move.b    #41,4227080
00003BFC  0040 8008 
                    6960   ; WaitTIP();
00003C00  4E92      6961          jsr       (A2)
                    6962   ; while(I2C_STAT & 0x01 == 0x00);
                    6963   ; readData = I2C_RX;
00003C02  1D79 0040 6964          move.b    4227078,-5(A6)
00003C06  8006 FFFB 
                    6965   ; I2C_CMD = I2C_CMD_Slave_Read_Stop; // instead of sending a stop command
00003C0A  13FC 0049 6966          move.b    #73,4227080
00003C0E  0040 8008 
                    6967   ; // printf("\r\nADDR: %x, DATA: %x\r\n",ChipAddress,readData);
                    6968   ; WaitTIP();
00003C12  4E92      6969          jsr       (A2)
                    6970   ; block_change_flag = 1;
00003C14  387C 0001 6971          move.w    #1,A4
00003C18  6000 004E 6972          bra       ReadI2CSequential_7
                    6973   ReadI2CSequential_6:
                    6974   ; } else {
                    6975   ; I2C_CMD = I2C_CMD_Slave_Read;
00003C1C  13FC 0021 6976          move.b    #33,4227080
00003C20  0040 8008 
                    6977   ; WaitTIP();
00003C24  4E92      6978          jsr       (A2)
                    6979   ; while((I2C_STAT & 0x01) != 0x01) {
                    6980   ReadI2CSequential_11:
00003C26  1039 0040 6981          move.b    4227080,D0
00003C2A  8008      
00003C2C  C03C 0001 6982          and.b     #1,D0
00003C30  0C00 0001 6983          cmp.b     #1,D0
00003C34  6702      6984          beq.s     ReadI2CSequential_13
                    6985   ; }
00003C36  60EE      6986          bra       ReadI2CSequential_11
                    6987   ReadI2CSequential_13:
                    6988   ; I2C_STAT = 0;
00003C38  4239 0040 6989          clr.b     4227080
00003C3C  8008      
                    6990   ; readData = I2C_RX;
00003C3E  1D79 0040 6991          move.b    4227078,-5(A6)
00003C42  8006 FFFB 
                    6992   ; printf("\r\nRead [%x] from Address[%x]", readData, ChipAddress);
00003C46  2F02      6993          move.l    D2,-(A7)
00003C48  122E FFFB 6994          move.b    -5(A6),D1
00003C4C  C2BC 0000 6995          and.l     #255,D1
00003C50  00FF      
00003C52  2F01      6996          move.l    D1,-(A7)
00003C54  4879 0000 6997          pea       @i2c_3.L
00003C58  699C      
00003C5A  4EB9 0000 6998          jsr       _printf
00003C5E  43B8      
00003C60  DEFC 000C 6999          add.w     #12,A7
                    7000   ; ChipAddress++;
00003C64  5282      7001          addq.l    #1,D2
                    7002   ; block_address++;
00003C66  5287      7003          addq.l    #1,D7
                    7004   ReadI2CSequential_7:
                    7005   ; }
                    7006   ; if (block_change_flag) {
00003C68  200C      7007          move.l    A4,D0
00003C6A  6700 005E 7008          beq       ReadI2CSequential_14
                    7009   ; controleWriteByte = EEPROM_Write_Block_1;
00003C6E  183C 00A2 7010          move.b    #162,D4
                    7011   ; controlReadByte = EEPROM_Read_Block_1;
00003C72  163C 00A3 7012          move.b    #163,D3
                    7013   ; AddressMSB = 0;
00003C76  4206      7014          clr.b     D6
                    7015   ; AddressLSB = 0;
00003C78  4205      7016          clr.b     D5
                    7017   ; WaitTIP();
00003C7A  4E92      7018          jsr       (A2)
                    7019   ; I2C_TX = controleWriteByte;
00003C7C  13C4 0040 7020          move.b    D4,4227078
00003C80  8006      
                    7021   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
00003C82  13FC 0091 7022          move.b    #145,4227080
00003C86  0040 8008 
                    7023   ; WaitTIP();
00003C8A  4E92      7024          jsr       (A2)
                    7025   ; WaitACK();
00003C8C  4E93      7026          jsr       (A3)
                    7027   ; I2C_TX = AddressMSB;
00003C8E  13C6 0040 7028          move.b    D6,4227078
00003C92  8006      
                    7029   ; I2C_CMD = I2C_CMD_Slave_Write;
00003C94  13FC 0011 7030          move.b    #17,4227080
00003C98  0040 8008 
                    7031   ; WaitTIP();
00003C9C  4E92      7032          jsr       (A2)
                    7033   ; WaitACK();
00003C9E  4E93      7034          jsr       (A3)
                    7035   ; I2C_TX = AddressLSB;
00003CA0  13C5 0040 7036          move.b    D5,4227078
00003CA4  8006      
                    7037   ; I2C_CMD = I2C_CMD_Slave_Write;
00003CA6  13FC 0011 7038          move.b    #17,4227080
00003CAA  0040 8008 
                    7039   ; WaitTIP();
00003CAE  4E92      7040          jsr       (A2)
                    7041   ; WaitACK();
00003CB0  4E93      7042          jsr       (A3)
                    7043   ; I2C_TX = controlReadByte;
00003CB2  13C3 0040 7044          move.b    D3,4227078
00003CB6  8006      
                    7045   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
00003CB8  13FC 0091 7046          move.b    #145,4227080
00003CBC  0040 8008 
                    7047   ; WaitTIP();
00003CC0  4E92      7048          jsr       (A2)
                    7049   ; WaitACK();
00003CC2  4E93      7050          jsr       (A3)
                    7051   ; block_change_flag = 0;
00003CC4  387C 0000 7052          move.w    #0,A4
                    7053   ; block_address = 0;
00003CC8  7E00      7054          moveq     #0,D7
                    7055   ReadI2CSequential_14:
00003CCA  524D      7056          addq.w    #1,A5
00003CCC  6000 FF18 7057          bra       ReadI2CSequential_3
                    7058   ReadI2CSequential_5:
                    7059   ; }
                    7060   ; }
                    7061   ; I2C_CMD = I2C_CMD_Slave_Read_Ack;
00003CD0  13FC 0029 7062          move.b    #41,4227080
00003CD4  0040 8008 
                    7063   ; WaitTIP();
00003CD8  4E92      7064          jsr       (A2)
                    7065   ; while(I2C_STAT & 0x01 == 0x00);
                    7066   ; I2C_CMD = I2C_CMD_Slave_Read_Stop;
00003CDA  13FC 0049 7067          move.b    #73,4227080
00003CDE  0040 8008 
                    7068   ; printf("\r\nBlock Read operation complete\r\n");
00003CE2  4879 0000 7069          pea       @i2c_4.L
00003CE6  69BA      
00003CE8  4EB9 0000 7070          jsr       _printf
00003CEC  43B8      
00003CEE  584F      7071          addq.w    #4,A7
                    7072   ; return;
00003CF0  4CDF 3CFC 7073          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00003CF4  4E5E      7074          unlk      A6
00003CF6  4E75      7075          rts
                    7076   ; }
                    7077   ; ///////////////////////////////////////////////
                    7078   ; // generate a waveform (square wave) via DAC //
                    7079   ; ///////////////////////////////////////////////
                    7080   ; void DACWrite(void) {
                    7081   _DACWrite:
00003CF8  48E7 3830 7082          movem.l   D2/D3/D4/A2/A3,-(A7)
00003CFC  45F8 36A2 7083          lea       _WaitTIP.L,A2
00003D00  47F8 36C8 7084          lea       _WaitACK.L,A3
                    7085   ; int i;
                    7086   ; unsigned int delay = 0xFFFFF;
00003D04  283C 000F 7087          move.l    #1048575,D4
00003D08  FFFF      
                    7088   ; printf("\nI2C DAC Write: Please check LED\n");
00003D0A  4879 0000 7089          pea       @i2c_5.L
00003D0E  69DC      
00003D10  4EB9 0000 7090          jsr       _printf
00003D14  43B8      
00003D16  584F      7091          addq.w    #4,A7
                    7092   ; WaitTIP();
00003D18  4E92      7093          jsr       (A2)
                    7094   ; I2C_TX = ADC_DAC_Write_Address;
00003D1A  13FC 0090 7095          move.b    #144,4227078
00003D1E  0040 8006 
                    7096   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
00003D22  13FC 0091 7097          move.b    #145,4227080
00003D26  0040 8008 
                    7098   ; WaitTIP();
00003D2A  4E92      7099          jsr       (A2)
                    7100   ; WaitACK();
00003D2C  4E93      7101          jsr       (A3)
                    7102   ; I2C_TX = DAC_CMD_Enable;
00003D2E  13FC 0040 7103          move.b    #64,4227078
00003D32  0040 8006 
                    7104   ; I2C_CMD = I2C_CMD_Slave_Write;
00003D36  13FC 0011 7105          move.b    #17,4227080
00003D3A  0040 8008 
                    7106   ; WaitTIP();
00003D3E  4E92      7107          jsr       (A2)
                    7108   ; WaitACK();
00003D40  4E93      7109          jsr       (A3)
                    7110   ; I2C_TX = 0xFF; 
00003D42  13FC 00FF 7111          move.b    #255,4227078
00003D46  0040 8006 
                    7112   ; I2C_CMD = I2C_CMD_Slave_Write;
00003D4A  13FC 0011 7113          move.b    #17,4227080
00003D4E  0040 8008 
                    7114   ; WaitTIP();
00003D52  4E92      7115          jsr       (A2)
                    7116   ; WaitACK();
00003D54  4E93      7117          jsr       (A3)
                    7118   ; while(1) { // keep blinking the LED
                    7119   DACWrite_1:
                    7120   ; unsigned int val = 0xFF; // digital high
00003D56  263C 0000 7121          move.l    #255,D3
00003D5A  00FF      
                    7122   ; I2C_TX = val; 
00003D5C  13C3 0040 7123          move.b    D3,4227078
00003D60  8006      
                    7124   ; I2C_CMD = I2C_CMD_Slave_Write;
00003D62  13FC 0011 7125          move.b    #17,4227080
00003D66  0040 8008 
                    7126   ; WaitTIP();
00003D6A  4E92      7127          jsr       (A2)
                    7128   ; WaitACK();
00003D6C  4E93      7129          jsr       (A3)
                    7130   ; for(i = 0; i < delay; i++);
00003D6E  4282      7131          clr.l     D2
                    7132   DACWrite_4:
00003D70  B484      7133          cmp.l     D4,D2
00003D72  6404      7134          bhs.s     DACWrite_6
00003D74  5282      7135          addq.l    #1,D2
00003D76  60F8      7136          bra       DACWrite_4
                    7137   DACWrite_6:
                    7138   ; val = 0x00; // digital low
00003D78  4283      7139          clr.l     D3
                    7140   ; I2C_TX = val;
00003D7A  13C3 0040 7141          move.b    D3,4227078
00003D7E  8006      
                    7142   ; I2C_CMD = I2C_CMD_Slave_Write;
00003D80  13FC 0011 7143          move.b    #17,4227080
00003D84  0040 8008 
                    7144   ; WaitTIP();
00003D88  4E92      7145          jsr       (A2)
                    7146   ; WaitACK();
00003D8A  4E93      7147          jsr       (A3)
                    7148   ; for(i = 0; i < delay; i++);
00003D8C  4282      7149          clr.l     D2
                    7150   DACWrite_7:
00003D8E  B484      7151          cmp.l     D4,D2
00003D90  6404      7152          bhs.s     DACWrite_9
00003D92  5282      7153          addq.l    #1,D2
00003D94  60F8      7154          bra       DACWrite_7
                    7155   DACWrite_9:
00003D96  60BE      7156          bra       DACWrite_1
                    7157   ; }
                    7158   ; }
                    7159   ; ///////////////////////////////////////////////
                    7160   ; // generate a waveform (square wave) via DAC //
                    7161   ; ///////////////////////////////////////////////
                    7162   ; char ADCRead(int arg){
                    7163   _ADCRead:
00003D98  4E56 FFF8 7164          link      A6,#-8
00003D9C  48E7 3030 7165          movem.l   D2/D3/A2/A3,-(A7)
00003DA0  45F8 36A2 7166          lea       _WaitTIP.L,A2
00003DA4  262E 0008 7167          move.l    8(A6),D3
00003DA8  47F8 36C8 7168          lea       _WaitACK.L,A3
                    7169   ; unsigned char thermistor_value;
                    7170   ; unsigned char potentiometer_value;
                    7171   ; unsigned char photo_resistor_value;
                    7172   ; unsigned int delay = 0xFFFFF;
00003DAC  2D7C 000F 7173          move.l    #1048575,-4(A6)
00003DB0  FFFF FFFC 
                    7174   ; unsigned char result;
                    7175   ; // printf("I2C ADC Read:\n");
                    7176   ; // printf("\n==============================Measuring==============================\n");
                    7177   ; WaitTIP();
00003DB4  4E92      7178          jsr       (A2)
                    7179   ; I2C_TX = ADC_DAC_Write_Address;
00003DB6  13FC 0090 7180          move.b    #144,4227078
00003DBA  0040 8006 
                    7181   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
00003DBE  13FC 0091 7182          move.b    #145,4227080
00003DC2  0040 8008 
                    7183   ; WaitTIP();
00003DC6  4E92      7184          jsr       (A2)
                    7185   ; WaitACK();
00003DC8  4E93      7186          jsr       (A3)
                    7187   ; I2C_TX = ADC_CMD_Enable;
00003DCA  13FC 0044 7188          move.b    #68,4227078
00003DCE  0040 8006 
                    7189   ; I2C_CMD = I2C_CMD_Slave_Write;
00003DD2  13FC 0011 7190          move.b    #17,4227080
00003DD6  0040 8008 
                    7191   ; WaitTIP();
00003DDA  4E92      7192          jsr       (A2)
                    7193   ; WaitACK();
00003DDC  4E93      7194          jsr       (A3)
                    7195   ; I2C_TX = ADC_Read_Address;
00003DDE  13FC 0091 7196          move.b    #145,4227078
00003DE2  0040 8006 
                    7197   ; I2C_CMD = I2C_CMD_Slave_Write_With_Start;
00003DE6  13FC 0091 7198          move.b    #145,4227080
00003DEA  0040 8008 
                    7199   ; WaitTIP();
00003DEE  4E92      7200          jsr       (A2)
                    7201   ; WaitACK();
00003DF0  4E93      7202          jsr       (A3)
                    7203   ; I2C_CMD = I2C_CMD_Slave_Read;
00003DF2  13FC 0021 7204          move.b    #33,4227080
00003DF6  0040 8008 
                    7205   ; WaitTIP();
00003DFA  4E92      7206          jsr       (A2)
                    7207   ; // measure thermistor 
                    7208   ; I2C_CMD = I2C_CMD_Slave_Read;
00003DFC  13FC 0021 7209          move.b    #33,4227080
00003E00  0040 8008 
                    7210   ; WaitTIP();
00003E04  4E92      7211          jsr       (A2)
                    7212   ; thermistor_value = I2C_RX;
00003E06  1D79 0040 7213          move.b    4227078,-7(A6)
00003E0A  8006 FFF9 
                    7214   ; // measure potentiometer 
                    7215   ; I2C_CMD = I2C_CMD_Slave_Read;
00003E0E  13FC 0021 7216          move.b    #33,4227080
00003E12  0040 8008 
                    7217   ; WaitTIP();
00003E16  4E92      7218          jsr       (A2)
                    7219   ; potentiometer_value = I2C_RX;
00003E18  1D79 0040 7220          move.b    4227078,-6(A6)
00003E1C  8006 FFFA 
                    7221   ; // measure photo resistor 
                    7222   ; I2C_CMD = I2C_CMD_Slave_Read;
00003E20  13FC 0021 7223          move.b    #33,4227080
00003E24  0040 8008 
                    7224   ; WaitTIP();
00003E28  4E92      7225          jsr       (A2)
                    7226   ; photo_resistor_value = I2C_RX;
00003E2A  1D79 0040 7227          move.b    4227078,-5(A6)
00003E2E  8006 FFFB 
                    7228   ; result = 0;
00003E32  4202      7229          clr.b     D2
                    7230   ; if (arg == 0) {
00003E34  4A83      7231          tst.l     D3
00003E36  6606      7232          bne.s     ADCRead_1
                    7233   ; // printf("Value of Thermistor: %d\n", thermistor_value);
                    7234   ; result = thermistor_value;
00003E38  142E FFF9 7235          move.b    -7(A6),D2
00003E3C  6028      7236          bra.s     ADCRead_7
                    7237   ADCRead_1:
                    7238   ; } else if (arg == 1) {
00003E3E  0C83 0000 7239          cmp.l     #1,D3
00003E42  0001      
00003E44  6606      7240          bne.s     ADCRead_3
                    7241   ; // printf("Value of Potentiometer: %d\n", potentiometer_value);
                    7242   ; result = potentiometer_value;
00003E46  142E FFFA 7243          move.b    -6(A6),D2
00003E4A  601A      7244          bra.s     ADCRead_7
                    7245   ADCRead_3:
                    7246   ; } else if (arg == 2) {
00003E4C  0C83 0000 7247          cmp.l     #2,D3
00003E50  0002      
00003E52  6606      7248          bne.s     ADCRead_5
                    7249   ; // printf("Value of Photo-resister: %d\n", photo_resistor_value);
                    7250   ; result = photo_resistor_value;
00003E54  142E FFFB 7251          move.b    -5(A6),D2
00003E58  600C      7252          bra.s     ADCRead_7
                    7253   ADCRead_5:
                    7254   ; } else if (arg == 3) {
00003E5A  0C83 0000 7255          cmp.l     #3,D3
00003E5E  0003      
00003E60  6604      7256          bne.s     ADCRead_7
                    7257   ; // printf("Value of Thermistor: %d Potentiometer: %d Photo-resister: %d\n", thermistor_value, potentiometer_value, photo_resistor_value);
                    7258   ; result = 0xff;
00003E62  143C 00FF 7259          move.b    #255,D2
                    7260   ADCRead_7:
                    7261   ; } 
                    7262   ; return result;
00003E66  1002      7263          move.b    D2,D0
00003E68  4CDF 0C0C 7264          movem.l   (A7)+,D2/D3/A2/A3
00003E6C  4E5E      7265          unlk      A6
00003E6E  4E75      7266          rts
                    7267   ; }
                    7268   ; D:\CPEN412\M68K\PROGRAMS\DEMOCO\CANBUS.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    7269   ; #include <stdio.h>
                    7270   ; #include "canbus.H"
                    7271   ; #include "DM.H"
                    7272   ; // initialisation for Can controller 0
                    7273   ; void Init_CanBus_Controller0(void)
                    7274   ; {
                    7275   _Init_CanBus_Controller0:
                    7276   ; // TODO - put your Canbus initialisation code for CanController 0 here
                    7277   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                    7278   ; /* define interrupt priority & control (level-activated, see chapter 4.2.5) */
                    7279   ; // PX0 = PRIORITY_HIGH; /* CAN HAS A HIGH PRIORITY INTERRUPT */
                    7280   ; // IT0 = INTLEVELACT; /* set interrupt0 to level activated */
                    7281   ; // /* enable the communication interface of the SJA1000 */
                    7282   ; // CS = ENABLE_N; /* Enable the SJA1000 interface */
                    7283   ; // /* disable interrupts, if used (not necessary after power-on) */
                    7284   ; // EA = DISABLE; /* disable all interrupts */
                    7285   ; // SJAIntEn = DISABLE; /* disable external interrupt from SJA1000 */
                    7286   ; // /* set reset mode/request (Note: after power-on SJA1000 is in BasicCAN mode)
                    7287   ; // leave loop after a time out and signal an error */
                    7288   ; while ((Can0_ModeControlReg & RM_RR_Bit) == ClrByte){
                    7289   Init_CanBus_Controller0_1:
00003E70  1039 0050 7290          move.b    5242880,D0
00003E74  0000      
00003E76  C03C 0001 7291          and.b     #1,D0
00003E7A  6612      7292          bne.s     Init_CanBus_Controller0_3
                    7293   ; /* other bits than the reset mode/request bit are unchanged */
                    7294   ; Can0_ModeControlReg = Can0_ModeControlReg | RM_RR_Bit;
00003E7C  1039 0050 7295          move.b    5242880,D0
00003E80  0000      
00003E82  803C 0001 7296          or.b      #1,D0
00003E86  13C0 0050 7297          move.b    D0,5242880
00003E8A  0000      
00003E8C  60E2      7298          bra       Init_CanBus_Controller0_1
                    7299   Init_CanBus_Controller0_3:
                    7300   ; }
                    7301   ; // Set clock divide register to use pelican mode and bypass CAN input comparator (possible only in reset mode)
                    7302   ; Can0_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
00003E8E  13FC 00C0 7303          move.b    #192,5242942
00003E92  0050 003E 
                    7304   ; /* disable CAN interrupts, if required (always necessary after power-on)
                    7305   ; (write to SJA1000 Interrupt Enable / Control Register) */
                    7306   ; Can0_InterruptEnReg = ClrIntEnSJA;
00003E96  4239 0050 7307          clr.b     5242888
00003E9A  0008      
                    7308   ; /* define acceptance code and mask */
                    7309   ; Can0_AcceptCode0Reg = ClrByte;
00003E9C  4239 0050 7310          clr.b     5242912
00003EA0  0020      
                    7311   ; Can0_AcceptCode1Reg = ClrByte;
00003EA2  4239 0050 7312          clr.b     5242914
00003EA6  0022      
                    7313   ; Can0_AcceptCode2Reg = ClrByte;
00003EA8  4239 0050 7314          clr.b     5242916
00003EAC  0024      
                    7315   ; Can0_AcceptCode3Reg = ClrByte;
00003EAE  4239 0050 7316          clr.b     5242918
00003EB2  0026      
                    7317   ; Can0_AcceptMask0Reg = DontCare; /* every identifier is accepted */
00003EB4  13FC 00FF 7318          move.b    #255,5242920
00003EB8  0050 0028 
                    7319   ; Can0_AcceptMask1Reg = DontCare; /* every identifier is accepted */
00003EBC  13FC 00FF 7320          move.b    #255,5242922
00003EC0  0050 002A 
                    7321   ; Can0_AcceptMask2Reg = DontCare; /* every identifier is accepted */
00003EC4  13FC 00FF 7322          move.b    #255,5242924
00003EC8  0050 002C 
                    7323   ; Can0_AcceptMask3Reg = DontCare; /* every identifier is accepted */
00003ECC  13FC 00FF 7324          move.b    #255,5242926
00003ED0  0050 002E 
                    7325   ; /* configure bus timing */
                    7326   ; /* bit-rate = 100 kbit/s @ 25 MHz, the bus is sampled once */
                    7327   ; Can0_BusTiming0Reg = BTR0;
00003ED4  13FC 0004 7328          move.b    #4,5242892
00003ED8  0050 000C 
                    7329   ; Can0_BusTiming1Reg = BTR1;
00003EDC  13FC 007F 7330          move.b    #127,5242894
00003EE0  0050 000E 
                    7331   ; /* configure CAN outputs: float on TX1, Push/Pull on TX0, normal output mode */
                    7332   ; Can0_OutControlReg = Tx0Float | Tx0PshPull | NormalMode;
00003EE4  13FC 001A 7333          move.b    #26,5242896
00003EE8  0050 0010 
                    7334   ; // Set mode control to clr
                    7335   ; do {
                    7336   Init_CanBus_Controller0_4:
                    7337   ; Can0_ModeControlReg = ClrByte;
00003EEC  4239 0050 7338          clr.b     5242880
00003EF0  0000      
00003EF2  1039 0050 7339          move.b    5242880,D0
00003EF6  0000      
00003EF8  C03C 0001 7340          and.b     #1,D0
00003EFC  66EE      7341          bne       Init_CanBus_Controller0_4
00003EFE  4E75      7342          rts
                    7343   ; } while ((Can0_ModeControlReg & RM_RR_Bit) != ClrByte);
                    7344   ; }
                    7345   ; // initialisation for Can controller 1
                    7346   ; void Init_CanBus_Controller1(void)
                    7347   ; {
                    7348   _Init_CanBus_Controller1:
                    7349   ; // TODO - put your Canbus initialisation code for CanController 1 here
                    7350   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                    7351   ; while ((Can1_ModeControlReg & RM_RR_Bit) == ClrByte){
                    7352   Init_CanBus_Controller1_1:
00003F00  1039 0050 7353          move.b    5243392,D0
00003F04  0200      
00003F06  C03C 0001 7354          and.b     #1,D0
00003F0A  6612      7355          bne.s     Init_CanBus_Controller1_3
                    7356   ; /* other bits than the reset mode/request bit are unchanged */
                    7357   ; Can1_ModeControlReg = Can1_ModeControlReg | RM_RR_Bit;
00003F0C  1039 0050 7358          move.b    5243392,D0
00003F10  0200      
00003F12  803C 0001 7359          or.b      #1,D0
00003F16  13C0 0050 7360          move.b    D0,5243392
00003F1A  0200      
00003F1C  60E2      7361          bra       Init_CanBus_Controller1_1
                    7362   Init_CanBus_Controller1_3:
                    7363   ; }
                    7364   ; // Set clock divide register to use pelican mode and bypass CAN input comparator (possible only in reset mode)
                    7365   ; Can1_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
00003F1E  13FC 00C0 7366          move.b    #192,5243454
00003F22  0050 023E 
                    7367   ; /* disable CAN interrupts, if required (always necessary after power-on)
                    7368   ; (write to SJA1000 Interrupt Enable / Control Register) */
                    7369   ; Can1_InterruptEnReg = ClrIntEnSJA;
00003F26  4239 0050 7370          clr.b     5243400
00003F2A  0208      
                    7371   ; /* define acceptance code and mask */
                    7372   ; Can1_AcceptCode0Reg = ClrByte;
00003F2C  4239 0050 7373          clr.b     5243424
00003F30  0220      
                    7374   ; Can1_AcceptCode1Reg = ClrByte;
00003F32  4239 0050 7375          clr.b     5243426
00003F36  0222      
                    7376   ; Can1_AcceptCode2Reg = ClrByte;
00003F38  4239 0050 7377          clr.b     5243428
00003F3C  0224      
                    7378   ; Can1_AcceptCode3Reg = ClrByte;
00003F3E  4239 0050 7379          clr.b     5243430
00003F42  0226      
                    7380   ; Can1_AcceptMask0Reg = DontCare; /* every identifier is accepted */
00003F44  13FC 00FF 7381          move.b    #255,5243432
00003F48  0050 0228 
                    7382   ; Can1_AcceptMask1Reg = DontCare; /* every identifier is accepted */
00003F4C  13FC 00FF 7383          move.b    #255,5243434
00003F50  0050 022A 
                    7384   ; Can1_AcceptMask2Reg = DontCare; /* every identifier is accepted */
00003F54  13FC 00FF 7385          move.b    #255,5243436
00003F58  0050 022C 
                    7386   ; Can1_AcceptMask3Reg = DontCare; /* every identifier is accepted */
00003F5C  13FC 00FF 7387          move.b    #255,5243438
00003F60  0050 022E 
                    7388   ; /* configure bus timing */
                    7389   ; /* bit-rate = 100 kbit/s @ 25 MHz, the bus is sampled once */
                    7390   ; Can1_BusTiming0Reg = BTR0;
00003F64  13FC 0004 7391          move.b    #4,5243404
00003F68  0050 020C 
                    7392   ; Can1_BusTiming1Reg = BTR1;
00003F6C  13FC 007F 7393          move.b    #127,5243406
00003F70  0050 020E 
                    7394   ; /* configure CAN outputs: float on TX1, Push/Pull on TX0, normal output mode */
                    7395   ; Can1_OutControlReg = Tx0Float | Tx0PshPull | NormalMode;
00003F74  13FC 001A 7396          move.b    #26,5243408
00003F78  0050 0210 
                    7397   ; // Set mode control to clr
                    7398   ; do {
                    7399   Init_CanBus_Controller1_4:
                    7400   ; Can1_ModeControlReg = ClrByte;
00003F7C  4239 0050 7401          clr.b     5243392
00003F80  0200      
00003F82  1039 0050 7402          move.b    5243392,D0
00003F86  0200      
00003F88  C03C 0001 7403          and.b     #1,D0
00003F8C  66EE      7404          bne       Init_CanBus_Controller1_4
00003F8E  4E75      7405          rts
                    7406   ; } while ((Can1_ModeControlReg & RM_RR_Bit) != ClrByte);
                    7407   ; }
                    7408   ; // Transmit for sending a message via Can controller 0
                    7409   ; void CanBus0_Transmit(int id, char data)
                    7410   ; {
                    7411   _CanBus0_Transmit:
00003F90  4E56 0000 7412          link      A6,#0
                    7413   ; // TODO - put your Canbus transmit code for CanController 0 here
                    7414   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                    7415   ; /* wait until the Transmit Buffer is released */
                    7416   ; do
                    7417   ; {
                    7418   CanBus0_Transmit_1:
                    7419   ; /* start a polling timer and run some tasks while waiting
                    7420   ; break the loop and signal an error if time too long */
                    7421   ; } while((Can0_StatusReg & TBS_Bit ) != TBS_Bit );
00003F94  1039 0050 7422          move.b    5242884,D0
00003F98  0004      
00003F9A  C03C 0004 7423          and.b     #4,D0
00003F9E  0C00 0004 7424          cmp.b     #4,D0
00003FA2  66F0      7425          bne       CanBus0_Transmit_1
                    7426   ; /* Transmit Buffer is released, a message may be written into the buffer */
                    7427   ; /* in this example a Standard Frame message shall be transmitted */
                    7428   ; Can0_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
00003FA4  13FC 0008 7429          move.b    #8,5242912
00003FA8  0050 0020 
                    7430   ; Can0_TxBuffer1 = 0xA5; /* ID1 = A5, (1010 0101) */
00003FAC  13FC 00A5 7431          move.b    #165,5242914
00003FB0  0050 0022 
                    7432   ; Can0_TxBuffer2 = 0x20; /* ID2 = 20, (0010 0000) */
00003FB4  13FC 0020 7433          move.b    #32,5242916
00003FB8  0050 0024 
                    7434   ; Can0_TxBuffer3 = id; 
00003FBC  202E 0008 7435          move.l    8(A6),D0
00003FC0  13C0 0050 7436          move.b    D0,5242918
00003FC4  0026      
                    7437   ; Can0_TxBuffer4 = data; 
00003FC6  13EE 000F 7438          move.b    15(A6),5242920
00003FCA  0050 0028 
                    7439   ; /* Start the transmission */
                    7440   ; Can0_CommandReg = TR_Bit ; /* Set Transmission Request bit */
00003FCE  13FC 0001 7441          move.b    #1,5242882
00003FD2  0050 0002 
00003FD6  4E5E      7442          unlk      A6
00003FD8  4E75      7443          rts
                    7444   ; }
                    7445   ; // Transmit for sending a message via Can controller 1
                    7446   ; void CanBus1_Transmit(int id, char data)
                    7447   ; {
                    7448   _CanBus1_Transmit:
00003FDA  4E56 0000 7449          link      A6,#0
                    7450   ; // TODO - put your Canbus transmit code for CanController 1 here
                    7451   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                    7452   ; /* wait until the Transmit Buffer is released */
                    7453   ; do
                    7454   ; {
                    7455   CanBus1_Transmit_1:
                    7456   ; /* start a polling timer and run some tasks while waiting
                    7457   ; break the loop and signal an error if time too long */
                    7458   ; } while((Can1_StatusReg & TBS_Bit ) != TBS_Bit );
00003FDE  1039 0050 7459          move.b    5243396,D0
00003FE2  0204      
00003FE4  C03C 0004 7460          and.b     #4,D0
00003FE8  0C00 0004 7461          cmp.b     #4,D0
00003FEC  66F0      7462          bne       CanBus1_Transmit_1
                    7463   ; /* Transmit Buffer is released, a message may be written into the buffer */
                    7464   ; /* in this example a Standard Frame message shall be transmitted */
                    7465   ; Can1_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
00003FEE  13FC 0008 7466          move.b    #8,5243424
00003FF2  0050 0220 
                    7467   ; Can1_TxBuffer1 = 0xA5; /* ID1 = A5, (1010 0101) */
00003FF6  13FC 00A5 7468          move.b    #165,5243426
00003FFA  0050 0222 
                    7469   ; Can1_TxBuffer2 = 0x20; /* ID2 = 20, (0010 0000) */
00003FFE  13FC 0020 7470          move.b    #32,5243428
00004002  0050 0224 
                    7471   ; Can1_TxBuffer3 = 0x32; /* data1 = 51 */
00004006  13FC 0032 7472          move.b    #50,5243430
0000400A  0050 0226 
                    7473   ; Can1_TxBuffer4 = 0x42; /* data2 = 52*/
0000400E  13FC 0042 7474          move.b    #66,5243432
00004012  0050 0228 
                    7475   ; Can1_TxBuffer10 = 0x12; /* data8 = 58 */
00004016  13FC 0012 7476          move.b    #18,5243444
0000401A  0050 0234 
                    7477   ; /* Start the transmission */
                    7478   ; Can1_CommandReg = TR_Bit ; /* Set Transmission Request bit */
0000401E  13FC 0001 7479          move.b    #1,5243394
00004022  0050 0202 
00004026  4E5E      7480          unlk      A6
00004028  4E75      7481          rts
                    7482   ; }
                    7483   ; // Receive for reading a received message via Can controller 0
                    7484   ; void CanBus0_Receive(void)
                    7485   ; {
                    7486   _CanBus0_Receive:
0000402A  4E56 FFF4 7487          link      A6,#-12
0000402E  2F0A      7488          move.l    A2,-(A7)
00004030  45EE FFF6 7489          lea       -10(A6),A2
                    7490   ; // TODO - put your Canbus receive code for CanController 0 here
                    7491   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                    7492   ; unsigned char numArray[2];
                    7493   ; unsigned char dataArray[10];
                    7494   ; do{ }while((Can0_StatusReg & RBS_Bit) != RBS_Bit);
                    7495   CanBus0_Receive_1:
00004034  1039 0050 7496          move.b    5242884,D0
00004038  0004      
0000403A  C03C 0001 7497          and.b     #1,D0
0000403E  0C00 0001 7498          cmp.b     #1,D0
00004042  66F0      7499          bne       CanBus0_Receive_1
                    7500   ; numArray[0] = Can0_RxBuffer1 & 0xff;
00004044  1039 0050 7501          move.b    5242914,D0
00004048  0022      
0000404A  C07C 00FF 7502          and.w     #255,D0
0000404E  C07C 00FF 7503          and.w     #255,D0
00004052  1D40 FFF4 7504          move.b    D0,-12+0(A6)
                    7505   ; numArray[1] = Can0_RxBuffer2 & 0xff;
00004056  1039 0050 7506          move.b    5242916,D0
0000405A  0024      
0000405C  C07C 00FF 7507          and.w     #255,D0
00004060  C07C 00FF 7508          and.w     #255,D0
00004064  1D40 FFF5 7509          move.b    D0,-12+1(A6)
                    7510   ; //data bits
                    7511   ; dataArray[0] = Can0_RxBuffer3;
00004068  14B9 0050 7512          move.b    5242918,(A2)
0000406C  0026      
                    7513   ; dataArray[1] = Can0_RxBuffer4;
0000406E  1579 0050 7514          move.b    5242920,1(A2)
00004072  0028 0001 
                    7515   ; Can0_CommandReg = RRB_Bit;
00004076  13FC 0004 7516          move.b    #4,5242882
0000407A  0050 0002 
                    7517   ; printf("Can0 recieve data at index 0: %d\n", dataArray[0]);
0000407E  1212      7518          move.b    (A2),D1
00004080  C2BC 0000 7519          and.l     #255,D1
00004084  00FF      
00004086  2F01      7520          move.l    D1,-(A7)
00004088  4879 0000 7521          pea       @canbus_1.L
0000408C  69FE      
0000408E  4EB9 0000 7522          jsr       _printf
00004092  43B8      
00004094  504F      7523          addq.w    #8,A7
                    7524   ; printf("Can0 recieve data at index 1: %d\n", dataArray[1]);
00004096  122A 0001 7525          move.b    1(A2),D1
0000409A  C2BC 0000 7526          and.l     #255,D1
0000409E  00FF      
000040A0  2F01      7527          move.l    D1,-(A7)
000040A2  4879 0000 7528          pea       @canbus_2.L
000040A6  6A20      
000040A8  4EB9 0000 7529          jsr       _printf
000040AC  43B8      
000040AE  504F      7530          addq.w    #8,A7
000040B0  245F      7531          move.l    (A7)+,A2
000040B2  4E5E      7532          unlk      A6
000040B4  4E75      7533          rts
                    7534   ; }
                    7535   ; // Receive for reading a received message via Can controller 1
                    7536   ; void CanBus1_Receive(void)
                    7537   ; {
                    7538   _CanBus1_Receive:
000040B6  4E56 FFF4 7539          link      A6,#-12
000040BA  2F0A      7540          move.l    A2,-(A7)
000040BC  45EE FFF6 7541          lea       -10(A6),A2
                    7542   ; // TODO - put your Canbus receive code for CanController 0 here
                    7543   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                    7544   ; unsigned char numArray[2];
                    7545   ; unsigned char dataArray[10];
                    7546   ; do{ }while((Can1_StatusReg & RBS_Bit) != RBS_Bit);
                    7547   CanBus1_Receive_1:
000040C0  1039 0050 7548          move.b    5243396,D0
000040C4  0204      
000040C6  C03C 0001 7549          and.b     #1,D0
000040CA  0C00 0001 7550          cmp.b     #1,D0
000040CE  66F0      7551          bne       CanBus1_Receive_1
                    7552   ; numArray[0] = Can1_RxBuffer1 & 0xff;
000040D0  1039 0050 7553          move.b    5243426,D0
000040D4  0222      
000040D6  C07C 00FF 7554          and.w     #255,D0
000040DA  C07C 00FF 7555          and.w     #255,D0
000040DE  1D40 FFF4 7556          move.b    D0,-12+0(A6)
                    7557   ; numArray[1] = Can1_RxBuffer2 & 0xff;
000040E2  1039 0050 7558          move.b    5243428,D0
000040E6  0224      
000040E8  C07C 00FF 7559          and.w     #255,D0
000040EC  C07C 00FF 7560          and.w     #255,D0
000040F0  1D40 FFF5 7561          move.b    D0,-12+1(A6)
                    7562   ; //data bits
                    7563   ; dataArray[0] = Can1_RxBuffer3;
000040F4  14B9 0050 7564          move.b    5243430,(A2)
000040F8  0226      
                    7565   ; dataArray[1] = Can1_RxBuffer4;
000040FA  1579 0050 7566          move.b    5243432,1(A2)
000040FE  0228 0001 
                    7567   ; Can1_CommandReg = RRB_Bit;
00004102  13FC 0004 7568          move.b    #4,5243394
00004106  0050 0202 
                    7569   ; printf("Can1 recieve data at index 0: %d\n", dataArray[0]);
0000410A  1212      7570          move.b    (A2),D1
0000410C  C2BC 0000 7571          and.l     #255,D1
00004110  00FF      
00004112  2F01      7572          move.l    D1,-(A7)
00004114  4879 0000 7573          pea       @canbus_3.L
00004118  6A42      
0000411A  4EB9 0000 7574          jsr       _printf
0000411E  43B8      
00004120  504F      7575          addq.w    #8,A7
                    7576   ; printf("Can1 recieve data at index 1: %d\n", dataArray[1]);
00004122  122A 0001 7577          move.b    1(A2),D1
00004126  C2BC 0000 7578          and.l     #255,D1
0000412A  00FF      
0000412C  2F01      7579          move.l    D1,-(A7)
0000412E  4879 0000 7580          pea       @canbus_4.L
00004132  6A64      
00004134  4EB9 0000 7581          jsr       _printf
00004138  43B8      
0000413A  504F      7582          addq.w    #8,A7
0000413C  245F      7583          move.l    (A7)+,A2
0000413E  4E5E      7584          unlk      A6
00004140  4E75      7585          rts
                    7586   ; }
                    7587   ; void CanBusTest(void)
                    7588   ; {
                    7589   _CanBusTest:
00004142  48E7 2020 7590          movem.l   D2/A2,-(A7)
00004146  45F9 0000 7591          lea       _printf.L,A2
0000414A  43B8      
                    7592   ; int i;
                    7593   ; // initialise the two Can controllers
                    7594   ; Init_CanBus_Controller0();
0000414C  4EB8 3E70 7595          jsr       _Init_CanBus_Controller0
                    7596   ; Init_CanBus_Controller1();
00004150  4EB8 3F00 7597          jsr       _Init_CanBus_Controller1
                    7598   ; printf("\r\n\r\n---- CANBUS Test ----\r\n") ;
00004154  4879 0000 7599          pea       @canbus_5.L
00004158  6A86      
0000415A  4E92      7600          jsr       (A2)
0000415C  584F      7601          addq.w    #4,A7
                    7602   ; // simple application to alternately transmit and receive messages from each of two nodes
                    7603   ; while (1) {
                    7604   CanBusTest_1:
                    7605   ; for (i = 0; i < 500; i++) {
0000415E  4282      7606          clr.l     D2
                    7607   CanBusTest_4:
00004160  0C82 0000 7608          cmp.l     #500,D2
00004164  01F4      
00004166  6C08      7609          bge.s     CanBusTest_6
                    7610   ; Wait1ms();
00004168  4EB8 0932 7611          jsr       _Wait1ms
0000416C  5282      7612          addq.l    #1,D2
0000416E  60F0      7613          bra       CanBusTest_4
                    7614   CanBusTest_6:
                    7615   ; }
                    7616   ; CanBus0_Transmit(1, 0x10) ;       // transmit a message via Controller 0
00004170  4878 0010 7617          pea       16
00004174  4878 0001 7618          pea       1
00004178  4EB8 3F90 7619          jsr       _CanBus0_Transmit
0000417C  504F      7620          addq.w    #8,A7
                    7621   ; CanBus1_Receive() ;        // receive a message via Controller 1 (and display it)
0000417E  4EB8 40B6 7622          jsr       _CanBus1_Receive
                    7623   ; printf("\r\n") ;
00004182  4879 0000 7624          pea       @canbus_6.L
00004186  6AA2      
00004188  4E92      7625          jsr       (A2)
0000418A  584F      7626          addq.w    #4,A7
                    7627   ; for (i = 0; i < 500; i++) {
0000418C  4282      7628          clr.l     D2
                    7629   CanBusTest_7:
0000418E  0C82 0000 7630          cmp.l     #500,D2
00004192  01F4      
00004194  6C08      7631          bge.s     CanBusTest_9
                    7632   ; Wait1ms();
00004196  4EB8 0932 7633          jsr       _Wait1ms
0000419A  5282      7634          addq.l    #1,D2
0000419C  60F0      7635          bra       CanBusTest_7
                    7636   CanBusTest_9:
                    7637   ; }
                    7638   ; CanBus1_Transmit(1, 0x11) ;        // transmit a message via Controller 1
0000419E  4878 0011 7639          pea       17
000041A2  4878 0001 7640          pea       1
000041A6  4EB8 3FDA 7641          jsr       _CanBus1_Transmit
000041AA  504F      7642          addq.w    #8,A7
                    7643   ; CanBus0_Receive() ;         // receive a message via Controller 0 (and display it)
000041AC  4EB8 402A 7644          jsr       _CanBus0_Receive
                    7645   ; printf("\r\n") ;
000041B0  4879 0000 7646          pea       @canbus_6.L
000041B4  6AA2      
000041B6  4E92      7647          jsr       (A2)
000041B8  584F      7648          addq.w    #4,A7
000041BA  60A2      7649          bra       CanBusTest_1
                    7650   ; }
                    7651   ; }
                    7652   _strcpy:
000041BC  206F 0004 7653          move.l    (4,A7),A0
000041C0  226F 0008 7654          move.l    (8,A7),A1
000041C4  2008      7655          move.l    A0,D0
                    7656   strcpy_1:
000041C6  10D9      7657          move.b    (A1)+,(A0)+
000041C8  66FC      7658          bne       strcpy_1
000041CA  4E75      7659          rts
                    7660   ULDIV:
000041CC  4E56 0000 7661          link    A6,#0
000041D0  48E7 C000 7662          movem.l D0/D1,-(A7)
000041D4  222E 0008 7663          move.l  8(A6),D1
000041D8  202E 000C 7664          move.l  12(A6),D0
000041DC  6036      7665          bra.s   ldiv_3
                    7666   LDIV:
000041DE  4E56 0000 7667          link    A6,#0
000041E2  48E7 C000 7668          movem.l D0/D1,-(A7)
000041E6  222E 0008 7669          move.l  8(A6),D1
000041EA  202E 000C 7670          move.l  12(A6),D0
000041EE  4A80      7671          tst.l   D0
000041F0  6A0E      7672          bpl.s   ldiv_1
000041F2  4480      7673          neg.l   D0
000041F4  4A81      7674          tst.l   D1
000041F6  6A14      7675          bpl.s   ldiv_2
000041F8  4481      7676          neg.l   D1
000041FA  612A      7677          bsr.s   dodiv
000041FC  4481      7678          neg.l   D1
000041FE  6016      7679          bra.s   ldiv_4
                    7680   ldiv_1:
00004200  4A81      7681          tst.l   D1
00004202  6A10      7682          bpl.s   ldiv_3
00004204  4481      7683          neg.l   D1
00004206  611E      7684          bsr.s   dodiv
00004208  4480      7685          neg.l   D0
0000420A  600A      7686          bra.s   ldiv_4
                    7687   ldiv_2:
0000420C  6118      7688          bsr.s   dodiv
0000420E  4480      7689          neg.l   D0
00004210  4481      7690          neg.l   D1
00004212  6002      7691          bra.s   ldiv_4
                    7692   ldiv_3:
00004214  6110      7693          bsr.s   dodiv
                    7694   ldiv_4:
00004216  2D40 0008 7695          move.l  D0,8(A6)
0000421A  2D41 000C 7696          move.l  D1,12(A6)
0000421E  4CDF 0003 7697          movem.l (A7)+,D0/D1
00004222  4E5E      7698          unlk    A6
00004224  4E75      7699          rts
                    7700   dodiv:
00004226  0C81 0000 7701          cmpi.l  #$FFFF,D1
0000422A  FFFF      
0000422C  6236      7702          bhi.s   dodiv_2
0000422E  0C80 0000 7703          cmpi.l  #$FFFF,D0
00004232  FFFF      
00004234  6210      7704          bhi.s   dodiv_1
00004236  80C1      7705          divu    D1,D0
00004238  2200      7706          move.l  D0,D1
0000423A  4241      7707          clr.w   D1
0000423C  4841      7708          swap    D1
0000423E  0280 0000 7709          andi.l  #$FFFF,D0
00004242  FFFF      
00004244  4E75      7710          rts
                    7711   dodiv_1:
00004246  48A7 A000 7712          movem.w D0/D2,-(A7)
0000424A  4240      7713          clr.w   D0
0000424C  4840      7714          swap    D0
0000424E  80C1      7715          divu    D1,D0
00004250  3400      7716          move.w  D0,D2
00004252  301F      7717          move.w  (A7)+,D0
00004254  80C1      7718          divu    D1,D0
00004256  4840      7719          swap    D0
00004258  4281      7720          clr.l   D1
0000425A  3200      7721          move.w  D0,D1
0000425C  3002      7722          move.w  D2,D0
0000425E  4840      7723          swap    D0
00004260  341F      7724          move.w  (A7)+,D2
00004262  4E75      7725          rts
                    7726   dodiv_2:
00004264  48E7 3800 7727          movem.l D2/D3/D4,-(A7)
00004268  2401      7728          move.l  D1,D2
0000426A  4242      7729          clr.w   D2
0000426C  4842      7730          swap    D2
0000426E  5282      7731          addq.l  #1,D2
00004270  2600      7732          move.l  D0,D3
00004272  2801      7733          move.l  D1,D4
00004274  2202      7734          move.l  D2,D1
00004276  61CE      7735          bsr.s   dodiv_1
00004278  2204      7736          move.l  D4,D1
0000427A  82C2      7737          divu    D2,D1
0000427C  80C1      7738          divu    D1,D0
0000427E  0280 0000 7739          andi.l  #$FFFF,D0
00004282  FFFF      
                    7740   dodiv_3:
00004284  2204      7741          move.l  D4,D1
00004286  2404      7742          move.l  D4,D2
00004288  4842      7743          swap    D2
0000428A  C2C0      7744          mulu    D0,D1
0000428C  C4C0      7745          mulu    D0,D2
0000428E  4842      7746          swap    D2
00004290  D282      7747          add.l   D2,D1
00004292  9283      7748          sub.l   D3,D1
00004294  620A      7749          bhi.s   dodiv_4
00004296  4481      7750          neg.l   D1
00004298  B881      7751          cmp.l   D1,D4
0000429A  6208      7752          bhi.s   dodiv_5
0000429C  5280      7753          addq.l  #1,D0
0000429E  60E4      7754          bra.s   dodiv_3
                    7755   dodiv_4:
000042A0  5380      7756          subq.l  #1,D0
000042A2  60E0      7757          bra.s   dodiv_3
                    7758   dodiv_5:
000042A4  4CDF 001C 7759          movem.l (A7)+,D2/D3/D4
000042A8  4E75      7760          rts
                    7761   _putch:
000042AA  4E56 0000 7762          link      A6,#0
000042AE  48E7 2000 7763          movem.l   D2,-(A7)
000042B2  242E 0008 7764          move.l    8(A6),D2
000042B6  0C82 0000 7765          cmp.l     #10,D2
000042BA  000A      
000042BC  660A      7766          bne.s     putch_1
000042BE  4878 000D 7767          pea       13
000042C2  6100 C878 7768          bsr       __putch
000042C6  584F      7769          addq.w    #4,A7
                    7770   putch_1:
000042C8  2F02      7771          move.l    D2,-(A7)
000042CA  6100 C870 7772          bsr       __putch
000042CE  584F      7773          addq.w    #4,A7
000042D0  2002      7774          move.l    D2,D0
000042D2  4CDF 0004 7775          movem.l   (A7)+,D2
000042D6  4E5E      7776          unlk      A6
000042D8  4E75      7777          rts
                    7778   _getch:
000042DA  48E7 2000 7779          movem.l   D2,-(A7)
000042DE  2439 0B00 7780          move.l    __ungetbuf,D2
000042E2  00C0      
000042E4  2039 0B00 7781          move.l    __ungetbuf,D0
000042E8  00C0      
000042EA  0C80 FFFF 7782          cmp.l     #-1,D0
000042EE  FFFF      
000042F0  670C      7783          beq.s     getch_1
000042F2  23FC FFFF 7784          move.l    #-1,__ungetbuf
000042F6  FFFF 0B00 
000042FA  00C0      
000042FC  6010      7785          bra.s     getch_3
                    7786   getch_1:
000042FE  6100 C868 7787          bsr       __getch
00004302  2400      7788          move.l    D0,D2
00004304  0C80 0000 7789          cmp.l     #13,D0
00004308  000D      
0000430A  6602      7790          bne.s     getch_3
0000430C  740A      7791          moveq     #10,D2
                    7792   getch_3:
0000430E  2002      7793          move.l    D2,D0
00004310  4CDF 0004 7794          movem.l   (A7)+,D2
00004314  4E75      7795          rts
                    7796   _tolower:
00004316  4E56 0000 7797          link      A6,#0
0000431A  48E7 2000 7798          movem.l   D2,-(A7)
0000431E  242E 0008 7799          move.l    8(A6),D2
00004322  0C82 0000 7800          cmp.l     #65,D2
00004326  0041      
00004328  6D0E      7801          blt.s     tolower_1
0000432A  0C82 0000 7802          cmp.l     #90,D2
0000432E  005A      
00004330  6E06      7803          bgt.s     tolower_1
00004332  84BC 0000 7804          or.l      #32,D2
00004336  0020      
                    7805   tolower_1:
00004338  2002      7806          move.l    D2,D0
0000433A  4CDF 0004 7807          movem.l   (A7)+,D2
0000433E  4E5E      7808          unlk      A6
00004340  4E75      7809          rts
                    7810   _sprintf:
00004342  4E56 FFFC 7811          link      A6,#-4
00004346  48E7 2000 7812          movem.l   D2,-(A7)
0000434A  41EE 000C 7813          lea       12(A6),A0
0000434E  5848      7814          addq.w    #4,A0
00004350  2408      7815          move.l    A0,D2
00004352  2F02      7816          move.l    D2,-(A7)
00004354  2F2E 000C 7817          move.l    12(A6),-(A7)
00004358  2F2E 0008 7818          move.l    8(A6),-(A7)
0000435C  6100 013E 7819          bsr       _vsprintf
00004360  DEFC 000C 7820          add.w     #12,A7
00004364  2D40 FFFC 7821          move.l    D0,-4(A6)
00004368  4282      7822          clr.l     D2
0000436A  202E FFFC 7823          move.l    -4(A6),D0
0000436E  4CDF 0004 7824          movem.l   (A7)+,D2
00004372  4E5E      7825          unlk      A6
00004374  4E75      7826          rts
                    7827   _strcat:
00004376  206F 0004 7828          move.l    (4,A7),A0	
0000437A  226F 0008 7829          move.l    (8,A7),A1	
0000437E  2008      7830          move.l    A0,D0		
                    7831   strcat_0:
00004380  4A18      7832          tst.b     (A0)+
00004382  66FC      7833          bne       strcat_0
00004384  5348      7834          subq      #1,A0
                    7835   strcat_1:
00004386  10D9      7836          move.b    (A1)+,(A0)+
00004388  66FC      7837          bne       strcat_1
0000438A  4E75      7838          rts
                    7839   _toupper:
0000438C  4E56 0000 7840          link      A6,#0
00004390  48E7 2000 7841          movem.l   D2,-(A7)
00004394  242E 0008 7842          move.l    8(A6),D2
00004398  0C82 0000 7843          cmp.l     #97,D2
0000439C  0061      
0000439E  6D0E      7844          blt.s     toupper_1
000043A0  0C82 0000 7845          cmp.l     #122,D2
000043A4  007A      
000043A6  6E06      7846          bgt.s     toupper_1
000043A8  C4BC 0000 7847          and.l     #95,D2
000043AC  005F      
                    7848   toupper_1:
000043AE  2002      7849          move.l    D2,D0
000043B0  4CDF 0004 7850          movem.l   (A7)+,D2
000043B4  4E5E      7851          unlk      A6
000043B6  4E75      7852          rts
                    7853   _printf:
000043B8  4E56 FFFC 7854          link      A6,#-4
000043BC  48E7 2000 7855          movem.l   D2,-(A7)
000043C0  41EE 0008 7856          lea       8(A6),A0
000043C4  5848      7857          addq.w    #4,A0
000043C6  2408      7858          move.l    A0,D2
000043C8  2F02      7859          move.l    D2,-(A7)
000043CA  2F2E 0008 7860          move.l    8(A6),-(A7)
000043CE  42A7      7861          clr.l     -(A7)
000043D0  6100 00CA 7862          bsr       _vsprintf
000043D4  DEFC 000C 7863          add.w     #12,A7
000043D8  2D40 FFFC 7864          move.l    D0,-4(A6)
000043DC  4282      7865          clr.l     D2
000043DE  202E FFFC 7866          move.l    -4(A6),D0
000043E2  4CDF 0004 7867          movem.l   (A7)+,D2
000043E6  4E5E      7868          unlk      A6
000043E8  4E75      7869          rts
                    7870   @vsprintf_copy:
000043EA  4E56 0000 7871          link      A6,#0
000043EE  206E 0008 7872          move.l    8(A6),A0
000043F2  4A90      7873          tst.l     (A0)
000043F4  6710      7874          beq.s     @vsprintf_copy_1
000043F6  202E 000C 7875          move.l    12(A6),D0
000043FA  206E 0008 7876          move.l    8(A6),A0
000043FE  2250      7877          move.l    (A0),A1
00004400  5290      7878          addq.l    #1,(A0)
00004402  1280      7879          move.b    D0,(A1)
00004404  600A      7880          bra.s     @vsprintf_copy_2
                    7881   @vsprintf_copy_1:
00004406  2F2E 000C 7882          move.l    12(A6),-(A7)
0000440A  6100 FE9E 7883          bsr       _putch
0000440E  584F      7884          addq.w    #4,A7
                    7885   @vsprintf_copy_2:
00004410  4E5E      7886          unlk      A6
00004412  4E75      7887          rts
                    7888   @vsprintf_getval:
00004414  4E56 0000 7889          link      A6,#0
00004418  48E7 3000 7890          movem.l   D2/D3,-(A7)
0000441C  242E 0008 7891          move.l    8(A6),D2
00004420  4283      7892          clr.l     D3
00004422  2042      7893          move.l    D2,A0
00004424  2050      7894          move.l    (A0),A0
00004426  1010      7895          move.b    (A0),D0
00004428  4880      7896          ext.w     D0
0000442A  48C0      7897          ext.l     D0
0000442C  0C80 0000 7898          cmp.l     #42,D0
00004430  002A      
00004432  6612      7899          bne.s     @vsprintf_getval_1
00004434  206E 000C 7900          move.l    12(A6),A0
00004438  2250      7901          move.l    (A0),A1
0000443A  5890      7902          addq.l    #4,(A0)
0000443C  2611      7903          move.l    (A1),D3
0000443E  2042      7904          move.l    D2,A0
00004440  5290      7905          addq.l    #1,(A0)
00004442  6000 004E 7906          bra       @vsprintf_getval_5
                    7907   @vsprintf_getval_1:
00004446  2042      7908          move.l    D2,A0
00004448  2050      7909          move.l    (A0),A0
0000444A  1010      7910          move.b    (A0),D0
0000444C  4880      7911          ext.w     D0
0000444E  48C0      7912          ext.l     D0
00004450  0C80 0000 7913          cmp.l     #48,D0
00004454  0030      
00004456  6D00 003A 7914          blt       @vsprintf_getval_5
0000445A  2042      7915          move.l    D2,A0
0000445C  2050      7916          move.l    (A0),A0
0000445E  1010      7917          move.b    (A0),D0
00004460  4880      7918          ext.w     D0
00004462  48C0      7919          ext.l     D0
00004464  0C80 0000 7920          cmp.l     #57,D0
00004468  0039      
0000446A  6E26      7921          bgt.s     @vsprintf_getval_5
0000446C  2F03      7922          move.l    D3,-(A7)
0000446E  4878 000A 7923          pea       10
00004472  6100 07F4 7924          bsr       LMUL
00004476  2017      7925          move.l    (A7),D0
00004478  504F      7926          addq.w    #8,A7
0000447A  2042      7927          move.l    D2,A0
0000447C  2250      7928          move.l    (A0),A1
0000447E  5290      7929          addq.l    #1,(A0)
00004480  1211      7930          move.b    (A1),D1
00004482  4881      7931          ext.w     D1
00004484  48C1      7932          ext.l     D1
00004486  D081      7933          add.l     D1,D0
00004488  0480 0000 7934          sub.l     #48,D0
0000448C  0030      
0000448E  2600      7935          move.l    D0,D3
00004490  60B4      7936          bra       @vsprintf_getval_1
                    7937   @vsprintf_getval_5:
00004492  2003      7938          move.l    D3,D0
00004494  4CDF 000C 7939          movem.l   (A7)+,D2/D3
00004498  4E5E      7940          unlk      A6
0000449A  4E75      7941          rts
                    7942   _vsprintf:
0000449C  4E56 FFCC 7943          link      A6,#-52
000044A0  48E7 3F3C 7944          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000044A4  45EE 0008 7945          lea       8(A6),A2
000044A8  47F8 43EA 7946          lea       @vsprintf_copy,A3
000044AC  49F9 0000 7947          lea       _ultoa,A4
000044B0  4BF4      
000044B2  4286      7948          clr.l     D6
                    7949   vsprintf_1:
000044B4  206E 000C 7950          move.l    12(A6),A0
000044B8  4A10      7951          tst.b     (A0)
000044BA  6700 0624 7952          beq       vsprintf_3
000044BE  206E 000C 7953          move.l    12(A6),A0
000044C2  1010      7954          move.b    (A0),D0
000044C4  4880      7955          ext.w     D0
000044C6  48C0      7956          ext.l     D0
000044C8  0C80 0000 7957          cmp.l     #37,D0
000044CC  0025      
000044CE  671C      7958          beq.s     vsprintf_4
000044D0  206E 000C 7959          move.l    12(A6),A0
000044D4  52AE 000C 7960          addq.l    #1,12(A6)
000044D8  1210      7961          move.b    (A0),D1
000044DA  4881      7962          ext.w     D1
000044DC  48C1      7963          ext.l     D1
000044DE  2F01      7964          move.l    D1,-(A7)
000044E0  2F0A      7965          move.l    A2,-(A7)
000044E2  4E93      7966          jsr       (A3)
000044E4  504F      7967          addq.w    #8,A7
000044E6  5286      7968          addq.l    #1,D6
000044E8  6000 05F2 7969          bra       vsprintf_2
                    7970   vsprintf_4:
000044EC  52AE 000C 7971          addq.l    #1,12(A6)
000044F0  422E FFD3 7972          clr.b     -45(A6)
000044F4  422E FFD2 7973          clr.b     -46(A6)
000044F8  422E FFD0 7974          clr.b     -48(A6)
000044FC  422E FFCF 7975          clr.b     -49(A6)
00004500  422E FFCE 7976          clr.b     -50(A6)
00004504  422E FFCD 7977          clr.b     -51(A6)
00004508  42AE FFFC 7978          clr.l     -4(A6)
0000450C  7AFF      7979          moveq     #-1,D5
0000450E  41EE FFDC 7980          lea       -36(A6),A0
00004512  2608      7981          move.l    A0,D3
00004514  2408      7982          move.l    A0,D2
                    7983   vsprintf_6:
00004516  206E 000C 7984          move.l    12(A6),A0
0000451A  1010      7985          move.b    (A0),D0
0000451C  4880      7986          ext.w     D0
0000451E  48C0      7987          ext.l     D0
00004520  0C80 0000 7988          cmp.l     #43,D0
00004524  002B      
00004526  6730      7989          beq.s     vsprintf_12
00004528  6E18      7990          bgt.s     vsprintf_15
0000452A  0C80 0000 7991          cmp.l     #35,D0
0000452E  0023      
00004530  6700 003E 7992          beq       vsprintf_14
00004534  6E00 0046 7993          bgt       vsprintf_9
00004538  0C80 0000 7994          cmp.l     #32,D0
0000453C  0020      
0000453E  6724      7995          beq.s     vsprintf_13
00004540  603A      7996          bra.s     vsprintf_9
                    7997   vsprintf_15:
00004542  0C80 0000 7998          cmp.l     #45,D0
00004546  002D      
00004548  6702      7999          beq.s     vsprintf_11
0000454A  6030      8000          bra.s     vsprintf_9
                    8001   vsprintf_11:
0000454C  1D7C 0001 8002          move.b    #1,-51(A6)
00004550  FFCD      
00004552  52AE 000C 8003          addq.l    #1,12(A6)
00004556  6026      8004          bra.s     vsprintf_7
                    8005   vsprintf_12:
00004558  1D7C 0001 8006          move.b    #1,-50(A6)
0000455C  FFCE      
0000455E  52AE 000C 8007          addq.l    #1,12(A6)
00004562  601A      8008          bra.s     vsprintf_7
                    8009   vsprintf_13:
00004564  1D7C 0001 8010          move.b    #1,-49(A6)
00004568  FFCF      
0000456A  52AE 000C 8011          addq.l    #1,12(A6)
0000456E  600E      8012          bra.s     vsprintf_7
                    8013   vsprintf_14:
00004570  1D7C 0001 8014          move.b    #1,-48(A6)
00004574  FFD0      
00004576  52AE 000C 8015          addq.l    #1,12(A6)
0000457A  6002      8016          bra.s     vsprintf_7
                    8017   vsprintf_9:
0000457C  6002      8018          bra.s     vsprintf_8
                    8019   vsprintf_7:
0000457E  6096      8020          bra       vsprintf_6
                    8021   vsprintf_8:
00004580  206E 000C 8022          move.l    12(A6),A0
00004584  1010      8023          move.b    (A0),D0
00004586  4880      8024          ext.w     D0
00004588  48C0      8025          ext.l     D0
0000458A  0C80 0000 8026          cmp.l     #48,D0
0000458E  0030      
00004590  660A      8027          bne.s     vsprintf_16
00004592  52AE 000C 8028          addq.l    #1,12(A6)
00004596  1D7C 0001 8029          move.b    #1,-46(A6)
0000459A  FFD2      
                    8030   vsprintf_16:
0000459C  486E 0010 8031          pea       16(A6)
000045A0  486E 000C 8032          pea       12(A6)
000045A4  6100 FE6E 8033          bsr       @vsprintf_getval
000045A8  504F      8034          addq.w    #8,A7
000045AA  2A40      8035          move.l    D0,A5
000045AC  206E 000C 8036          move.l    12(A6),A0
000045B0  1010      8037          move.b    (A0),D0
000045B2  4880      8038          ext.w     D0
000045B4  48C0      8039          ext.l     D0
000045B6  0C80 0000 8040          cmp.l     #46,D0
000045BA  002E      
000045BC  6614      8041          bne.s     vsprintf_18
000045BE  52AE 000C 8042          addq.l    #1,12(A6)
000045C2  486E 0010 8043          pea       16(A6)
000045C6  486E 000C 8044          pea       12(A6)
000045CA  6100 FE48 8045          bsr       @vsprintf_getval
000045CE  504F      8046          addq.w    #8,A7
000045D0  2A00      8047          move.l    D0,D5
                    8048   vsprintf_18:
000045D2  206E 000C 8049          move.l    12(A6),A0
000045D6  1010      8050          move.b    (A0),D0
000045D8  4880      8051          ext.w     D0
000045DA  48C0      8052          ext.l     D0
000045DC  0C80 0000 8053          cmp.l     #108,D0
000045E0  006C      
000045E2  660A      8054          bne.s     vsprintf_20
000045E4  52AE 000C 8055          addq.l    #1,12(A6)
000045E8  1D7C 0001 8056          move.b    #1,-45(A6)
000045EC  FFD3      
                    8057   vsprintf_20:
000045EE  206E 000C 8058          move.l    12(A6),A0
000045F2  1010      8059          move.b    (A0),D0
000045F4  4880      8060          ext.w     D0
000045F6  48C0      8061          ext.l     D0
000045F8  0C80 0000 8062          cmp.l     #111,D0
000045FC  006F      
000045FE  6700 00D4 8063          beq       vsprintf_27
00004602  6E34      8064          bgt.s     vsprintf_33
00004604  0C80 0000 8065          cmp.l     #100,D0
00004608  0064      
0000460A  6700 0054 8066          beq       vsprintf_24
0000460E  6E1C      8067          bgt.s     vsprintf_34
00004610  0C80 0000 8068          cmp.l     #99,D0
00004614  0063      
00004616  6700 012C 8069          beq       vsprintf_30
0000461A  6E00 016A 8070          bgt       vsprintf_22
0000461E  0C80 0000 8071          cmp.l     #88,D0
00004622  0058      
00004624  6700 00E6 8072          beq       vsprintf_28
00004628  6000 015C 8073          bra       vsprintf_22
                    8074   vsprintf_34:
0000462C  0C80 0000 8075          cmp.l     #105,D0
00004630  0069      
00004632  672C      8076          beq.s     vsprintf_24
00004634  6000 0150 8077          bra       vsprintf_22
                    8078   vsprintf_33:
00004638  0C80 0000 8079          cmp.l     #117,D0
0000463C  0075      
0000463E  6700 005C 8080          beq       vsprintf_26
00004642  6E0E      8081          bgt.s     vsprintf_35
00004644  0C80 0000 8082          cmp.l     #115,D0
00004648  0073      
0000464A  6700 011C 8083          beq       vsprintf_31
0000464E  6000 0136 8084          bra       vsprintf_22
                    8085   vsprintf_35:
00004652  0C80 0000 8086          cmp.l     #120,D0
00004656  0078      
00004658  6700 00B2 8087          beq       vsprintf_28
0000465C  6000 0128 8088          bra       vsprintf_22
                    8089   vsprintf_24:
00004660  4A2E FFD3 8090          tst.b     -45(A6)
00004664  671A      8091          beq.s     vsprintf_36
00004666  4878 000A 8092          pea       10
0000466A  2F03      8093          move.l    D3,-(A7)
0000466C  206E 0010 8094          move.l    16(A6),A0
00004670  58AE 0010 8095          addq.l    #4,16(A6)
00004674  2F10      8096          move.l    (A0),-(A7)
00004676  6100 04F8 8097          bsr       _ltoa
0000467A  DEFC 000C 8098          add.w     #12,A7
0000467E  6018      8099          bra.s     vsprintf_37
                    8100   vsprintf_36:
00004680  4878 000A 8101          pea       10
00004684  2F03      8102          move.l    D3,-(A7)
00004686  206E 0010 8103          move.l    16(A6),A0
0000468A  58AE 0010 8104          addq.l    #4,16(A6)
0000468E  2F10      8105          move.l    (A0),-(A7)
00004690  6100 04DE 8106          bsr       _ltoa
00004694  DEFC 000C 8107          add.w     #12,A7
                    8108   vsprintf_37:
00004698  6000 00FA 8109          bra       vsprintf_23
                    8110   vsprintf_26:
0000469C  4A2E FFD3 8111          tst.b     -45(A6)
000046A0  6718      8112          beq.s     vsprintf_38
000046A2  4878 000A 8113          pea       10
000046A6  2F03      8114          move.l    D3,-(A7)
000046A8  206E 0010 8115          move.l    16(A6),A0
000046AC  58AE 0010 8116          addq.l    #4,16(A6)
000046B0  2F10      8117          move.l    (A0),-(A7)
000046B2  4E94      8118          jsr       (A4)
000046B4  DEFC 000C 8119          add.w     #12,A7
000046B8  6016      8120          bra.s     vsprintf_39
                    8121   vsprintf_38:
000046BA  4878 000A 8122          pea       10
000046BE  2F03      8123          move.l    D3,-(A7)
000046C0  206E 0010 8124          move.l    16(A6),A0
000046C4  58AE 0010 8125          addq.l    #4,16(A6)
000046C8  2F10      8126          move.l    (A0),-(A7)
000046CA  4E94      8127          jsr       (A4)
000046CC  DEFC 000C 8128          add.w     #12,A7
                    8129   vsprintf_39:
000046D0  6000 00C2 8130          bra       vsprintf_23
                    8131   vsprintf_27:
000046D4  4A2E FFD3 8132          tst.b     -45(A6)
000046D8  6718      8133          beq.s     vsprintf_40
000046DA  4878 0008 8134          pea       8
000046DE  2F03      8135          move.l    D3,-(A7)
000046E0  206E 0010 8136          move.l    16(A6),A0
000046E4  58AE 0010 8137          addq.l    #4,16(A6)
000046E8  2F10      8138          move.l    (A0),-(A7)
000046EA  4E94      8139          jsr       (A4)
000046EC  DEFC 000C 8140          add.w     #12,A7
000046F0  6016      8141          bra.s     vsprintf_41
                    8142   vsprintf_40:
000046F2  4878 0008 8143          pea       8
000046F6  2F03      8144          move.l    D3,-(A7)
000046F8  206E 0010 8145          move.l    16(A6),A0
000046FC  58AE 0010 8146          addq.l    #4,16(A6)
00004700  2F10      8147          move.l    (A0),-(A7)
00004702  4E94      8148          jsr       (A4)
00004704  DEFC 000C 8149          add.w     #12,A7
                    8150   vsprintf_41:
00004708  6000 008A 8151          bra       vsprintf_23
                    8152   vsprintf_28:
0000470C  4A2E FFD3 8153          tst.b     -45(A6)
00004710  6718      8154          beq.s     vsprintf_42
00004712  4878 0010 8155          pea       16
00004716  2F03      8156          move.l    D3,-(A7)
00004718  206E 0010 8157          move.l    16(A6),A0
0000471C  58AE 0010 8158          addq.l    #4,16(A6)
00004720  2F10      8159          move.l    (A0),-(A7)
00004722  4E94      8160          jsr       (A4)
00004724  DEFC 000C 8161          add.w     #12,A7
00004728  6016      8162          bra.s     vsprintf_43
                    8163   vsprintf_42:
0000472A  4878 0010 8164          pea       16
0000472E  2F03      8165          move.l    D3,-(A7)
00004730  206E 0010 8166          move.l    16(A6),A0
00004734  58AE 0010 8167          addq.l    #4,16(A6)
00004738  2F10      8168          move.l    (A0),-(A7)
0000473A  4E94      8169          jsr       (A4)
0000473C  DEFC 000C 8170          add.w     #12,A7
                    8171   vsprintf_43:
00004740  6000 0052 8172          bra       vsprintf_23
                    8173   vsprintf_30:
00004744  206E 0010 8174          move.l    16(A6),A0
00004748  58AE 0010 8175          addq.l    #4,16(A6)
0000474C  2010      8176          move.l    (A0),D0
0000474E  2042      8177          move.l    D2,A0
00004750  5282      8178          addq.l    #1,D2
00004752  1080      8179          move.b    D0,(A0)
00004754  2042      8180          move.l    D2,A0
00004756  4210      8181          clr.b     (A0)
00004758  200D      8182          move.l    A5,D0
0000475A  6704      8183          beq.s     vsprintf_44
0000475C  200D      8184          move.l    A5,D0
0000475E  6002      8185          bra.s     vsprintf_45
                    8186   vsprintf_44:
00004760  7001      8187          moveq     #1,D0
                    8188   vsprintf_45:
00004762  2A00      8189          move.l    D0,D5
00004764  6000 002E 8190          bra       vsprintf_23
                    8191   vsprintf_31:
00004768  206E 0010 8192          move.l    16(A6),A0
0000476C  58AE 0010 8193          addq.l    #4,16(A6)
00004770  2610      8194          move.l    (A0),D3
00004772  0C85 FFFF 8195          cmp.l     #-1,D5
00004776  FFFF      
00004778  660A      8196          bne.s     vsprintf_46
0000477A  2F03      8197          move.l    D3,-(A7)
0000477C  6100 0578 8198          bsr       _strlen
00004780  584F      8199          addq.w    #4,A7
00004782  2A00      8200          move.l    D0,D5
                    8201   vsprintf_46:
00004784  600E      8202          bra.s     vsprintf_23
                    8203   vsprintf_22:
00004786  206E 000C 8204          move.l    12(A6),A0
0000478A  2242      8205          move.l    D2,A1
0000478C  5282      8206          addq.l    #1,D2
0000478E  1290      8207          move.b    (A0),(A1)
00004790  2042      8208          move.l    D2,A0
00004792  4210      8209          clr.b     (A0)
                    8210   vsprintf_23:
00004794  2F03      8211          move.l    D3,-(A7)
00004796  6100 055E 8212          bsr       _strlen
0000479A  584F      8213          addq.w    #4,A7
0000479C  1800      8214          move.b    D0,D4
0000479E  206E 000C 8215          move.l    12(A6),A0
000047A2  1010      8216          move.b    (A0),D0
000047A4  4880      8217          ext.w     D0
000047A6  48C0      8218          ext.l     D0
000047A8  0C80 0000 8219          cmp.l     #115,D0
000047AC  0073      
000047AE  6618      8220          bne.s     vsprintf_48
000047B0  0C85 0000 8221          cmp.l     #0,D5
000047B4  0000      
000047B6  6D10      8222          blt.s     vsprintf_48
000047B8  4884      8223          ext.w     D4
000047BA  48C4      8224          ext.l     D4
000047BC  B885      8225          cmp.l     D5,D4
000047BE  6F04      8226          ble.s     vsprintf_50
000047C0  1005      8227          move.b    D5,D0
000047C2  6002      8228          bra.s     vsprintf_51
                    8229   vsprintf_50:
000047C4  1004      8230          move.b    D4,D0
                    8231   vsprintf_51:
000047C6  1800      8232          move.b    D0,D4
                    8233   vsprintf_48:
000047C8  206E 000C 8234          move.l    12(A6),A0
000047CC  1010      8235          move.b    (A0),D0
000047CE  4880      8236          ext.w     D0
000047D0  48C0      8237          ext.l     D0
000047D2  0C80 0000 8238          cmp.l     #88,D0
000047D6  0058      
000047D8  6600 0026 8239          bne       vsprintf_56
000047DC  41EE FFDC 8240          lea       -36(A6),A0
000047E0  2408      8241          move.l    A0,D2
                    8242   vsprintf_54:
000047E2  2042      8243          move.l    D2,A0
000047E4  4A10      8244          tst.b     (A0)
000047E6  6718      8245          beq.s     vsprintf_56
000047E8  2042      8246          move.l    D2,A0
000047EA  1210      8247          move.b    (A0),D1
000047EC  4881      8248          ext.w     D1
000047EE  48C1      8249          ext.l     D1
000047F0  2F01      8250          move.l    D1,-(A7)
000047F2  6100 FB98 8251          bsr       _toupper
000047F6  584F      8252          addq.w    #4,A7
000047F8  2042      8253          move.l    D2,A0
000047FA  1080      8254          move.b    D0,(A0)
000047FC  5282      8255          addq.l    #1,D2
000047FE  60E2      8256          bra       vsprintf_54
                    8257   vsprintf_56:
00004800  7E00      8258          moveq     #0,D7
00004802  41EE FFD4 8259          lea       -44(A6),A0
00004806  2408      8260          move.l    A0,D2
00004808  206E 000C 8261          move.l    12(A6),A0
0000480C  1010      8262          move.b    (A0),D0
0000480E  4880      8263          ext.w     D0
00004810  48C0      8264          ext.l     D0
00004812  0C80 0000 8265          cmp.l     #100,D0
00004816  0064      
00004818  6714      8266          beq.s     vsprintf_59
0000481A  206E 000C 8267          move.l    12(A6),A0
0000481E  1010      8268          move.b    (A0),D0
00004820  4880      8269          ext.w     D0
00004822  48C0      8270          ext.l     D0
00004824  0C80 0000 8271          cmp.l     #105,D0
00004828  0069      
0000482A  6600 0076 8272          bne       vsprintf_65
                    8273   vsprintf_59:
0000482E  4A2E FFCE 8274          tst.b     -50(A6)
00004832  6612      8275          bne.s     vsprintf_62
00004834  2043      8276          move.l    D3,A0
00004836  1010      8277          move.b    (A0),D0
00004838  4880      8278          ext.w     D0
0000483A  48C0      8279          ext.l     D0
0000483C  0C80 0000 8280          cmp.l     #45,D0
00004840  002D      
00004842  6600 002E 8281          bne       vsprintf_60
                    8282   vsprintf_62:
00004846  2043      8283          move.l    D3,A0
00004848  1010      8284          move.b    (A0),D0
0000484A  4880      8285          ext.w     D0
0000484C  48C0      8286          ext.l     D0
0000484E  0C80 0000 8287          cmp.l     #45,D0
00004852  002D      
00004854  660E      8288          bne.s     vsprintf_63
00004856  2043      8289          move.l    D3,A0
00004858  5283      8290          addq.l    #1,D3
0000485A  2242      8291          move.l    D2,A1
0000485C  5282      8292          addq.l    #1,D2
0000485E  1290      8293          move.b    (A0),(A1)
00004860  5304      8294          subq.b    #1,D4
00004862  6008      8295          bra.s     vsprintf_64
                    8296   vsprintf_63:
00004864  2042      8297          move.l    D2,A0
00004866  5282      8298          addq.l    #1,D2
00004868  10BC 002B 8299          move.b    #43,(A0)
                    8300   vsprintf_64:
0000486C  5287      8301          addq.l    #1,D7
0000486E  6000 0032 8302          bra       vsprintf_65
                    8303   vsprintf_60:
00004872  4A2E FFCF 8304          tst.b     -49(A6)
00004876  6700 002A 8305          beq       vsprintf_65
0000487A  2043      8306          move.l    D3,A0
0000487C  1010      8307          move.b    (A0),D0
0000487E  4880      8308          ext.w     D0
00004880  48C0      8309          ext.l     D0
00004882  0C80 0000 8310          cmp.l     #45,D0
00004886  002D      
00004888  660E      8311          bne.s     vsprintf_67
0000488A  2043      8312          move.l    D3,A0
0000488C  5283      8313          addq.l    #1,D3
0000488E  2242      8314          move.l    D2,A1
00004890  5282      8315          addq.l    #1,D2
00004892  1290      8316          move.b    (A0),(A1)
00004894  5304      8317          subq.b    #1,D4
00004896  6008      8318          bra.s     vsprintf_68
                    8319   vsprintf_67:
00004898  2042      8320          move.l    D2,A0
0000489A  5282      8321          addq.l    #1,D2
0000489C  10BC 0020 8322          move.b    #32,(A0)
                    8323   vsprintf_68:
000048A0  5287      8324          addq.l    #1,D7
                    8325   vsprintf_65:
000048A2  4A2E FFD0 8326          tst.b     -48(A6)
000048A6  6700 0066 8327          beq       vsprintf_77
000048AA  206E 000C 8328          move.l    12(A6),A0
000048AE  1010      8329          move.b    (A0),D0
000048B0  4880      8330          ext.w     D0
000048B2  48C0      8331          ext.l     D0
000048B4  0C80 0000 8332          cmp.l     #111,D0
000048B8  006F      
000048BA  671A      8333          beq.s     vsprintf_73
000048BC  6E0C      8334          bgt.s     vsprintf_76
000048BE  0C80 0000 8335          cmp.l     #88,D0
000048C2  0058      
000048C4  6710      8336          beq.s     vsprintf_73
000048C6  6000 0046 8337          bra       vsprintf_77
                    8338   vsprintf_76:
000048CA  0C80 0000 8339          cmp.l     #120,D0
000048CE  0078      
000048D0  6704      8340          beq.s     vsprintf_73
000048D2  6000 003A 8341          bra       vsprintf_77
                    8342   vsprintf_73:
000048D6  2042      8343          move.l    D2,A0
000048D8  5282      8344          addq.l    #1,D2
000048DA  10BC 0030 8345          move.b    #48,(A0)
000048DE  5287      8346          addq.l    #1,D7
000048E0  206E 000C 8347          move.l    12(A6),A0
000048E4  1010      8348          move.b    (A0),D0
000048E6  4880      8349          ext.w     D0
000048E8  48C0      8350          ext.l     D0
000048EA  0C80 0000 8351          cmp.l     #120,D0
000048EE  0078      
000048F0  6712      8352          beq.s     vsprintf_79
000048F2  206E 000C 8353          move.l    12(A6),A0
000048F6  1010      8354          move.b    (A0),D0
000048F8  4880      8355          ext.w     D0
000048FA  48C0      8356          ext.l     D0
000048FC  0C80 0000 8357          cmp.l     #88,D0
00004900  0058      
00004902  660A      8358          bne.s     vsprintf_77
                    8359   vsprintf_79:
00004904  2042      8360          move.l    D2,A0
00004906  5282      8361          addq.l    #1,D2
00004908  10BC 0078 8362          move.b    #120,(A0)
0000490C  5287      8363          addq.l    #1,D7
                    8364   vsprintf_77:
0000490E  2042      8365          move.l    D2,A0
00004910  4210      8366          clr.b     (A0)
00004912  206E 000C 8367          move.l    12(A6),A0
00004916  1010      8368          move.b    (A0),D0
00004918  4880      8369          ext.w     D0
0000491A  48C0      8370          ext.l     D0
0000491C  0C80 0000 8371          cmp.l     #105,D0
00004920  0069      
00004922  6700 0076 8372          beq       vsprintf_82
00004926  6E42      8373          bgt.s     vsprintf_93
00004928  0C80 0000 8374          cmp.l     #99,D0
0000492C  0063      
0000492E  6700 0084 8375          beq       vsprintf_96
00004932  6E1C      8376          bgt.s     vsprintf_94
00004934  0C80 0000 8377          cmp.l     #88,D0
00004938  0058      
0000493A  6700 005E 8378          beq       vsprintf_82
0000493E  6E00 0184 8379          bgt       vsprintf_80
00004942  0C80 0000 8380          cmp.l     #69,D0
00004946  0045      
00004948  6700 0050 8381          beq       vsprintf_82
0000494C  6000 0176 8382          bra       vsprintf_80
                    8383   vsprintf_94:
00004950  0C80 0000 8384          cmp.l     #101,D0
00004954  0065      
00004956  6700 0042 8385          beq       vsprintf_82
0000495A  6E00 0168 8386          bgt       vsprintf_80
0000495E  0C80 0000 8387          cmp.l     #100,D0
00004962  0064      
00004964  6734      8388          beq.s     vsprintf_82
00004966  6000 015C 8389          bra       vsprintf_80
                    8390   vsprintf_93:
0000496A  0C80 0000 8391          cmp.l     #117,D0
0000496E  0075      
00004970  6728      8392          beq.s     vsprintf_82
00004972  6E1A      8393          bgt.s     vsprintf_95
00004974  0C80 0000 8394          cmp.l     #115,D0
00004978  0073      
0000497A  6700 0038 8395          beq       vsprintf_96
0000497E  6E00 0144 8396          bgt       vsprintf_80
00004982  0C80 0000 8397          cmp.l     #111,D0
00004986  006F      
00004988  6710      8398          beq.s     vsprintf_82
0000498A  6000 0138 8399          bra       vsprintf_80
                    8400   vsprintf_95:
0000498E  0C80 0000 8401          cmp.l     #120,D0
00004992  0078      
00004994  6704      8402          beq.s     vsprintf_82
00004996  6000 012C 8403          bra       vsprintf_80
                    8404   vsprintf_82:
0000499A  4A2E FFD2 8405          tst.b     -46(A6)
0000499E  6714      8406          beq.s     vsprintf_96
000049A0  4A2E FFCD 8407          tst.b     -51(A6)
000049A4  660E      8408          bne.s     vsprintf_96
000049A6  200D      8409          move.l    A5,D0
000049A8  9087      8410          sub.l     D7,D0
000049AA  4884      8411          ext.w     D4
000049AC  48C4      8412          ext.l     D4
000049AE  9084      8413          sub.l     D4,D0
000049B0  2D40 FFFC 8414          move.l    D0,-4(A6)
                    8415   vsprintf_96:
000049B4  202E FFFC 8416          move.l    -4(A6),D0
000049B8  0C80 0000 8417          cmp.l     #0,D0
000049BC  0000      
000049BE  6C04      8418          bge.s     vsprintf_98
000049C0  42AE FFFC 8419          clr.l     -4(A6)
                    8420   vsprintf_98:
000049C4  4A2E FFCD 8421          tst.b     -51(A6)
000049C8  6600 0030 8422          bne       vsprintf_104
000049CC  4884      8423          ext.w     D4
000049CE  48C4      8424          ext.l     D4
000049D0  2004      8425          move.l    D4,D0
000049D2  D0AE FFFC 8426          add.l     -4(A6),D0
000049D6  D087      8427          add.l     D7,D0
000049D8  1D40 FFD1 8428          move.b    D0,-47(A6)
                    8429   vsprintf_102:
000049DC  102E FFD1 8430          move.b    -47(A6),D0
000049E0  4880      8431          ext.w     D0
000049E2  48C0      8432          ext.l     D0
000049E4  220D      8433          move.l    A5,D1
000049E6  534D      8434          subq.w    #1,A5
000049E8  B081      8435          cmp.l     D1,D0
000049EA  6C0E      8436          bge.s     vsprintf_104
000049EC  4878 0020 8437          pea       32
000049F0  2F0A      8438          move.l    A2,-(A7)
000049F2  4E93      8439          jsr       (A3)
000049F4  504F      8440          addq.w    #8,A7
000049F6  5286      8441          addq.l    #1,D6
000049F8  60E2      8442          bra       vsprintf_102
                    8443   vsprintf_104:
000049FA  41EE FFD4 8444          lea       -44(A6),A0
000049FE  2408      8445          move.l    A0,D2
                    8446   vsprintf_105:
00004A00  2042      8447          move.l    D2,A0
00004A02  4A10      8448          tst.b     (A0)
00004A04  6716      8449          beq.s     vsprintf_107
00004A06  2042      8450          move.l    D2,A0
00004A08  5282      8451          addq.l    #1,D2
00004A0A  1210      8452          move.b    (A0),D1
00004A0C  4881      8453          ext.w     D1
00004A0E  48C1      8454          ext.l     D1
00004A10  2F01      8455          move.l    D1,-(A7)
00004A12  2F0A      8456          move.l    A2,-(A7)
00004A14  4E93      8457          jsr       (A3)
00004A16  504F      8458          addq.w    #8,A7
00004A18  5286      8459          addq.l    #1,D6
00004A1A  60E4      8460          bra       vsprintf_105
                    8461   vsprintf_107:
00004A1C  202E FFFC 8462          move.l    -4(A6),D0
00004A20  1D40 FFD1 8463          move.b    D0,-47(A6)
                    8464   vsprintf_108:
00004A24  102E FFD1 8465          move.b    -47(A6),D0
00004A28  532E FFD1 8466          subq.b    #1,-47(A6)
00004A2C  4A00      8467          tst.b     D0
00004A2E  670E      8468          beq.s     vsprintf_110
00004A30  4878 0030 8469          pea       48
00004A34  2F0A      8470          move.l    A2,-(A7)
00004A36  4E93      8471          jsr       (A3)
00004A38  504F      8472          addq.w    #8,A7
00004A3A  5286      8473          addq.l    #1,D6
00004A3C  60E6      8474          bra       vsprintf_108
                    8475   vsprintf_110:
00004A3E  2043      8476          move.l    D3,A0
00004A40  4A10      8477          tst.b     (A0)
00004A42  6700 0048 8478          beq       vsprintf_113
00004A46  206E 000C 8479          move.l    12(A6),A0
00004A4A  1010      8480          move.b    (A0),D0
00004A4C  4880      8481          ext.w     D0
00004A4E  48C0      8482          ext.l     D0
00004A50  0C80 0000 8483          cmp.l     #115,D0
00004A54  0073      
00004A56  670C      8484          beq.s     vsprintf_116
00004A58  6E18      8485          bgt.s     vsprintf_119
00004A5A  0C80 0000 8486          cmp.l     #99,D0
00004A5E  0063      
00004A60  6702      8487          beq.s     vsprintf_116
00004A62  600E      8488          bra.s     vsprintf_119
                    8489   vsprintf_116:
00004A64  2005      8490          move.l    D5,D0
00004A66  5385      8491          subq.l    #1,D5
00004A68  0C80 0000 8492          cmp.l     #0,D0
00004A6C  0000      
00004A6E  6E02      8493          bgt.s     vsprintf_119
00004A70  6016      8494          bra.s     vsprintf_115
                    8495   vsprintf_119:
00004A72  2043      8496          move.l    D3,A0
00004A74  5283      8497          addq.l    #1,D3
00004A76  1210      8498          move.b    (A0),D1
00004A78  4881      8499          ext.w     D1
00004A7A  48C1      8500          ext.l     D1
00004A7C  2F01      8501          move.l    D1,-(A7)
00004A7E  2F0A      8502          move.l    A2,-(A7)
00004A80  4E93      8503          jsr       (A3)
00004A82  504F      8504          addq.w    #8,A7
00004A84  5286      8505          addq.l    #1,D6
00004A86  6002      8506          bra.s     vsprintf_112
                    8507   vsprintf_115:
00004A88  6002      8508          bra.s     vsprintf_113
                    8509   vsprintf_112:
00004A8A  60B2      8510          bra       vsprintf_110
                    8511   vsprintf_113:
00004A8C  4A2E FFCD 8512          tst.b     -51(A6)
00004A90  6700 0030 8513          beq       vsprintf_125
00004A94  4884      8514          ext.w     D4
00004A96  48C4      8515          ext.l     D4
00004A98  2004      8516          move.l    D4,D0
00004A9A  D0AE FFFC 8517          add.l     -4(A6),D0
00004A9E  D087      8518          add.l     D7,D0
00004AA0  1D40 FFD1 8519          move.b    D0,-47(A6)
                    8520   vsprintf_123:
00004AA4  102E FFD1 8521          move.b    -47(A6),D0
00004AA8  4880      8522          ext.w     D0
00004AAA  48C0      8523          ext.l     D0
00004AAC  220D      8524          move.l    A5,D1
00004AAE  534D      8525          subq.w    #1,A5
00004AB0  B081      8526          cmp.l     D1,D0
00004AB2  6C0E      8527          bge.s     vsprintf_125
00004AB4  4878 0020 8528          pea       32
00004AB8  2F0A      8529          move.l    A2,-(A7)
00004ABA  4E93      8530          jsr       (A3)
00004ABC  504F      8531          addq.w    #8,A7
00004ABE  5386      8532          subq.l    #1,D6
00004AC0  60E2      8533          bra       vsprintf_123
                    8534   vsprintf_125:
00004AC2  6014      8535          bra.s     vsprintf_81
                    8536   vsprintf_80:
00004AC4  206E 000C 8537          move.l    12(A6),A0
00004AC8  1210      8538          move.b    (A0),D1
00004ACA  4881      8539          ext.w     D1
00004ACC  48C1      8540          ext.l     D1
00004ACE  2F01      8541          move.l    D1,-(A7)
00004AD0  2F0A      8542          move.l    A2,-(A7)
00004AD2  4E93      8543          jsr       (A3)
00004AD4  504F      8544          addq.w    #8,A7
00004AD6  5286      8545          addq.l    #1,D6
                    8546   vsprintf_81:
00004AD8  52AE 000C 8547          addq.l    #1,12(A6)
                    8548   vsprintf_2:
00004ADC  6000 F9D6 8549          bra       vsprintf_1
                    8550   vsprintf_3:
00004AE0  4A92      8551          tst.l     (A2)
00004AE2  6710      8552          beq.s     vsprintf_126
00004AE4  4201      8553          clr.b     D1
00004AE6  C2BC 0000 8554          and.l     #255,D1
00004AEA  00FF      
00004AEC  2F01      8555          move.l    D1,-(A7)
00004AEE  2F0A      8556          move.l    A2,-(A7)
00004AF0  4E93      8557          jsr       (A3)
00004AF2  504F      8558          addq.w    #8,A7
                    8559   vsprintf_126:
00004AF4  2006      8560          move.l    D6,D0
00004AF6  4CDF 3CFC 8561          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00004AFA  4E5E      8562          unlk      A6
00004AFC  4E75      8563          rts
                    8564   @itoa_convert:
00004AFE  4E56 0000 8565          link      A6,#0
00004B02  48E7 3C00 8566          movem.l   D2/D3/D4/D5,-(A7)
00004B06  242E 0008 8567          move.l    8(A6),D2
00004B0A  262E 0010 8568          move.l    16(A6),D3
00004B0E  2A2E 000C 8569          move.l    12(A6),D5
00004B12  2F05      8570          move.l    D5,-(A7)
00004B14  2F03      8571          move.l    D3,-(A7)
00004B16  6100 F6B4 8572          bsr       ULDIV
00004B1A  202F 0004 8573          move.l    4(A7),D0
00004B1E  504F      8574          addq.w    #8,A7
00004B20  2800      8575          move.l    D0,D4
00004B22  BA83      8576          cmp.l     D3,D5
00004B24  651A      8577          blo.s     @itoa_convert_1
00004B26  2F03      8578          move.l    D3,-(A7)
00004B28  2F05      8579          move.l    D5,-(A7)
00004B2A  2F03      8580          move.l    D3,-(A7)
00004B2C  6100 F69E 8581          bsr       ULDIV
00004B30  2217      8582          move.l    (A7),D1
00004B32  504F      8583          addq.w    #8,A7
00004B34  2F01      8584          move.l    D1,-(A7)
00004B36  2F02      8585          move.l    D2,-(A7)
00004B38  61C4      8586          bsr       @itoa_convert
00004B3A  DEFC 000C 8587          add.w     #12,A7
00004B3E  2400      8588          move.l    D0,D2
                    8589   @itoa_convert_1:
00004B40  0C84 0000 8590          cmp.l     #9,D4
00004B44  0009      
00004B46  6E0A      8591          bgt.s     @itoa_convert_3
00004B48  2004      8592          move.l    D4,D0
00004B4A  0680 0000 8593          add.l     #48,D0
00004B4E  0030      
00004B50  600E      8594          bra.s     @itoa_convert_4
                    8595   @itoa_convert_3:
00004B52  2004      8596          move.l    D4,D0
00004B54  0680 0000 8597          add.l     #97,D0
00004B58  0061      
00004B5A  0480 0000 8598          sub.l     #10,D0
00004B5E  000A      
                    8599   @itoa_convert_4:
00004B60  2042      8600          move.l    D2,A0
00004B62  1080      8601          move.b    D0,(A0)
00004B64  2002      8602          move.l    D2,D0
00004B66  5280      8603          addq.l    #1,D0
00004B68  4CDF 003C 8604          movem.l   (A7)+,D2/D3/D4/D5
00004B6C  4E5E      8605          unlk      A6
00004B6E  4E75      8606          rts
                    8607   _ltoa:
00004B70  4E56 0000 8608          link      A6,#0
00004B74  48E7 3C00 8609          movem.l   D2/D3/D4/D5,-(A7)
00004B78  242E 0008 8610          move.l    8(A6),D2
00004B7C  262E 000C 8611          move.l    12(A6),D3
00004B80  2A2E 0010 8612          move.l    16(A6),D5
00004B84  2803      8613          move.l    D3,D4
00004B86  0C85 0000 8614          cmp.l     #2,D5
00004B8A  0002      
00004B8C  6D08      8615          blt.s     ltoa_3
00004B8E  0C85 0000 8616          cmp.l     #36,D5
00004B92  0024      
00004B94  6F06      8617          ble.s     ltoa_1
                    8618   ltoa_3:
00004B96  2003      8619          move.l    D3,D0
00004B98  6000 0052 8620          bra       ltoa_4
                    8621   ltoa_1:
00004B9C  0C85 0000 8622          cmp.l     #10,D5
00004BA0  000A      
00004BA2  6600 0032 8623          bne       ltoa_5
00004BA6  0C82 0000 8624          cmp.l     #0,D2
00004BAA  0000      
00004BAC  6C28      8625          bge.s     ltoa_5
00004BAE  2002      8626          move.l    D2,D0
00004BB0  4480      8627          neg.l     D0
00004BB2  2400      8628          move.l    D0,D2
00004BB4  0C82 0000 8629          cmp.l     #0,D2
00004BB8  0000      
00004BBA  6C12      8630          bge.s     ltoa_7
00004BBC  4879 0000 8631          pea       @itoa_1
00004BC0  6ACA      
00004BC2  2F03      8632          move.l    D3,-(A7)
00004BC4  6100 F5F6 8633          bsr       _strcpy
00004BC8  504F      8634          addq.w    #8,A7
00004BCA  2003      8635          move.l    D3,D0
00004BCC  601E      8636          bra.s     ltoa_4
                    8637   ltoa_7:
00004BCE  2044      8638          move.l    D4,A0
00004BD0  5284      8639          addq.l    #1,D4
00004BD2  10BC 002D 8640          move.b    #45,(A0)
                    8641   ltoa_5:
00004BD6  2F05      8642          move.l    D5,-(A7)
00004BD8  2F02      8643          move.l    D2,-(A7)
00004BDA  2F04      8644          move.l    D4,-(A7)
00004BDC  6100 FF20 8645          bsr       @itoa_convert
00004BE0  DEFC 000C 8646          add.w     #12,A7
00004BE4  2800      8647          move.l    D0,D4
00004BE6  2044      8648          move.l    D4,A0
00004BE8  4210      8649          clr.b     (A0)
00004BEA  2003      8650          move.l    D3,D0
                    8651   ltoa_4:
00004BEC  4CDF 003C 8652          movem.l   (A7)+,D2/D3/D4/D5
00004BF0  4E5E      8653          unlk      A6
00004BF2  4E75      8654          rts
                    8655   _ultoa:
00004BF4  4E56 0000 8656          link      A6,#0
00004BF8  48E7 3800 8657          movem.l   D2/D3/D4,-(A7)
00004BFC  262E 0010 8658          move.l    16(A6),D3
00004C00  282E 000C 8659          move.l    12(A6),D4
00004C04  2404      8660          move.l    D4,D2
00004C06  0C83 0000 8661          cmp.l     #2,D3
00004C0A  0002      
00004C0C  6D08      8662          blt.s     ultoa_3
00004C0E  0C83 0000 8663          cmp.l     #36,D3
00004C12  0024      
00004C14  6F04      8664          ble.s     ultoa_1
                    8665   ultoa_3:
00004C16  2004      8666          move.l    D4,D0
00004C18  6018      8667          bra.s     ultoa_4
                    8668   ultoa_1:
00004C1A  2F03      8669          move.l    D3,-(A7)
00004C1C  2F2E 0008 8670          move.l    8(A6),-(A7)
00004C20  2F02      8671          move.l    D2,-(A7)
00004C22  6100 FEDA 8672          bsr       @itoa_convert
00004C26  DEFC 000C 8673          add.w     #12,A7
00004C2A  2400      8674          move.l    D0,D2
00004C2C  2042      8675          move.l    D2,A0
00004C2E  4210      8676          clr.b     (A0)
00004C30  2004      8677          move.l    D4,D0
                    8678   ultoa_4:
00004C32  4CDF 001C 8679          movem.l   (A7)+,D2/D3/D4
00004C36  4E5E      8680          unlk      A6
00004C38  4E75      8681          rts
                    8682   _itoa:
00004C3A  4E56 0000 8683          link      A6,#0
00004C3E  2F2E 0010 8684          move.l    16(A6),-(A7)
00004C42  2F2E 000C 8685          move.l    12(A6),-(A7)
00004C46  2F2E 0008 8686          move.l    8(A6),-(A7)
00004C4A  6100 FF24 8687          bsr       _ltoa
00004C4E  DEFC 000C 8688          add.w     #12,A7
00004C52  4E5E      8689          unlk      A6
00004C54  4E75      8690          rts
                    8691   ULMUL:
00004C56  4E56 0000 8692          link    A6,#0
00004C5A  48E7 C000 8693          movem.l D0/D1,-(A7)
00004C5E  222E 0008 8694          move.l  8(A6),D1
00004C62  202E 000C 8695          move.l  12(A6),D0
00004C66  602C      8696          bra.s   lmul_3
                    8697   LMUL:
00004C68  4E56 0000 8698          link    A6,#0
00004C6C  48E7 C000 8699          movem.l D0/D1,-(A7)
00004C70  222E 0008 8700          move.l  8(A6),D1
00004C74  202E 000C 8701          move.l  12(A6),D0
00004C78  4A80      8702          tst.l   D0
00004C7A  6A0A      8703          bpl.s   lmul_1
00004C7C  4480      8704          neg.l   D0
00004C7E  4A81      8705          tst.l   D1
00004C80  6A0A      8706          bpl.s   lmul_2
00004C82  4481      8707          neg.l   D1
00004C84  600E      8708          bra.s   lmul_3
                    8709   lmul_1:
00004C86  4A81      8710          tst.l   D1
00004C88  6A0A      8711          bpl.s   lmul_3
00004C8A  4481      8712          neg.l   D1
                    8713   lmul_2:
00004C8C  6114      8714          bsr.s   domul
00004C8E  4481      8715          neg.l   D1
00004C90  4080      8716          negx.l  D0
00004C92  6002      8717          bra.s   lmul_4
                    8718   lmul_3:
00004C94  610C      8719          bsr.s   domul
                    8720   lmul_4:
00004C96  2D41 0008 8721          move.l  D1,8(A6)
00004C9A  4CDF 0003 8722          movem.l (A7)+,D0/D1
00004C9E  4E5E      8723          unlk    A6
00004CA0  4E75      8724          rts
                    8725   domul:
00004CA2  0C81 0000 8726          cmpi.l  #$FFFF,D1
00004CA6  FFFF      
00004CA8  620C      8727          bhi.s   domul_1
00004CAA  0C80 0000 8728          cmpi.l  #$FFFF,D0
00004CAE  FFFF      
00004CB0  620E      8729          bhi.s   domul_2
00004CB2  C2C0      8730          mulu    D0,D1
00004CB4  4E75      8731          rts
                    8732   domul_1:
00004CB6  0C80 0000 8733          cmpi.l  #$FFFF,D0
00004CBA  FFFF      
00004CBC  6218      8734          bhi.s   domul_4
00004CBE  6002      8735          bra.s   domul_3
                    8736   domul_2
00004CC0  C141      8737          exg     D0,D1
                    8738   domul_3:
00004CC2  2F02      8739          move.l  D2,-(A7)
00004CC4  2401      8740          move.l  D1,D2
00004CC6  4842      8741          swap    D2
00004CC8  C2C0      8742          mulu    D0,D1
00004CCA  C4C0      8743          mulu    D0,D2
00004CCC  4842      8744          swap    D2
00004CCE  4242      8745          clr.w   D2
00004CD0  D282      8746          add.l   D2,D1
00004CD2  241F      8747          move.l  (A7)+,D2
00004CD4  4E75      8748          rts
                    8749   domul_4:
00004CD6  48E7 3000 8750          movem.l D2/D3,-(A7)
00004CDA  2401      8751          move.l  D1,D2
00004CDC  2601      8752          move.l  D1,D3
00004CDE  C2C0      8753          mulu    D0,D1
00004CE0  4842      8754          swap    D2
00004CE2  C4C0      8755          mulu    D0,D2
00004CE4  4840      8756          swap    D0
00004CE6  C6C0      8757          mulu    D0,D3
00004CE8  D483      8758          add.l   D3,D2
00004CEA  4842      8759          swap    D2
00004CEC  4242      8760          clr.w   D2
00004CEE  D282      8761          add.l   D2,D1
00004CF0  4CDF 000C 8762          movem.l (A7)+,D2/D3
00004CF4  4E75      8763          rts
                    8764   _strlen:
00004CF6  206F 0004 8765          move.l    (4,A7),A0
00004CFA  2248      8766          move.l    A0,A1
                    8767   strlen_1:
00004CFC  4A19      8768          tst.b     (A1)+
00004CFE  66FC      8769          bne       strlen_1
00004D00  2009      8770          move.l    A1,D0
00004D02  9088      8771          sub.l     A0,D0
00004D04  5380      8772          subq.l    #1,D0
00004D06  4E75      8773          rts
                    8774          section   const
                    8775   
                    8776   @lab6b_1:
00004D08  0D0A 00   8777          dc.b      13,10,0
                    8778   @lab6b_2:
00004D0C  0D53 7769 8779          dc.b      13,83,119,105,116,99,104,101,115,32,83,87,91
00004D10  7463 6865 
00004D14  7320 5357 
00004D18  5B        
00004D19  372D 305D 8780          dc.b      55,45,48,93,32,61,32,0
00004D1D  203D 2000 
                    8781   @lab6b_3:
00004D22  3000      8782          dc.b      48,0
                    8783   @lab6b_4:
00004D24  3100      8784          dc.b      49,0
                    8785   @lab6b_5:
00004D26  0D0A 4475 8786          dc.b      13,10,68,117,109,112,32,77,101,109,111,114,121
00004D2A  6D70 204D 
00004D2E  656D 6F72 
00004D32  79        
00004D33  2042 6C6F 8787          dc.b      32,66,108,111,99,107,58,32,60,69,83,67,62,32
00004D37  636B 3A20 
00004D3B  3C45 5343 
00004D3F  3E20      
00004D41  746F 2041 8788          dc.b      116,111,32,65,98,111,114,116,44,32,60,83,80
00004D45  626F 7274 
00004D49  2C20 3C53 
00004D4D  50        
00004D4E  4143 453E 8789          dc.b      65,67,69,62,32,116,111,32,67,111,110,116,105
00004D52  2074 6F20 
00004D56  436F 6E74 
00004D5A  69        
00004D5B  6E75 6500 8790          dc.b      110,117,101,0
                    8791   @lab6b_6:
00004D60  0D0A 456E 8792          dc.b      13,10,69,110,116,101,114,32,83,116,97,114,116
00004D64  7465 7220 
00004D68  5374 6172 
00004D6C  74        
00004D6D  2041 6464 8793          dc.b      32,65,100,100,114,101,115,115,58,32,0
00004D71  7265 7373 
00004D75  3A20 00   
                    8794   @lab6b_7:
00004D78  0D0A 2530 8795          dc.b      13,10,37,48,56,120,32,0
00004D7C  3878 2000 
                    8796   @lab6b_8:
00004D80  2530 3258 8797          dc.b      37,48,50,88,0
00004D84  00        
                    8798   @lab6b_9:
00004D86  2020 00   8799          dc.b      32,32,0
                    8800   @lab6b_10:
00004D8A  0D0A 4669 8801          dc.b      13,10,70,105,108,108,32,77,101,109,111,114,121
00004D8E  6C6C 204D 
00004D92  656D 6F72 
00004D96  79        
00004D97  2042 6C6F 8802          dc.b      32,66,108,111,99,107,0
00004D9B  636B 00   
                    8803   @lab6b_11:
00004D9E  0D0A 456E 8804          dc.b      13,10,69,110,116,101,114,32,69,110,100,32,65
00004DA2  7465 7220 
00004DA6  456E 6420 
00004DAA  41        
00004DAB  6464 7265 8805          dc.b      100,100,114,101,115,115,58,32,0
00004DAF  7373 3A20 
00004DB3  00        
                    8806   @lab6b_12:
00004DB4  0D0A 456E 8807          dc.b      13,10,69,110,116,101,114,32,70,105,108,108,32
00004DB8  7465 7220 
00004DBC  4669 6C6C 
00004DC0  20        
00004DC1  4461 7461 8808          dc.b      68,97,116,97,58,32,0
00004DC5  3A20 00   
                    8809   @lab6b_13:
00004DC8  0D0A 4669 8810          dc.b      13,10,70,105,108,108,105,110,103,32,65,100,100
00004DCC  6C6C 696E 
00004DD0  6720 4164 
00004DD4  64        
00004DD5  7265 7373 8811          dc.b      114,101,115,115,101,115,32,91,36,37,48,56,88
00004DD9  6573 205B 
00004DDD  2425 3038 
00004DE1  58        
00004DE2  202D 2024 8812          dc.b      32,45,32,36,37,48,56,88,93,32,119,105,116,104
00004DE6  2530 3858 
00004DEA  5D20 7769 
00004DEE  7468      
00004DF0  2024 2530 8813          dc.b      32,36,37,48,50,88,0
00004DF4  3258 00   
                    8814   @lab6b_14:
00004DF8  0D0A 5573 8815          dc.b      13,10,85,115,101,32,72,121,112,101,114,84,101
00004DFC  6520 4879 
00004E00  7065 7254 
00004E04  65        
00004E05  726D 696E 8816          dc.b      114,109,105,110,97,108,32,116,111,32,83,101
00004E09  616C 2074 
00004E0D  6F20 5365 
00004E11  6E64 2054 8817          dc.b      110,100,32,84,101,120,116,32,70,105,108,101
00004E15  6578 7420 
00004E19  4669 6C65 
00004E1D  2028 2E68 8818          dc.b      32,40,46,104,101,120,41,13,10,0
00004E21  6578 290D 
00004E25  0A00      
                    8819   @lab6b_15:
00004E28  0D0A 4C6F 8820          dc.b      13,10,76,111,97,100,32,70,97,105,108,101,100
00004E2C  6164 2046 
00004E30  6169 6C65 
00004E34  64        
00004E35  2061 7420 8821          dc.b      32,97,116,32,65,100,100,114,101,115,115,32,61
00004E39  4164 6472 
00004E3D  6573 7320 
00004E41  3D        
00004E42  205B 2425 8822          dc.b      32,91,36,37,48,56,88,93,13,10,0
00004E46  3038 585D 
00004E4A  0D0A 00   
                    8823   @lab6b_16:
00004E4E  0D0A 5375 8824          dc.b      13,10,83,117,99,99,101,115,115,58,32,68,111
00004E52  6363 6573 
00004E56  733A 2044 
00004E5A  6F        
00004E5B  776E 6C6F 8825          dc.b      119,110,108,111,97,100,101,100,32,37,100,32
00004E5F  6164 6564 
00004E63  2025 6420 
00004E67  6279 7465 8826          dc.b      98,121,116,101,115,13,10,0
00004E6B  730D 0A00 
                    8827   @lab6b_17:
00004E70  0D0A 4578 8828          dc.b      13,10,69,120,97,109,105,110,101,32,97,110,100
00004E74  616D 696E 
00004E78  6520 616E 
00004E7C  64        
00004E7D  2043 6861 8829          dc.b      32,67,104,97,110,103,101,32,77,101,109,111,114
00004E81  6E67 6520 
00004E85  4D65 6D6F 
00004E89  72        
00004E8A  7900      8830          dc.b      121,0
                    8831   @lab6b_18:
00004E8C  0D0A 3C45 8832          dc.b      13,10,60,69,83,67,62,32,116,111,32,83,116,111
00004E90  5343 3E20 
00004E94  746F 2053 
00004E98  746F      
00004E9A  702C 203C 8833          dc.b      112,44,32,60,83,80,65,67,69,62,32,116,111,32
00004E9E  5350 4143 
00004EA2  453E 2074 
00004EA6  6F20      
00004EA8  4164 7661 8834          dc.b      65,100,118,97,110,99,101,44,32,39,45,39,32,116
00004EAC  6E63 652C 
00004EB0  2027 2D27 
00004EB4  2074      
00004EB6  6F20 476F 8835          dc.b      111,32,71,111,32,66,97,99,107,44,32,60,68,65
00004EBA  2042 6163 
00004EBE  6B2C 203C 
00004EC2  4441      
00004EC4  5441 3E20 8836          dc.b      84,65,62,32,116,111,32,99,104,97,110,103,101
00004EC8  746F 2063 
00004ECC  6861 6E67 
00004ED0  65        
00004ED1  00        8837          dc.b      0
                    8838   @lab6b_19:
00004ED2  0D0A 456E 8839          dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
00004ED6  7465 7220 
00004EDA  4164 6472 
00004EDE  65        
00004EDF  7373 3A20 8840          dc.b      115,115,58,32,0
00004EE3  00        
                    8841   @lab6b_20:
00004EE4  0D0A 5B25 8842          dc.b      13,10,91,37,48,56,120,93,32,58,32,37,48,50,120
00004EE8  3038 785D 
00004EEC  203A 2025 
00004EF0  3032 78   
00004EF3  2020 00   8843          dc.b      32,32,0
                    8844   @lab6b_21:
00004EF6  0D0A 5761 8845          dc.b      13,10,87,97,114,110,105,110,103,32,67,104,97
00004EFA  726E 696E 
00004EFE  6720 4368 
00004F02  61        
00004F03  6E67 6520 8846          dc.b      110,103,101,32,70,97,105,108,101,100,58,32,87
00004F07  4661 696C 
00004F0B  6564 3A20 
00004F0F  57        
00004F10  726F 7465 8847          dc.b      114,111,116,101,32,91,37,48,50,120,93,44,32
00004F14  205B 2530 
00004F18  3278 5D2C 
00004F1C  20        
00004F1D  5265 6164 8848          dc.b      82,101,97,100,32,91,37,48,50,120,93,0
00004F21  205B 2530 
00004F25  3278 5D00 
                    8849   @lab6b_22:
00004F2A  2E00      8850          dc.b      46,0
                    8851   @lab6b_23:
00004F2C  0A0D 4572 8852          dc.b      10,13,69,114,97,115,105,110,103,10,13,0
00004F30  6173 696E 
00004F34  670A 0D00 
                    8853   @lab6b_24:
00004F38  5772 6974 8854          dc.b      87,114,105,116,105,110,103,32,80,114,111,103
00004F3C  696E 6720 
00004F40  5072 6F67 
00004F44  7261 6D20 8855          dc.b      114,97,109,32,116,111,32,109,101,109,111,114
00004F48  746F 206D 
00004F4C  656D 6F72 
00004F50  7920 0A0D 8856          dc.b      121,32,10,13,0
00004F54  00        
                    8857   @lab6b_25:
00004F56  5772 6974 8858          dc.b      87,114,105,116,105,110,103,32,68,111,110,101
00004F5A  696E 6720 
00004F5E  446F 6E65 
00004F62  0A0D 00   8859          dc.b      10,13,0
                    8860   @lab6b_26:
00004F66  5265 6164 8861          dc.b      82,101,97,100,105,110,103,32,80,114,111,103
00004F6A  696E 6720 
00004F6E  5072 6F67 
00004F72  7261 6D20 8862          dc.b      114,97,109,32,102,114,111,109,32,109,101,109
00004F76  6672 6F6D 
00004F7A  206D 656D 
00004F7E  6F72 790A 8863          dc.b      111,114,121,10,13,0
00004F82  0D00      
                    8864   @lab6b_27:
00004F84  0D0A 4552 8865          dc.b      13,10,69,82,82,79,82,58,32,68,65,84,65,32,77
00004F88  524F 523A 
00004F8C  2044 4154 
00004F90  4120 4D   
00004F93  6973 6D61 8866          dc.b      105,115,109,97,116,99,104,32,97,116,32,97,100
00004F97  7463 6820 
00004F9B  6174 2061 
00004F9F  64        
00004FA0  6472 2030 8867          dc.b      100,114,32,48,120,37,48,56,120,46,32,87,82,73
00004FA4  7825 3038 
00004FA8  782E 2057 
00004FAC  5249      
00004FAE  5445 3A20 8868          dc.b      84,69,58,32,48,120,37,48,50,120,32,82,69,65
00004FB2  3078 2530 
00004FB6  3278 2052 
00004FBA  4541      
00004FBC  443A 2030 8869          dc.b      68,58,32,48,120,37,48,50,120,13,10,0
00004FC0  7825 3032 
00004FC4  780D 0A00 
                    8870   @lab6b_28:
00004FC8  5041 5353 8871          dc.b      80,65,83,83,10,13,0
00004FCC  0A0D 00   
                    8872   @lab6b_29:
00004FD0  0D0A 4C6F 8873          dc.b      13,10,76,111,97,100,105,110,103,32,80,114,111
00004FD4  6164 696E 
00004FD8  6720 5072 
00004FDC  6F        
00004FDD  6772 616D 8874          dc.b      103,114,97,109,32,70,114,111,109,32,83,80,73
00004FE1  2046 726F 
00004FE5  6D20 5350 
00004FE9  49        
00004FEA  2046 6C61 8875          dc.b      32,70,108,97,115,104,46,46,46,46,0
00004FEE  7368 2E2E 
00004FF2  2E2E 00   
                    8876   @lab6b_30:
00004FF6  6761 7262 8877          dc.b      103,97,114,98,97,103,101,32,118,97,108,117,101
00004FFA  6167 6520 
00004FFE  7661 6C75 
00005002  65        
00005003  2072 6561 8878          dc.b      32,114,101,97,100,33,13,10,0
00005007  6421 0D0A 
0000500B  00        
                    8879   @lab6b_31:
0000500C  0D0A 446F 8880          dc.b      13,10,68,111,110,101,32,108,111,97,100,105,110
00005010  6E65 206C 
00005014  6F61 6469 
00005018  6E        
00005019  672E 0D0A 8881          dc.b      103,46,13,10,0
0000501D  00        
                    8882   @lab6b_32:
0000501E  2425 3038 8883          dc.b      36,37,48,56,88,32,32,0
00005022  5820 2000 
                    8884   @lab6b_33:
00005026  2000      8885          dc.b      32,0
                    8886   @lab6b_34:
00005028  2563 00   8887          dc.b      37,99,0
                    8888   @lab6b_35:
0000502C  00        8889          dc.b      0
                    8890   @lab6b_36:
0000502E  0D0A 0D0A 8891          dc.b      13,10,13,10,32,68,48,32,61,32,36,37,48,56,88
00005032  2044 3020 
00005036  3D20 2425 
0000503A  3038 58   
0000503D  2020 4130 8892          dc.b      32,32,65,48,32,61,32,36,37,48,56,88,0
00005041  203D 2024 
00005045  2530 3858 
00005049  00        
                    8893   @lab6b_37:
0000504A  0D0A 2044 8894          dc.b      13,10,32,68,49,32,61,32,36,37,48,56,88,32,32
0000504E  3120 3D20 
00005052  2425 3038 
00005056  5820 20   
00005059  4131 203D 8895          dc.b      65,49,32,61,32,36,37,48,56,88,0
0000505D  2024 2530 
00005061  3858 00   
                    8896   @lab6b_38:
00005064  0D0A 2044 8897          dc.b      13,10,32,68,50,32,61,32,36,37,48,56,88,32,32
00005068  3220 3D20 
0000506C  2425 3038 
00005070  5820 20   
00005073  4132 203D 8898          dc.b      65,50,32,61,32,36,37,48,56,88,0
00005077  2024 2530 
0000507B  3858 00   
                    8899   @lab6b_39:
0000507E  0D0A 2044 8900          dc.b      13,10,32,68,51,32,61,32,36,37,48,56,88,32,32
00005082  3320 3D20 
00005086  2425 3038 
0000508A  5820 20   
0000508D  4133 203D 8901          dc.b      65,51,32,61,32,36,37,48,56,88,0
00005091  2024 2530 
00005095  3858 00   
                    8902   @lab6b_40:
00005098  0D0A 2044 8903          dc.b      13,10,32,68,52,32,61,32,36,37,48,56,88,32,32
0000509C  3420 3D20 
000050A0  2425 3038 
000050A4  5820 20   
000050A7  4134 203D 8904          dc.b      65,52,32,61,32,36,37,48,56,88,0
000050AB  2024 2530 
000050AF  3858 00   
                    8905   @lab6b_41:
000050B2  0D0A 2044 8906          dc.b      13,10,32,68,53,32,61,32,36,37,48,56,88,32,32
000050B6  3520 3D20 
000050BA  2425 3038 
000050BE  5820 20   
000050C1  4135 203D 8907          dc.b      65,53,32,61,32,36,37,48,56,88,0
000050C5  2024 2530 
000050C9  3858 00   
                    8908   @lab6b_42:
000050CC  0D0A 2044 8909          dc.b      13,10,32,68,54,32,61,32,36,37,48,56,88,32,32
000050D0  3620 3D20 
000050D4  2425 3038 
000050D8  5820 20   
000050DB  4136 203D 8910          dc.b      65,54,32,61,32,36,37,48,56,88,0
000050DF  2024 2530 
000050E3  3858 00   
                    8911   @lab6b_43:
000050E6  0D0A 2044 8912          dc.b      13,10,32,68,55,32,61,32,36,37,48,56,88,32,32
000050EA  3720 3D20 
000050EE  2425 3038 
000050F2  5820 20   
000050F5  4137 203D 8913          dc.b      65,55,32,61,32,36,37,48,56,88,0
000050F9  2024 2530 
000050FD  3858 00   
                    8914   @lab6b_44:
00005100  0D0A 0D0A 8915          dc.b      13,10,13,10,85,83,80,32,61,32,36,37,48,56,88
00005104  5553 5020 
00005108  3D20 2425 
0000510C  3038 58   
0000510F  2020 2841 8916          dc.b      32,32,40,65,55,41,32,85,115,101,114,32,83,80
00005113  3729 2055 
00005117  7365 7220 
0000511B  5350      
0000511D  00        8917          dc.b      0
                    8918   @lab6b_45:
0000511E  0D0A 5353 8919          dc.b      13,10,83,83,80,32,61,32,36,37,48,56,88,32,32
00005122  5020 3D20 
00005126  2425 3038 
0000512A  5820 20   
0000512D  2841 3729 8920          dc.b      40,65,55,41,32,83,117,112,101,114,118,105,115
00005131  2053 7570 
00005135  6572 7669 
00005139  73        
0000513A  6F72 2053 8921          dc.b      111,114,32,83,80,0
0000513E  5000      
                    8922   @lab6b_46:
00005140  0D0A 2053 8923          dc.b      13,10,32,83,82,32,61,32,36,37,48,52,88,32,32
00005144  5220 3D20 
00005148  2425 3034 
0000514C  5820 20   
0000514F  2000      8924          dc.b      32,0
                    8925   @lab6b_47:
00005152  2020 205B 8926          dc.b      32,32,32,91,0
00005156  00        
                    8927   @lab6b_48:
00005158  0D0A 2050 8928          dc.b      13,10,32,80,67,32,61,32,36,37,48,56,88,32,32
0000515C  4320 3D20 
00005160  2425 3038 
00005164  5820 20   
00005167  00        8929          dc.b      0
                    8930   @lab6b_49:
00005168  5B40 2042 8931          dc.b      91,64,32,66,82,69,65,75,80,79,73,78,84,93,0
0000516C  5245 414B 
00005170  504F 494E 
00005174  545D 00   
                    8932   @lab6b_50:
00005178  0D0A 5750 8933          dc.b      13,10,87,80,37,100,32,61,32,37,115,0
0000517C  2564 203D 
00005180  2025 7300 
                    8934   @lab6b_51:
00005184  0D0A 0D0A 8935          dc.b      13,10,13,10,13,10,13,10,13,10,13,10,83,105,110
00005188  0D0A 0D0A 
0000518C  0D0A 0D0A 
00005190  5369 6E   
00005193  676C 6520 8936          dc.b      103,108,101,32,83,116,101,112,32,32,58,91,79
00005197  5374 6570 
0000519B  2020 3A5B 
0000519F  4F        
000051A0  4E5D 00   8937          dc.b      78,93,0
                    8938   @lab6b_52:
000051A4  0D0A 4272 8939          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
000051A8  6561 6B20 
000051AC  506F 696E 
000051B0  74        
000051B1  7320 3A5B 8940          dc.b      115,32,58,91,68,105,115,97,98,108,101,100,93
000051B5  4469 7361 
000051B9  626C 6564 
000051BD  5D        
000051BE  00        8941          dc.b      0
                    8942   @lab6b_53:
000051C0  0D0A 5072 8943          dc.b      13,10,80,114,101,115,115,32,60,83,80,65,67,69
000051C4  6573 7320 
000051C8  3C53 5041 
000051CC  4345      
000051CE  3E20 746F 8944          dc.b      62,32,116,111,32,69,120,101,99,117,116,101,32
000051D2  2045 7865 
000051D6  6375 7465 
000051DA  20        
000051DB  4E65 7874 8945          dc.b      78,101,120,116,32,73,110,115,116,114,117,99
000051DF  2049 6E73 
000051E3  7472 7563 
000051E7  7469 6F6E 8946          dc.b      116,105,111,110,0
000051EB  00        
                    8947   @lab6b_54:
000051EC  0D0A 5072 8948          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
000051F0  6573 7320 
000051F4  3C45 5343 
000051F8  3E20      
000051FA  746F 2052 8949          dc.b      116,111,32,82,101,115,117,109,101,32,80,114
000051FE  6573 756D 
00005202  6520 5072 
00005206  6F67 7261 8950          dc.b      111,103,114,97,109,0
0000520A  6D00      
                    8951   @lab6b_55:
0000520C  0D0A 496C 8952          dc.b      13,10,73,108,108,101,103,97,108,32,68,97,116
00005210  6C65 6761 
00005214  6C20 4461 
00005218  74        
00005219  6120 5265 8953          dc.b      97,32,82,101,103,105,115,116,101,114,32,58,32
0000521D  6769 7374 
00005221  6572 203A 
00005225  20        
00005226  5573 6520 8954          dc.b      85,115,101,32,68,48,45,68,55,46,46,46,46,46
0000522A  4430 2D44 
0000522E  372E 2E2E 
00005232  2E2E      
00005234  0D0A 00   8955          dc.b      13,10,0
                    8956   @lab6b_56:
00005238  0D0A 4425 8957          dc.b      13,10,68,37,99,32,61,32,0
0000523C  6320 3D20 
00005240  00        
                    8958   @lab6b_57:
00005242  0D0A 496C 8959          dc.b      13,10,73,108,108,101,103,97,108,32,65,100,100
00005246  6C65 6761 
0000524A  6C20 4164 
0000524E  64        
0000524F  7265 7373 8960          dc.b      114,101,115,115,32,82,101,103,105,115,116,101
00005253  2052 6567 
00005257  6973 7465 
0000525B  7220 3A20 8961          dc.b      114,32,58,32,85,115,101,32,65,48,45,65,55,46
0000525F  5573 6520 
00005263  4130 2D41 
00005267  372E      
00005269  2E2E 2E2E 8962          dc.b      46,46,46,46,13,10,0
0000526D  0D0A 00   
                    8963   @lab6b_58:
00005270  0D0A 4125 8964          dc.b      13,10,65,37,99,32,61,32,0
00005274  6320 3D20 
00005278  00        
                    8965   @lab6b_59:
0000527A  0D0A 5573 8966          dc.b      13,10,85,115,101,114,32,83,80,32,61,32,0
0000527E  6572 2053 
00005282  5020 3D20 
00005286  00        
                    8967   @lab6b_60:
00005288  0D0A 496C 8968          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
0000528C  6C65 6761 
00005290  6C20 5265 
00005294  67        
00005295  6973 7465 8969          dc.b      105,115,116,101,114,46,46,46,46,0
00005299  722E 2E2E 
0000529D  2E00      
                    8970   @lab6b_61:
000052A0  0D0A 5379 8971          dc.b      13,10,83,121,115,116,101,109,32,83,80,32,61
000052A4  7374 656D 
000052A8  2053 5020 
000052AC  3D        
000052AD  2000      8972          dc.b      32,0
                    8973   @lab6b_62:
000052B0  0D0A 5043 8974          dc.b      13,10,80,67,32,61,32,0
000052B4  203D 2000 
                    8975   @lab6b_63:
000052B8  0D0A 5352 8976          dc.b      13,10,83,82,32,61,32,0
000052BC  203D 2000 
                    8977   @lab6b_64:
000052C0  0D0A 496C 8978          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
000052C4  6C65 6761 
000052C8  6C20 5265 
000052CC  67        
000052CD  6973 7465 8979          dc.b      105,115,116,101,114,58,32,85,115,101,32,65,48
000052D1  723A 2055 
000052D5  7365 2041 
000052D9  30        
000052DA  2D41 372C 8980          dc.b      45,65,55,44,32,68,48,45,68,55,44,32,83,83,80
000052DE  2044 302D 
000052E2  4437 2C20 
000052E6  5353 50   
000052E9  2C20 5553 8981          dc.b      44,32,85,83,80,44,32,80,67,32,111,114,32,83
000052ED  502C 2050 
000052F1  4320 6F72 
000052F5  2053      
000052F7  520D 0A00 8982          dc.b      82,13,10,0
                    8983   @lab6b_65:
000052FC  0D0A 0D0A 8984          dc.b      13,10,13,10,78,117,109,32,32,32,32,32,65,100
00005300  4E75 6D20 
00005304  2020 2020 
00005308  4164      
0000530A  6472 6573 8985          dc.b      100,114,101,115,115,32,32,32,32,32,32,73,110
0000530E  7320 2020 
00005312  2020 2049 
00005316  6E        
00005317  7374 7275 8986          dc.b      115,116,114,117,99,116,105,111,110,0
0000531B  6374 696F 
0000531F  6E00      
                    8987   @lab6b_66:
00005322  0D0A 2D2D 8988          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
00005326  2D20 2020 
0000532A  2020 2D2D 
0000532E  2D2D 2D   
00005331  2D2D 2D2D 8989          dc.b      45,45,45,45,32,32,32,32,45,45,45,45,45,45,45
00005335  2020 2020 
00005339  2D2D 2D2D 
0000533D  2D2D 2D   
00005340  2D2D 2D2D 8990          dc.b      45,45,45,45,0
00005344  00        
                    8991   @lab6b_67:
00005346  0D0A 4E6F 8992          dc.b      13,10,78,111,32,66,114,101,97,107,80,111,105
0000534A  2042 7265 
0000534E  616B 506F 
00005352  69        
00005353  6E74 7320 8993          dc.b      110,116,115,32,83,101,116,0
00005357  5365 7400 
                    8994   @lab6b_68:
0000535C  0D0A 2533 8995          dc.b      13,10,37,51,100,32,32,32,32,32,36,37,48,56,120
00005360  6420 2020 
00005364  2020 2425 
00005368  3038 78   
0000536B  00        8996          dc.b      0
                    8997   @lab6b_69:
0000536C  0D0A 4E75 8998          dc.b      13,10,78,117,109,32,32,32,32,32,65,100,100,114
00005370  6D20 2020 
00005374  2020 4164 
00005378  6472      
0000537A  6573 7300 8999          dc.b      101,115,115,0
                    9000   @lab6b_70:
0000537E  0D0A 2D2D 9001          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
00005382  2D20 2020 
00005386  2020 2D2D 
0000538A  2D2D 2D   
0000538D  2D2D 2D2D 9002          dc.b      45,45,45,45,0
00005391  00        
                    9003   @lab6b_71:
00005392  0D0A 4E6F 9004          dc.b      13,10,78,111,32,87,97,116,99,104,80,111,105
00005396  2057 6174 
0000539A  6368 506F 
0000539E  69        
0000539F  6E74 7320 9005          dc.b      110,116,115,32,83,101,116,0
000053A3  5365 7400 
                    9006   @lab6b_72:
000053A8  0D0A 456E 9007          dc.b      13,10,69,110,116,101,114,32,66,114,101,97,107
000053AC  7465 7220 
000053B0  4272 6561 
000053B4  6B        
000053B5  2050 6F69 9008          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
000053B9  6E74 204E 
000053BD  756D 6265 
000053C1  72        
000053C2  3A20 00   9009          dc.b      58,32,0
                    9010   @lab6b_73:
000053C6  0D0A 496C 9011          dc.b      13,10,73,108,108,101,103,97,108,32,82,97,110
000053CA  6C65 6761 
000053CE  6C20 5261 
000053D2  6E        
000053D3  6765 203A 9012          dc.b      103,101,32,58,32,85,115,101,32,48,32,45,32,55
000053D7  2055 7365 
000053DB  2030 202D 
000053DF  2037      
000053E1  00        9013          dc.b      0
                    9014   @lab6b_74:
000053E2  0D0A 4272 9015          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
000053E6  6561 6B20 
000053EA  506F 696E 
000053EE  74        
000053EF  2043 6C65 9016          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
000053F3  6172 6564 
000053F7  2E2E 2E2E 
000053FB  2E        
000053FC  0D0A 00   9017          dc.b      13,10,0
                    9018   @lab6b_75:
00005400  0D0A 4272 9019          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00005404  6561 6B20 
00005408  506F 696E 
0000540C  74        
0000540D  2077 6173 9020          dc.b      32,119,97,115,110,39,116,32,83,101,116,46,46
00005411  6E27 7420 
00005415  5365 742E 
00005419  2E        
0000541A  2E2E 2E00 9021          dc.b      46,46,46,0
                    9022   @lab6b_76:
0000541E  0D0A 456E 9023          dc.b      13,10,69,110,116,101,114,32,87,97,116,99,104
00005422  7465 7220 
00005426  5761 7463 
0000542A  68        
0000542B  2050 6F69 9024          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
0000542F  6E74 204E 
00005433  756D 6265 
00005437  72        
00005438  3A20 00   9025          dc.b      58,32,0
                    9026   @lab6b_77:
0000543C  0D0A 5761 9027          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00005440  7463 6820 
00005444  506F 696E 
00005448  74        
00005449  2043 6C65 9028          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
0000544D  6172 6564 
00005451  2E2E 2E2E 
00005455  2E        
00005456  0D0A 00   9029          dc.b      13,10,0
                    9030   @lab6b_78:
0000545A  0D0A 5761 9031          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
0000545E  7463 6820 
00005462  506F 696E 
00005466  74        
00005467  2057 6173 9032          dc.b      32,87,97,115,32,110,111,116,32,83,101,116,46
0000546B  206E 6F74 
0000546F  2053 6574 
00005473  2E        
00005474  2E2E 2E2E 9033          dc.b      46,46,46,46,0
00005478  00        
                    9034   @lab6b_79:
0000547A  0D0A 4E6F 9035          dc.b      13,10,78,111,32,70,82,69,69,32,66,114,101,97
0000547E  2046 5245 
00005482  4520 4272 
00005486  6561      
00005488  6B20 506F 9036          dc.b      107,32,80,111,105,110,116,115,46,46,46,46,46
0000548C  696E 7473 
00005490  2E2E 2E2E 
00005494  2E        
00005495  00        9037          dc.b      0
                    9038   @lab6b_80:
00005496  0D0A 4272 9039          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000549A  6561 6B20 
0000549E  506F 696E 
000054A2  74        
000054A3  2041 6464 9040          dc.b      32,65,100,100,114,101,115,115,58,32,0
000054A7  7265 7373 
000054AB  3A20 00   
                    9041   @lab6b_81:
000054AE  0D0A 4572 9042          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
000054B2  726F 7220 
000054B6  3A20 4272 
000054BA  65        
000054BB  616B 2050 9043          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
000054BF  6F69 6E74 
000054C3  7320 4341 
000054C7  4E        
000054C8  4E4F 5420 9044          dc.b      78,79,84,32,98,101,32,115,101,116,32,97,116
000054CC  6265 2073 
000054D0  6574 2061 
000054D4  74        
000054D5  204F 4444 9045          dc.b      32,79,68,68,32,97,100,100,114,101,115,115,101
000054D9  2061 6464 
000054DD  7265 7373 
000054E1  65        
000054E2  7300      9046          dc.b      115,0
                    9047   @lab6b_82:
000054E4  0D0A 4572 9048          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
000054E8  726F 7220 
000054EC  3A20 4272 
000054F0  65        
000054F1  616B 2050 9049          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
000054F5  6F69 6E74 
000054F9  7320 4341 
000054FD  4E        
000054FE  4E4F 5420 9050          dc.b      78,79,84,32,98,101,32,115,101,116,32,102,111
00005502  6265 2073 
00005506  6574 2066 
0000550A  6F        
0000550B  7220 524F 9051          dc.b      114,32,82,79,77,32,105,110,32,82,97,110,103
0000550F  4D20 696E 
00005513  2052 616E 
00005517  67        
00005518  6520 3A20 9052          dc.b      101,32,58,32,91,36,48,45,36,48,48,48,48,55,70
0000551C  5B24 302D 
00005520  2430 3030 
00005524  3037 46   
00005527  4646 5D00 9053          dc.b      70,70,93,0
                    9054   @lab6b_83:
0000552C  0D0A 4572 9055          dc.b      13,10,69,114,114,111,114,58,32,66,114,101,97
00005530  726F 723A 
00005534  2042 7265 
00005538  61        
00005539  6B20 506F 9056          dc.b      107,32,80,111,105,110,116,32,65,108,114,101
0000553D  696E 7420 
00005541  416C 7265 
00005545  6164 7920 9057          dc.b      97,100,121,32,69,120,105,115,116,115,32,97,116
00005549  4578 6973 
0000554D  7473 2061 
00005551  74        
00005552  2041 6464 9058          dc.b      32,65,100,100,114,101,115,115,32,58,32,37,48
00005556  7265 7373 
0000555A  203A 2025 
0000555E  30        
0000555F  3878 0D0A 9059          dc.b      56,120,13,10,0
00005563  00        
                    9060   @lab6b_84:
00005564  0D0A 4272 9061          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00005568  6561 6B20 
0000556C  506F 696E 
00005570  74        
00005571  2053 6574 9062          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
00005575  2061 7420 
00005579  4164 6472 
0000557D  65        
0000557E  7373 3A20 9063          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
00005582  5B24 2530 
00005586  3878 5D00 
                    9064   @lab6b_85:
0000558A  0D0A 4E6F 9065          dc.b      13,10,78,111,32,70,82,69,69,32,87,97,116,99
0000558E  2046 5245 
00005592  4520 5761 
00005596  7463      
00005598  6820 506F 9066          dc.b      104,32,80,111,105,110,116,115,46,46,46,46,46
0000559C  696E 7473 
000055A0  2E2E 2E2E 
000055A4  2E        
000055A5  00        9067          dc.b      0
                    9068   @lab6b_86:
000055A6  0D0A 5761 9069          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
000055AA  7463 6820 
000055AE  506F 696E 
000055B2  74        
000055B3  2041 6464 9070          dc.b      32,65,100,100,114,101,115,115,58,32,0
000055B7  7265 7373 
000055BB  3A20 00   
                    9071   @lab6b_87:
000055BE  0D0A 4572 9072          dc.b      13,10,69,114,114,111,114,58,32,87,97,116,99
000055C2  726F 723A 
000055C6  2057 6174 
000055CA  63        
000055CB  6820 506F 9073          dc.b      104,32,80,111,105,110,116,32,65,108,114,101
000055CF  696E 7420 
000055D3  416C 7265 
000055D7  6164 7920 9074          dc.b      97,100,121,32,83,101,116,32,97,116,32,65,100
000055DB  5365 7420 
000055DF  6174 2041 
000055E3  64        
000055E4  6472 6573 9075          dc.b      100,114,101,115,115,32,58,32,37,48,56,120,13
000055E8  7320 3A20 
000055EC  2530 3878 
000055F0  0D        
000055F1  0A00      9076          dc.b      10,0
                    9077   @lab6b_88:
000055F4  0D0A 5761 9078          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
000055F8  7463 6820 
000055FC  506F 696E 
00005600  74        
00005601  2053 6574 9079          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
00005605  2061 7420 
00005609  4164 6472 
0000560D  65        
0000560E  7373 3A20 9080          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
00005612  5B24 2530 
00005616  3878 5D00 
                    9081   @lab6b_89:
0000561A  0D0A 0D0A 9082          dc.b      13,10,13,10,13,10,13,10,64,66,82,69,65,75,80
0000561E  0D0A 0D0A 
00005622  4042 5245 
00005626  414B 50   
00005629  4F49 4E54 9083          dc.b      79,73,78,84,0
0000562D  00        
                    9084   @lab6b_90:
0000562E  0D0A 5369 9085          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00005632  6E67 6C65 
00005636  2053 7465 
0000563A  70        
0000563B  203A 205B 9086          dc.b      32,58,32,91,79,78,93,0
0000563F  4F4E 5D00 
                    9087   @lab6b_91:
00005644  0D0A 4272 9088          dc.b      13,10,66,114,101,97,107,80,111,105,110,116,115
00005648  6561 6B50 
0000564C  6F69 6E74 
00005650  73        
00005651  203A 205B 9089          dc.b      32,58,32,91,69,110,97,98,108,101,100,93,0
00005655  456E 6162 
00005659  6C65 645D 
0000565D  00        
                    9090   @lab6b_92:
0000565E  0D0A 5072 9091          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00005662  6573 7320 
00005666  3C45 5343 
0000566A  3E20      
0000566C  746F 2052 9092          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
00005670  6573 756D 
00005674  6520 5573 
00005678  6572 2050 9093          dc.b      101,114,32,80,114,111,103,114,97,109,13,10,0
0000567C  726F 6772 
00005680  616D 0D0A 
00005684  00        
                    9094   @lab6b_93:
00005686  0D0A 556E 9095          dc.b      13,10,85,110,107,110,111,119,110,32,67,111,109
0000568A  6B6E 6F77 
0000568E  6E20 436F 
00005692  6D        
00005693  6D61 6E64 9096          dc.b      109,97,110,100,46,46,46,46,46,13,10,0
00005697  2E2E 2E2E 
0000569B  2E0D 0A00 
                    9097   @lab6b_94:
000056A0  0D0A 5072 9098          dc.b      13,10,80,114,111,103,114,97,109,32,69,110,100
000056A4  6F67 7261 
000056A8  6D20 456E 
000056AC  64        
000056AD  6564 2028 9099          dc.b      101,100,32,40,84,82,65,80,32,35,49,53,41,46
000056B1  5452 4150 
000056B5  2023 3135 
000056B9  292E      
000056BB  2E2E 2E00 9100          dc.b      46,46,46,0
                    9101   @lab6b_95:
000056C0  0D0A 4B69 9102          dc.b      13,10,75,105,108,108,32,65,108,108,32,66,114
000056C4  6C6C 2041 
000056C8  6C6C 2042 
000056CC  72        
000056CD  6561 6B20 9103          dc.b      101,97,107,32,80,111,105,110,116,115,46,46,46
000056D1  506F 696E 
000056D5  7473 2E2E 
000056D9  2E        
000056DA  2879 2F6E 9104          dc.b      40,121,47,110,41,63,0
000056DE  293F 00   
                    9105   @lab6b_96:
000056E2  0D0A 4B69 9106          dc.b      13,10,75,105,108,108,32,65,108,108,32,87,97
000056E6  6C6C 2041 
000056EA  6C6C 2057 
000056EE  61        
000056EF  7463 6820 9107          dc.b      116,99,104,32,80,111,105,110,116,115,46,46,46
000056F3  506F 696E 
000056F7  7473 2E2E 
000056FB  2E        
000056FC  2879 2F6E 9108          dc.b      40,121,47,110,41,63,0
00005700  293F 00   
                    9109   @lab6b_97:
00005704  0D0A 2D2D 9110          dc.b      13,10,45,45,45,45,45,45,45,45,45,45,45,45,45
00005708  2D2D 2D2D 
0000570C  2D2D 2D2D 
00005710  2D2D 2D   
00005713  2D2D 2D2D 9111          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
00005717  2D2D 2D2D 
0000571B  2D2D 2D2D 
0000571F  2D2D 2D   
00005722  2D2D 2D2D 9112          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
00005726  2D2D 2D2D 
0000572A  2D2D 2D2D 
0000572E  2D2D 2D   
00005731  2D2D 2D2D 9113          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
00005735  2D2D 2D2D 
00005739  2D2D 2D2D 
0000573D  2D2D 2D   
00005740  2D2D 2D2D 9114          dc.b      45,45,45,45,45,45,0
00005744  2D2D 00   
                    9115   @lab6b_98:
00005748  0D0A 2020 9116          dc.b      13,10,32,32,68,101,98,117,103,103,101,114,32
0000574C  4465 6275 
00005750  6767 6572 
00005754  20        
00005755  436F 6D6D 9117          dc.b      67,111,109,109,97,110,100,32,83,117,109,109
00005759  616E 6420 
0000575D  5375 6D6D 
00005761  6172 7900 9118          dc.b      97,114,121,0
                    9119   @lab6b_99:
00005766  0D0A 2020 9120          dc.b      13,10,32,32,46,40,114,101,103,41,32,32,32,32
0000576A  2E28 7265 
0000576E  6729 2020 
00005772  2020      
00005774  2020 202D 9121          dc.b      32,32,32,45,32,67,104,97,110,103,101,32,82,101
00005778  2043 6861 
0000577C  6E67 6520 
00005780  5265      
00005782  6769 7374 9122          dc.b      103,105,115,116,101,114,115,58,32,101,46,103
00005786  6572 733A 
0000578A  2065 2E67 
0000578E  2041 302D 9123          dc.b      32,65,48,45,65,55,44,68,48,45,68,55,44,80,67
00005792  4137 2C44 
00005796  302D 4437 
0000579A  2C50 43   
0000579D  2C53 5350 9124          dc.b      44,83,83,80,44,85,83,80,44,83,82,0
000057A1  2C55 5350 
000057A5  2C53 5200 
                    9125   @lab6b_100:
000057AA  0D0A 2020 9126          dc.b      13,10,32,32,66,68,47,66,83,47,66,67,47,66,75
000057AE  4244 2F42 
000057B2  532F 4243 
000057B6  2F42 4B   
000057B9  2020 2D20 9127          dc.b      32,32,45,32,66,114,101,97,107,32,80,111,105
000057BD  4272 6561 
000057C1  6B20 506F 
000057C5  69        
000057C6  6E74 3A20 9128          dc.b      110,116,58,32,68,105,115,112,108,97,121,47,83
000057CA  4469 7370 
000057CE  6C61 792F 
000057D2  53        
000057D3  6574 2F43 9129          dc.b      101,116,47,67,108,101,97,114,47,75,105,108,108
000057D7  6C65 6172 
000057DB  2F4B 696C 
000057DF  6C        
000057E0  00        9130          dc.b      0
                    9131   @lab6b_101:
000057E2  0D0A 2020 9132          dc.b      13,10,32,32,67,32,32,32,32,32,32,32,32,32,32
000057E6  4320 2020 
000057EA  2020 2020 
000057EE  2020 20   
000057F1  2020 2D20 9133          dc.b      32,32,45,32,67,111,112,121,32,80,114,111,103
000057F5  436F 7079 
000057F9  2050 726F 
000057FD  67        
000057FE  7261 6D20 9134          dc.b      114,97,109,32,102,114,111,109,32,70,108,97,115
00005802  6672 6F6D 
00005806  2046 6C61 
0000580A  73        
0000580B  6820 746F 9135          dc.b      104,32,116,111,32,77,97,105,110,32,77,101,109
0000580F  204D 6169 
00005813  6E20 4D65 
00005817  6D        
00005818  6F72 7900 9136          dc.b      111,114,121,0
                    9137   @lab6b_102:
0000581C  0D0A 2020 9138          dc.b      13,10,32,32,68,32,32,32,32,32,32,32,32,32,32
00005820  4420 2020 
00005824  2020 2020 
00005828  2020 20   
0000582B  2020 2D20 9139          dc.b      32,32,45,32,68,117,109,112,32,77,101,109,111
0000582F  4475 6D70 
00005833  204D 656D 
00005837  6F        
00005838  7279 2043 9140          dc.b      114,121,32,67,111,110,116,101,110,116,115,32
0000583C  6F6E 7465 
00005840  6E74 7320 
00005844  746F 2053 9141          dc.b      116,111,32,83,99,114,101,101,110,0
00005848  6372 6565 
0000584C  6E00      
                    9142   @lab6b_103:
0000584E  0D0A 2020 9143          dc.b      13,10,32,32,69,32,32,32,32,32,32,32,32,32,32
00005852  4520 2020 
00005856  2020 2020 
0000585A  2020 20   
0000585D  2020 2D20 9144          dc.b      32,32,45,32,69,110,116,101,114,32,83,116,114
00005861  456E 7465 
00005865  7220 5374 
00005869  72        
0000586A  696E 6720 9145          dc.b      105,110,103,32,105,110,116,111,32,77,101,109
0000586E  696E 746F 
00005872  204D 656D 
00005876  6F72 7900 9146          dc.b      111,114,121,0
                    9147   @lab6b_104:
0000587A  0D0A 2020 9148          dc.b      13,10,32,32,70,32,32,32,32,32,32,32,32,32,32
0000587E  4620 2020 
00005882  2020 2020 
00005886  2020 20   
00005889  2020 2D20 9149          dc.b      32,32,45,32,70,105,108,108,32,77,101,109,111
0000588D  4669 6C6C 
00005891  204D 656D 
00005895  6F        
00005896  7279 2077 9150          dc.b      114,121,32,119,105,116,104,32,68,97,116,97,0
0000589A  6974 6820 
0000589E  4461 7461 
000058A2  00        
                    9151   @lab6b_105:
000058A4  0D0A 2020 9152          dc.b      13,10,32,32,71,32,32,32,32,32,32,32,32,32,32
000058A8  4720 2020 
000058AC  2020 2020 
000058B0  2020 20   
000058B3  2020 2D20 9153          dc.b      32,32,45,32,71,111,32,80,114,111,103,114,97
000058B7  476F 2050 
000058BB  726F 6772 
000058BF  61        
000058C0  6D20 5374 9154          dc.b      109,32,83,116,97,114,116,105,110,103,32,97,116
000058C4  6172 7469 
000058C8  6E67 2061 
000058CC  74        
000058CD  2041 6464 9155          dc.b      32,65,100,100,114,101,115,115,58,32,36,37,48
000058D1  7265 7373 
000058D5  3A20 2425 
000058D9  30        
000058DA  3858 00   9156          dc.b      56,88,0
                    9157   @lab6b_106:
000058DE  0D0A 2020 9158          dc.b      13,10,32,32,76,32,32,32,32,32,32,32,32,32,32
000058E2  4C20 2020 
000058E6  2020 2020 
000058EA  2020 20   
000058ED  2020 2D20 9159          dc.b      32,32,45,32,76,111,97,100,32,80,114,111,103
000058F1  4C6F 6164 
000058F5  2050 726F 
000058F9  67        
000058FA  7261 6D20 9160          dc.b      114,97,109,32,40,46,72,69,88,32,102,105,108
000058FE  282E 4845 
00005902  5820 6669 
00005906  6C        
00005907  6529 2066 9161          dc.b      101,41,32,102,114,111,109,32,76,97,112,116,111
0000590B  726F 6D20 
0000590F  4C61 7074 
00005913  6F        
00005914  7000      9162          dc.b      112,0
                    9163   @lab6b_107:
00005916  0D0A 2020 9164          dc.b      13,10,32,32,77,32,32,32,32,32,32,32,32,32,32
0000591A  4D20 2020 
0000591E  2020 2020 
00005922  2020 20   
00005925  2020 2D20 9165          dc.b      32,32,45,32,77,101,109,111,114,121,32,69,120
00005929  4D65 6D6F 
0000592D  7279 2045 
00005931  78        
00005932  616D 696E 9166          dc.b      97,109,105,110,101,32,97,110,100,32,67,104,97
00005936  6520 616E 
0000593A  6420 4368 
0000593E  61        
0000593F  6E67 6500 9167          dc.b      110,103,101,0
                    9168   @lab6b_108:
00005944  0D0A 2020 9169          dc.b      13,10,32,32,80,32,32,32,32,32,32,32,32,32,32
00005948  5020 2020 
0000594C  2020 2020 
00005950  2020 20   
00005953  2020 2D20 9170          dc.b      32,32,45,32,80,114,111,103,114,97,109,32,70
00005957  5072 6F67 
0000595B  7261 6D20 
0000595F  46        
00005960  6C61 7368 9171          dc.b      108,97,115,104,32,77,101,109,111,114,121,32
00005964  204D 656D 
00005968  6F72 7920 
0000596C  7769 7468 9172          dc.b      119,105,116,104,32,85,115,101,114,32,80,114
00005970  2055 7365 
00005974  7220 5072 
00005978  6F67 7261 9173          dc.b      111,103,114,97,109,0
0000597C  6D00      
                    9174   @lab6b_109:
0000597E  0D0A 2020 9175          dc.b      13,10,32,32,82,32,32,32,32,32,32,32,32,32,32
00005982  5220 2020 
00005986  2020 2020 
0000598A  2020 20   
0000598D  2020 2D20 9176          dc.b      32,32,45,32,68,105,115,112,108,97,121,32,54
00005991  4469 7370 
00005995  6C61 7920 
00005999  36        
0000599A  3830 3030 9177          dc.b      56,48,48,48,32,82,101,103,105,115,116,101,114
0000599E  2052 6567 
000059A2  6973 7465 
000059A6  72        
000059A7  7300      9178          dc.b      115,0
                    9179   @lab6b_110:
000059AA  0D0A 2020 9180          dc.b      13,10,32,32,83,32,32,32,32,32,32,32,32,32,32
000059AE  5320 2020 
000059B2  2020 2020 
000059B6  2020 20   
000059B9  2020 2D20 9181          dc.b      32,32,45,32,84,111,103,103,108,101,32,79,78
000059BD  546F 6767 
000059C1  6C65 204F 
000059C5  4E        
000059C6  2F4F 4646 9182          dc.b      47,79,70,70,32,83,105,110,103,108,101,32,83
000059CA  2053 696E 
000059CE  676C 6520 
000059D2  53        
000059D3  7465 7020 9183          dc.b      116,101,112,32,77,111,100,101,0
000059D7  4D6F 6465 
000059DB  00        
                    9184   @lab6b_111:
000059DC  0D0A 2020 9185          dc.b      13,10,32,32,84,77,32,32,32,32,32,32,32,32,32
000059E0  544D 2020 
000059E4  2020 2020 
000059E8  2020 20   
000059EB  2020 2D20 9186          dc.b      32,32,45,32,84,101,115,116,32,77,101,109,111
000059EF  5465 7374 
000059F3  204D 656D 
000059F7  6F        
000059F8  7279 00   9187          dc.b      114,121,0
                    9188   @lab6b_112:
000059FC  0D0A 2020 9189          dc.b      13,10,32,32,84,83,32,32,32,32,32,32,32,32,32
00005A00  5453 2020 
00005A04  2020 2020 
00005A08  2020 20   
00005A0B  2020 2D20 9190          dc.b      32,32,45,32,84,101,115,116,32,83,119,105,116
00005A0F  5465 7374 
00005A13  2053 7769 
00005A17  74        
00005A18  6368 6573 9191          dc.b      99,104,101,115,58,32,83,87,55,45,48,0
00005A1C  3A20 5357 
00005A20  372D 3000 
                    9192   @lab6b_113:
00005A24  0D0A 2020 9193          dc.b      13,10,32,32,84,68,32,32,32,32,32,32,32,32,32
00005A28  5444 2020 
00005A2C  2020 2020 
00005A30  2020 20   
00005A33  2020 2D20 9194          dc.b      32,32,45,32,84,101,115,116,32,68,105,115,112
00005A37  5465 7374 
00005A3B  2044 6973 
00005A3F  70        
00005A40  6C61 7973 9195          dc.b      108,97,121,115,58,32,76,69,68,115,32,97,110
00005A44  3A20 4C45 
00005A48  4473 2061 
00005A4C  6E        
00005A4D  6420 372D 9196          dc.b      100,32,55,45,83,101,103,109,101,110,116,0
00005A51  5365 676D 
00005A55  656E 7400 
                    9197   @lab6b_114:
00005A5A  0D0A 2020 9198          dc.b      13,10,32,32,87,68,47,87,83,47,87,67,47,87,75
00005A5E  5744 2F57 
00005A62  532F 5743 
00005A66  2F57 4B   
00005A69  2020 2D20 9199          dc.b      32,32,45,32,87,97,116,99,104,32,80,111,105,110
00005A6D  5761 7463 
00005A71  6820 506F 
00005A75  696E      
00005A77  743A 2044 9200          dc.b      116,58,32,68,105,115,112,108,97,121,47,83,101
00005A7B  6973 706C 
00005A7F  6179 2F53 
00005A83  65        
00005A84  742F 436C 9201          dc.b      116,47,67,108,101,97,114,47,75,105,108,108,0
00005A88  6561 722F 
00005A8C  4B69 6C6C 
00005A90  00        
                    9202   @lab6b_115:
00005A92  0D0A 2300 9203          dc.b      13,10,35,0
                    9204   @lab6b_116:
00005A96  0D0A 5072 9205          dc.b      13,10,80,114,111,103,114,97,109,32,82,117,110
00005A9A  6F67 7261 
00005A9E  6D20 5275 
00005AA2  6E        
00005AA3  6E69 6E67 9206          dc.b      110,105,110,103,46,46,46,46,46,0
00005AA7  2E2E 2E2E 
00005AAB  2E00      
                    9207   @lab6b_117:
00005AAE  0D0A 5072 9208          dc.b      13,10,80,114,101,115,115,32,60,82,69,83,69,84
00005AB2  6573 7320 
00005AB6  3C52 4553 
00005ABA  4554      
00005ABC  3E20 6275 9209          dc.b      62,32,98,117,116,116,111,110,32,60,75,101,121
00005AC0  7474 6F6E 
00005AC4  203C 4B65 
00005AC8  79        
00005AC9  303E 206F 9210          dc.b      48,62,32,111,110,32,68,69,49,32,116,111,32,115
00005ACD  6E20 4445 
00005AD1  3120 746F 
00005AD5  2073      
00005AD7  746F 7000 9211          dc.b      116,111,112,0
                    9212   @lab6b_118:
00005ADC  0D0A 4572 9213          dc.b      13,10,69,114,114,111,114,58,32,80,114,101,115
00005AE0  726F 723A 
00005AE4  2050 7265 
00005AE8  73        
00005AE9  7320 2747 9214          dc.b      115,32,39,71,39,32,102,105,114,115,116,32,116
00005AED  2720 6669 
00005AF1  7273 7420 
00005AF5  74        
00005AF6  6F20 7374 9215          dc.b      111,32,115,116,97,114,116,32,112,114,111,103
00005AFA  6172 7420 
00005AFE  7072 6F67 
00005B02  7261 6D00 9216          dc.b      114,97,109,0
                    9217   @lab6b_119:
00005B06  0D0A 5369 9218          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00005B0A  6E67 6C65 
00005B0E  2053 7465 
00005B12  70        
00005B13  2020 3A5B 9219          dc.b      32,32,58,91,79,78,93,0
00005B17  4F4E 5D00 
                    9220   @lab6b_120:
00005B1C  0D0A 5072 9221          dc.b      13,10,80,114,101,115,115,32,39,71,39,32,116
00005B20  6573 7320 
00005B24  2747 2720 
00005B28  74        
00005B29  6F20 5472 9222          dc.b      111,32,84,114,97,99,101,32,80,114,111,103,114
00005B2D  6163 6520 
00005B31  5072 6F67 
00005B35  72        
00005B36  616D 2066 9223          dc.b      97,109,32,102,114,111,109,32,97,100,100,114
00005B3A  726F 6D20 
00005B3E  6164 6472 
00005B42  6573 7320 9224          dc.b      101,115,115,32,36,37,88,46,46,46,46,46,0
00005B46  2425 582E 
00005B4A  2E2E 2E2E 
00005B4E  00        
                    9225   @lab6b_121:
00005B50  0D0A 5075 9226          dc.b      13,10,80,117,115,104,32,60,82,69,83,69,84,32
00005B54  7368 203C 
00005B58  5245 5345 
00005B5C  5420      
00005B5E  4275 7474 9227          dc.b      66,117,116,116,111,110,62,32,116,111,32,83,116
00005B62  6F6E 3E20 
00005B66  746F 2053 
00005B6A  74        
00005B6B  6F70 2E2E 9228          dc.b      111,112,46,46,46,46,46,0
00005B6F  2E2E 2E00 
                    9229   @lab6b_122:
00005B74  0D0A 5369 9230          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00005B78  6E67 6C65 
00005B7C  2053 7465 
00005B80  70        
00005B81  203A 205B 9231          dc.b      32,58,32,91,79,70,70,93,0
00005B85  4F46 465D 
00005B89  00        
                    9232   @lab6b_123:
00005B8A  0D0A 4272 9233          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00005B8E  6561 6B20 
00005B92  506F 696E 
00005B96  74        
00005B97  7320 3A5B 9234          dc.b      115,32,58,91,69,110,97,98,108,101,100,93,0
00005B9B  456E 6162 
00005B9F  6C65 645D 
00005BA3  00        
                    9235   @lab6b_124:
00005BA4  0D0A 5072 9236          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00005BA8  6573 7320 
00005BAC  3C45 5343 
00005BB0  3E20      
00005BB2  746F 2052 9237          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
00005BB6  6573 756D 
00005BBA  6520 5573 
00005BBE  6572 2050 9238          dc.b      101,114,32,80,114,111,103,114,97,109,46,46,46
00005BC2  726F 6772 
00005BC6  616D 2E2E 
00005BCA  2E        
00005BCB  2E2E 00   9239          dc.b      46,46,0
                    9240   @lab6b_125:
00005BCE  0D0A 5369 9241          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00005BD2  6E67 6C65 
00005BD6  2053 7465 
00005BDA  70        
00005BDB  2020 3A5B 9242          dc.b      32,32,58,91,79,70,70,93,0
00005BDF  4F46 465D 
00005BE3  00        
                    9243   @lab6b_126:
00005BE4  0D0A 0D0A 9244          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
00005BE8  5072 6F67 
00005BEC  7261 6D20 
00005BF0  41        
00005BF1  424F 5254 9245          dc.b      66,79,82,84,32,33,33,33,33,33,33,13,10,0
00005BF5  2021 2121 
00005BF9  2121 210D 
00005BFD  0A00      
                    9246   @lab6b_127:
00005C00  2573 0D0A 9247          dc.b      37,115,13,10,0
00005C04  00        
                    9248   @lab6b_128:
00005C06  0D0A 0D0A 9249          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
00005C0A  5072 6F67 
00005C0E  7261 6D20 
00005C12  41        
00005C13  424F 5254 9250          dc.b      66,79,82,84,32,33,33,33,33,33,0
00005C17  2021 2121 
00005C1B  2121 00   
                    9251   @lab6b_129:
00005C1E  0D0A 556E 9252          dc.b      13,10,85,110,104,97,110,100,108,101,100,32,73
00005C22  6861 6E64 
00005C26  6C65 6420 
00005C2A  49        
00005C2B  6E74 6572 9253          dc.b      110,116,101,114,114,117,112,116,58,32,73,82
00005C2F  7275 7074 
00005C33  3A20 4952 
00005C37  5125 6420 9254          dc.b      81,37,100,32,33,33,33,33,33,0
00005C3B  2121 2121 
00005C3F  2100      
                    9255   @lab6b_130:
00005C42  4144 4452 9256          dc.b      65,68,68,82,69,83,83,32,69,82,82,79,82,58,32
00005C46  4553 5320 
00005C4A  4552 524F 
00005C4E  523A 20   
00005C51  3136 206F 9257          dc.b      49,54,32,111,114,32,51,50,32,66,105,116,32,84
00005C55  7220 3332 
00005C59  2042 6974 
00005C5D  2054      
00005C5F  7261 6E73 9258          dc.b      114,97,110,115,102,101,114,32,116,111,47,102
00005C63  6665 7220 
00005C67  746F 2F66 
00005C6B  726F 6D20 9259          dc.b      114,111,109,32,97,110,32,79,68,68,32,65,100
00005C6F  616E 204F 
00005C73  4444 2041 
00005C77  64        
00005C78  6472 6573 9260          dc.b      100,114,101,115,115,46,46,46,46,0
00005C7C  732E 2E2E 
00005C80  2E00      
                    9261   @lab6b_131:
00005C82  556E 6861 9262          dc.b      85,110,104,97,110,100,108,101,100,32,84,114
00005C86  6E64 6C65 
00005C8A  6420 5472 
00005C8E  6170 2021 9263          dc.b      97,112,32,33,33,33,33,33,0
00005C92  2121 2121 
00005C96  00        
                    9264   @lab6b_132:
00005C98  4255 5320 9265          dc.b      66,85,83,32,69,114,114,111,114,33,0
00005C9C  4572 726F 
00005CA0  7221 00   
                    9266   @lab6b_133:
00005CA4  4144 4452 9267          dc.b      65,68,68,82,69,83,83,32,69,114,114,111,114,33
00005CA8  4553 5320 
00005CAC  4572 726F 
00005CB0  7221      
00005CB2  00        9268          dc.b      0
                    9269   @lab6b_134:
00005CB4  494C 4C45 9270          dc.b      73,76,76,69,71,65,76,32,73,78,83,84,82,85,67
00005CB8  4741 4C20 
00005CBC  494E 5354 
00005CC0  5255 43   
00005CC3  5449 4F4E 9271          dc.b      84,73,79,78,0
00005CC7  00        
                    9272   @lab6b_135:
00005CC8  4449 5649 9273          dc.b      68,73,86,73,68,69,32,66,89,32,90,69,82,79,0
00005CCC  4445 2042 
00005CD0  5920 5A45 
00005CD4  524F 00   
                    9274   @lab6b_136:
00005CD8  2743 484B 9275          dc.b      39,67,72,75,39,32,73,78,83,84,82,85,67,84,73
00005CDC  2720 494E 
00005CE0  5354 5255 
00005CE4  4354 49   
00005CE7  4F4E 00   9276          dc.b      79,78,0
                    9277   @lab6b_137:
00005CEA  5452 4150 9278          dc.b      84,82,65,80,86,32,73,78,83,84,82,85,67,84,73
00005CEE  5620 494E 
00005CF2  5354 5255 
00005CF6  4354 49   
00005CF9  4F4E 00   9279          dc.b      79,78,0
                    9280   @lab6b_138:
00005CFC  5052 4956 9281          dc.b      80,82,73,86,73,76,69,71,69,32,86,73,79,76,65
00005D00  494C 4547 
00005D04  4520 5649 
00005D08  4F4C 41   
00005D0B  5449 4F4E 9282          dc.b      84,73,79,78,0
00005D0F  00        
                    9283   @lab6b_139:
00005D10  554E 494E 9284          dc.b      85,78,73,78,73,84,73,65,76,73,83,69,68,32,73
00005D14  4954 4941 
00005D18  4C49 5345 
00005D1C  4420 49   
00005D1F  5251 00   9285          dc.b      82,81,0
                    9286   @lab6b_140:
00005D22  5350 5552 9287          dc.b      83,80,85,82,73,79,85,83,32,73,82,81,0
00005D26  494F 5553 
00005D2A  2049 5251 
00005D2E  00        
                    9288   @lab6b_141:
00005D30  0D0A 5374 9289          dc.b      13,10,83,116,97,114,116,32,65,100,100,114,101
00005D34  6172 7420 
00005D38  4164 6472 
00005D3C  65        
00005D3D  7373 2069 9290          dc.b      115,115,32,105,110,32,77,101,109,111,114,121
00005D41  6E20 4D65 
00005D45  6D6F 7279 
00005D49  3A20 00   9291          dc.b      58,32,0
                    9292   @lab6b_142:
00005D4C  0D0A 456E 9293          dc.b      13,10,69,110,116,101,114,32,83,116,114,105,110
00005D50  7465 7220 
00005D54  5374 7269 
00005D58  6E        
00005D59  6720 2845 9294          dc.b      103,32,40,69,83,67,32,116,111,32,101,110,100
00005D5D  5343 2074 
00005D61  6F20 656E 
00005D65  64        
00005D66  2920 3A00 9295          dc.b      41,32,58,0
                    9296   @lab6b_143:
00005D6A  0D0A 456E 9297          dc.b      13,10,69,110,116,101,114,32,116,104,101,32,118
00005D6E  7465 7220 
00005D72  7468 6520 
00005D76  76        
00005D77  616C 7565 9298          dc.b      97,108,117,101,32,98,101,108,111,119,32,102
00005D7B  2062 656C 
00005D7F  6F77 2066 
00005D83  6F72 2074 9299          dc.b      111,114,32,116,104,101,32,115,105,122,101,32
00005D87  6865 2073 
00005D8B  697A 6520 
00005D8F  6F66 2074 9300          dc.b      111,102,32,116,104,101,32,116,101,115,116,32
00005D93  6865 2074 
00005D97  6573 7420 
00005D9B  796F 7520 9301          dc.b      121,111,117,32,119,111,117,108,100,32,108,105
00005D9F  776F 756C 
00005DA3  6420 6C69 
00005DA7  6B65 2074 9302          dc.b      107,101,32,116,111,32,117,115,101,63,10,49,32
00005DAB  6F20 7573 
00005DAF  653F 0A31 
00005DB3  20        
00005DB4  3D20 6279 9303          dc.b      61,32,98,121,116,101,115,32,40,56,32,98,105
00005DB8  7465 7320 
00005DBC  2838 2062 
00005DC0  69        
00005DC1  7473 290A 9304          dc.b      116,115,41,10,50,32,61,32,119,111,114,100,115
00005DC5  3220 3D20 
00005DC9  776F 7264 
00005DCD  73        
00005DCE  2028 3136 9305          dc.b      32,40,49,54,32,98,105,116,115,41,10,51,32,61
00005DD2  2062 6974 
00005DD6  7329 0A33 
00005DDA  203D      
00005DDC  206C 6F6E 9306          dc.b      32,108,111,110,103,32,119,111,114,100,115,32
00005DE0  6720 776F 
00005DE4  7264 7320 
00005DE8  2833 3220 9307          dc.b      40,51,50,32,98,105,116,115,41,10,0
00005DEC  6269 7473 
00005DF0  290A 00   
                    9308   @lab6b_144:
00005DF4  0A59 6F75 9309          dc.b      10,89,111,117,32,104,97,118,101,32,115,101,108
00005DF8  2068 6176 
00005DFC  6520 7365 
00005E00  6C        
00005E01  6374 6564 9310          dc.b      99,116,101,100,32,116,111,32,117,115,101,32
00005E05  2074 6F20 
00005E09  7573 6520 
00005E0D  6279 7465 9311          dc.b      98,121,116,101,115,32,115,105,122,101,32,100
00005E11  7320 7369 
00005E15  7A65 2064 
00005E19  6174 6120 9312          dc.b      97,116,97,32,116,111,32,116,101,115,116,32,121
00005E1D  746F 2074 
00005E21  6573 7420 
00005E25  79        
00005E26  6F75 7220 9313          dc.b      111,117,114,32,109,101,109,111,114,121,10,0
00005E2A  6D65 6D6F 
00005E2E  7279 0A00 
                    9314   @lab6b_145:
00005E32  4F75 7420 9315          dc.b      79,117,116,32,111,102,32,116,104,101,32,98,101
00005E36  6F66 2074 
00005E3A  6865 2062 
00005E3E  65        
00005E3F  6C6F 7720 9316          dc.b      108,111,119,32,101,120,97,109,112,108,101,32
00005E43  6578 616D 
00005E47  706C 6520 
00005E4B  7465 7374 9317          dc.b      116,101,115,116,32,100,97,116,97,44,32,112,108
00005E4F  2064 6174 
00005E53  612C 2070 
00005E57  6C        
00005E58  6561 7365 9318          dc.b      101,97,115,101,32,115,101,108,101,99,116,32
00005E5C  2073 656C 
00005E60  6563 7420 
00005E64  6F6E 6520 9319          dc.b      111,110,101,32,98,121,32,101,110,116,101,114
00005E68  6279 2065 
00005E6C  6E74 6572 
00005E70  696E 6720 9320          dc.b      105,110,103,32,116,104,101,32,118,97,108,117
00005E74  7468 6520 
00005E78  7661 6C75 
00005E7C  6520 6173 9321          dc.b      101,32,97,115,115,111,99,105,97,116,101,100
00005E80  736F 6369 
00005E84  6174 6564 
00005E88  2074 6F20 9322          dc.b      32,116,111,32,101,97,99,104,32,101,120,97,109
00005E8C  6561 6368 
00005E90  2065 7861 
00005E94  6D        
00005E95  706C 653A 9323          dc.b      112,108,101,58,10,0
00005E99  0A00      
                    9324   @lab6b_146:
00005E9C  3120 3D20 9325          dc.b      49,32,61,32,34,65,65,34,10,50,32,61,32,34,65
00005EA0  2241 4122 
00005EA4  0A32 203D 
00005EA8  2022 41   
00005EAB  4222 0A33 9326          dc.b      66,34,10,51,32,61,32,34,67,67,34,10,52,32,61
00005EAF  203D 2022 
00005EB3  4343 220A 
00005EB7  3420 3D   
00005EBA  2022 4344 9327          dc.b      32,34,67,68,34,10,0
00005EBE  220A 00   
                    9328   @lab6b_147:
00005EC2  0D0A 4552 9329          dc.b      13,10,69,82,82,79,82,58,32,89,111,117,32,104
00005EC6  524F 523A 
00005ECA  2059 6F75 
00005ECE  2068      
00005ED0  6176 6520 9330          dc.b      97,118,101,32,101,110,116,101,114,101,100,32
00005ED4  656E 7465 
00005ED8  7265 6420 
00005EDC  6120 6B65 9331          dc.b      97,32,107,101,121,98,111,97,114,100,32,105,110
00005EE0  7962 6F61 
00005EE4  7264 2069 
00005EE8  6E        
00005EE9  7075 7420 9332          dc.b      112,117,116,32,116,104,97,116,32,100,111,101
00005EED  7468 6174 
00005EF1  2064 6F65 
00005EF5  7320 6E6F 9333          dc.b      115,32,110,111,116,32,97,115,115,111,99,105
00005EF9  7420 6173 
00005EFD  736F 6369 
00005F01  6174 6564 9334          dc.b      97,116,101,100,32,119,105,116,104,32,97,110
00005F05  2077 6974 
00005F09  6820 616E 
00005F0D  206F 7074 9335          dc.b      32,111,112,116,105,111,110,32,97,98,111,118
00005F11  696F 6E20 
00005F15  6162 6F76 
00005F19  652C 2070 9336          dc.b      101,44,32,112,108,101,97,115,101,32,116,114
00005F1D  6C65 6173 
00005F21  6520 7472 
00005F25  7920 6167 9337          dc.b      121,32,97,103,97,105,110,13,10,0
00005F29  6169 6E0D 
00005F2D  0A00      
                    9338   @lab6b_148:
00005F30  0D0A 4552 9339          dc.b      13,10,69,82,82,79,82,58,32,79,112,116,105,111
00005F34  524F 523A 
00005F38  204F 7074 
00005F3C  696F      
00005F3E  6E20 6D65 9340          dc.b      110,32,109,101,109,111,114,121,32,99,111,109
00005F42  6D6F 7279 
00005F46  2063 6F6D 
00005F4A  706C 6963 9341          dc.b      112,108,105,99,97,116,105,111,110,46,32,69,120
00005F4E  6174 696F 
00005F52  6E2E 2045 
00005F56  78        
00005F57  6974 696E 9342          dc.b      105,116,105,110,103,32,109,101,109,111,114,121
00005F5B  6720 6D65 
00005F5F  6D6F 7279 
00005F63  2074 6573 9343          dc.b      32,116,101,115,116,46,46,46,13,10,0
00005F67  742E 2E2E 
00005F6B  0D0A 00   
                    9344   @lab6b_149:
00005F6E  0D0A 506C 9345          dc.b      13,10,80,108,101,97,115,101,32,101,110,116,101
00005F72  6561 7365 
00005F76  2065 6E74 
00005F7A  65        
00005F7B  7220 7468 9346          dc.b      114,32,116,104,101,32,115,116,97,114,116,32
00005F7F  6520 7374 
00005F83  6172 7420 
00005F87  6164 6472 9347          dc.b      97,100,100,114,101,115,115,32,121,111,117,32
00005F8B  6573 7320 
00005F8F  796F 7520 
00005F93  776F 756C 9348          dc.b      119,111,117,108,100,32,108,105,107,101,32,116
00005F97  6420 6C69 
00005F9B  6B65 2074 
00005F9F  6F20 7573 9349          dc.b      111,32,117,115,101,32,102,111,114,32,116,104
00005FA3  6520 666F 
00005FA7  7220 7468 
00005FAB  6520 7465 9350          dc.b      101,32,116,101,115,116,32,100,97,116,97,32,105
00005FAF  7374 2064 
00005FB3  6174 6120 
00005FB7  69        
00005FB8  6E74 6F20 9351          dc.b      110,116,111,32,109,101,109,111,114,121,13,10
00005FBC  6D65 6D6F 
00005FC0  7279 0D0A 
00005FC4  00        9352          dc.b      0
                    9353   @lab6b_150:
00005FC6  0D0A 4552 9354          dc.b      13,10,69,82,82,79,82,58,32,83,116,97,114,116
00005FCA  524F 523A 
00005FCE  2053 7461 
00005FD2  7274      
00005FD4  696E 6720 9355          dc.b      105,110,103,32,65,100,100,114,101,115,115,32
00005FD8  4164 6472 
00005FDC  6573 7320 
00005FE0  6973 206F 9356          dc.b      105,115,32,111,117,116,115,105,100,101,32,111
00005FE4  7574 7369 
00005FE8  6465 206F 
00005FEC  6620 3638 9357          dc.b      102,32,54,56,75,32,109,101,109,111,114,121,32
00005FF0  4B20 6D65 
00005FF4  6D6F 7279 
00005FF8  20        
00005FF9  7261 6E67 9358          dc.b      114,97,110,103,101,46,32,80,108,101,97,115,101
00005FFD  652E 2050 
00006001  6C65 6173 
00006005  65        
00006006  2074 7279 9359          dc.b      32,116,114,121,32,97,103,97,105,110,32,97,110
0000600A  2061 6761 
0000600E  696E 2061 
00006012  6E        
00006013  6420 656E 9360          dc.b      100,32,101,110,115,117,114,101,32,116,104,101
00006017  7375 7265 
0000601B  2074 6865 
0000601F  2061 6464 9361          dc.b      32,97,100,100,114,101,115,115,32,105,115,32
00006023  7265 7373 
00006027  2069 7320 
0000602B  7769 7468 9362          dc.b      119,105,116,104,110,32,48,120,48,56,48,50,48
0000602F  6E20 3078 
00006033  3038 3032 
00006037  30        
00006038  3030 3020 9363          dc.b      48,48,48,32,45,32,48,120,48,57,55,70,70,70,70
0000603C  2D20 3078 
00006040  3039 3746 
00006044  4646 46   
00006047  460D 0A00 9364          dc.b      70,13,10,0
                    9365   @lab6b_151:
0000604C  0D0A 506C 9366          dc.b      13,10,80,108,101,97,115,101,32,101,110,116,101
00006050  6561 7365 
00006054  2065 6E74 
00006058  65        
00006059  7220 7468 9367          dc.b      114,32,116,104,101,32,101,110,100,32,97,100
0000605D  6520 656E 
00006061  6420 6164 
00006065  6472 6573 9368          dc.b      100,114,101,115,115,32,121,111,117,32,119,111
00006069  7320 796F 
0000606D  7520 776F 
00006071  756C 6420 9369          dc.b      117,108,100,32,108,105,107,101,32,116,111,32
00006075  6C69 6B65 
00006079  2074 6F20 
0000607D  7573 6520 9370          dc.b      117,115,101,32,102,111,114,32,116,104,101,32
00006081  666F 7220 
00006085  7468 6520 
00006089  7465 7374 9371          dc.b      116,101,115,116,32,100,97,116,97,32,105,110
0000608D  2064 6174 
00006091  6120 696E 
00006095  206D 656D 9372          dc.b      32,109,101,109,111,114,121,13,10,0
00006099  6F72 790D 
0000609D  0A00      
                    9373   @lab6b_152:
000060A0  0D0A 4552 9374          dc.b      13,10,69,82,82,79,82,58,32,69,110,100,32,65
000060A4  524F 523A 
000060A8  2045 6E64 
000060AC  2041      
000060AE  6464 7265 9375          dc.b      100,100,114,101,115,115,32,105,115,32,111,117
000060B2  7373 2069 
000060B6  7320 6F75 
000060BA  7473 6964 9376          dc.b      116,115,105,100,101,32,111,102,32,54,56,75,32
000060BE  6520 6F66 
000060C2  2036 384B 
000060C6  20        
000060C7  6D65 6D6F 9377          dc.b      109,101,109,111,114,121,32,114,97,110,103,101
000060CB  7279 2072 
000060CF  616E 6765 
000060D3  2E20 506C 9378          dc.b      46,32,80,108,101,97,115,101,32,116,114,121,32
000060D7  6561 7365 
000060DB  2074 7279 
000060DF  20        
000060E0  6167 6169 9379          dc.b      97,103,97,105,110,32,97,110,100,32,101,110,115
000060E4  6E20 616E 
000060E8  6420 656E 
000060EC  73        
000060ED  7572 6520 9380          dc.b      117,114,101,32,116,104,101,32,97,100,100,114
000060F1  7468 6520 
000060F5  6164 6472 
000060F9  6573 7320 9381          dc.b      101,115,115,32,105,115,32,119,105,116,104,110
000060FD  6973 2077 
00006101  6974 686E 
00006105  2030 7830 9382          dc.b      32,48,120,48,56,48,50,48,48,48,48,32,45,32,48
00006109  3830 3230 
0000610D  3030 3020 
00006111  2D20 30   
00006114  7830 3937 9383          dc.b      120,48,57,55,70,70,70,70,70,13,10,0
00006118  4646 4646 
0000611C  460D 0A00 
                    9384   @lab6b_153:
00006120  0D0A 0D0A 9385          dc.b      13,10,13,10,87,114,105,116,105,110,103,32,116
00006124  5772 6974 
00006128  696E 6720 
0000612C  74        
0000612D  6F20 6D65 9386          dc.b      111,32,109,101,109,111,114,121,0
00006131  6D6F 7279 
00006135  00        
                    9387   @lab6b_154:
00006136  0D0A 5752 9388          dc.b      13,10,87,82,73,84,69,58,32,91,37,48,50,88,32
0000613A  4954 453A 
0000613E  205B 2530 
00006142  3258 20   
00006145  746F 2025 9389          dc.b      116,111,32,37,48,56,120,93,0
00006149  3038 785D 
0000614D  00        
                    9390   @lab6b_155:
0000614E  0D0A 0D0A 9391          dc.b      13,10,13,10,83,116,97,114,116,105,110,103,32
00006152  5374 6172 
00006156  7469 6E67 
0000615A  20        
0000615B  6D65 6D6F 9392          dc.b      109,101,109,111,114,121,32,118,97,108,105,100
0000615F  7279 2076 
00006163  616C 6964 
00006167  6174 696F 9393          dc.b      97,116,105,111,110,32,116,101,115,116,0
0000616B  6E20 7465 
0000616F  7374 00   
                    9394   @lab6b_156:
00006172  0D0A 5665 9395          dc.b      13,10,86,101,114,105,102,121,105,110,103,32
00006176  7269 6679 
0000617A  696E 6720 
0000617E  7468 6520 9396          dc.b      116,104,101,32,97,100,100,114,101,115,115,101
00006182  6164 6472 
00006186  6573 7365 
0000618A  7320 5B25 9397          dc.b      115,32,91,37,48,56,120,32,116,111,32,37,48,56
0000618E  3038 7820 
00006192  746F 2025 
00006196  3038      
00006198  785D 2063 9398          dc.b      120,93,32,99,111,110,116,97,105,110,115,32,116
0000619C  6F6E 7461 
000061A0  696E 7320 
000061A4  74        
000061A5  6573 7420 9399          dc.b      101,115,116,32,100,97,116,97,32,91,37,48,50
000061A9  6461 7461 
000061AD  205B 2530 
000061B1  32        
000061B2  585D 2E2E 9400          dc.b      88,93,46,46,46,46,46,0
000061B6  2E2E 2E00 
                    9401   @lab6b_157:
000061BA  0D0A 4552 9402          dc.b      13,10,69,82,82,79,82,58,32,68,97,116,97,32,119
000061BE  524F 523A 
000061C2  2044 6174 
000061C6  6120 77   
000061C9  6974 6869 9403          dc.b      105,116,104,105,110,32,109,101,109,111,114,121
000061CD  6E20 6D65 
000061D1  6D6F 7279 
000061D5  2064 6F65 9404          dc.b      32,100,111,101,115,32,110,111,116,32,109,97
000061D9  7320 6E6F 
000061DD  7420 6D61 
000061E1  7463 6820 9405          dc.b      116,99,104,32,115,101,108,101,99,116,101,100
000061E5  7365 6C65 
000061E9  6374 6564 
000061ED  2074 6573 9406          dc.b      32,116,101,115,116,32,100,97,116,97,33,32,91
000061F1  7420 6461 
000061F5  7461 2120 
000061F9  5B        
000061FA  4164 6472 9407          dc.b      65,100,100,114,101,115,115,58,32,37,48,56,120
000061FE  6573 733A 
00006202  2025 3038 
00006206  78        
00006207  2045 7861 9408          dc.b      32,69,120,97,99,116,32,68,97,116,97,58,32,37
0000620B  6374 2044 
0000620F  6174 613A 
00006213  2025      
00006215  3032 5820 9409          dc.b      48,50,88,32,69,120,112,101,99,116,101,100,32
00006219  4578 7065 
0000621D  6374 6564 
00006221  20        
00006222  4461 7461 9410          dc.b      68,97,116,97,58,32,37,48,50,88,93,32,69,120
00006226  3A20 2530 
0000622A  3258 5D20 
0000622E  4578      
00006230  6974 696E 9411          dc.b      105,116,105,110,103,32,109,101,109,111,114,121
00006234  6720 6D65 
00006238  6D6F 7279 
0000623C  2074 6573 9412          dc.b      32,116,101,115,116,46,46,46,13,10,0
00006240  742E 2E2E 
00006244  0D0A 00   
                    9413   @lab6b_158:
00006248  0D0A 5041 9414          dc.b      13,10,80,65,83,83,58,32,77,101,109,111,114,121
0000624C  5353 3A20 
00006250  4D65 6D6F 
00006254  7279      
00006256  2056 616C 9415          dc.b      32,86,97,108,105,100,97,116,105,111,110,32,116
0000625A  6964 6174 
0000625E  696F 6E20 
00006262  74        
00006263  6573 7420 9416          dc.b      101,115,116,32,104,97,115,32,112,97,115,115
00006267  6861 7320 
0000626B  7061 7373 
0000626F  6564 210D 9417          dc.b      101,100,33,13,10,0
00006273  0A00      
                    9418   @lab6b_159:
00006276  0D0A 596F 9419          dc.b      13,10,89,111,117,32,104,97,118,101,32,115,101
0000627A  7520 6861 
0000627E  7665 2073 
00006282  65        
00006283  6C63 7465 9420          dc.b      108,99,116,101,100,32,116,111,32,117,115,101
00006287  6420 746F 
0000628B  2075 7365 
0000628F  2077 6F72 9421          dc.b      32,119,111,114,100,32,115,105,122,101,32,100
00006293  6420 7369 
00006297  7A65 2064 
0000629B  6174 6120 9422          dc.b      97,116,97,32,116,111,32,116,101,115,116,32,121
0000629F  746F 2074 
000062A3  6573 7420 
000062A7  79        
000062A8  6F75 7220 9423          dc.b      111,117,114,32,109,101,109,111,114,121,0
000062AC  6D65 6D6F 
000062B0  7279 00   
                    9424   @lab6b_160:
000062B4  0D0A 4F75 9425          dc.b      13,10,79,117,116,32,111,102,32,116,104,101,32
000062B8  7420 6F66 
000062BC  2074 6865 
000062C0  20        
000062C1  6265 6C6F 9426          dc.b      98,101,108,111,119,32,101,120,97,109,112,108
000062C5  7720 6578 
000062C9  616D 706C 
000062CD  6520 7465 9427          dc.b      101,32,116,101,115,116,32,100,97,116,97,44,32
000062D1  7374 2064 
000062D5  6174 612C 
000062D9  20        
000062DA  706C 6561 9428          dc.b      112,108,101,97,115,101,32,115,101,108,101,99
000062DE  7365 2073 
000062E2  656C 6563 
000062E6  7420 6F6E 9429          dc.b      116,32,111,110,101,32,98,121,32,101,110,116
000062EA  6520 6279 
000062EE  2065 6E74 
000062F2  6572 696E 9430          dc.b      101,114,105,110,103,32,116,104,101,32,118,97
000062F6  6720 7468 
000062FA  6520 7661 
000062FE  6C75 6520 9431          dc.b      108,117,101,32,97,115,115,111,99,105,97,116
00006302  6173 736F 
00006306  6369 6174 
0000630A  6564 2074 9432          dc.b      101,100,32,116,111,32,101,97,99,104,32,101,120
0000630E  6F20 6561 
00006312  6368 2065 
00006316  78        
00006317  616D 706C 9433          dc.b      97,109,112,108,101,58,0
0000631B  653A 00   
                    9434   @lab6b_161:
0000631E  0D0A 3120 9435          dc.b      13,10,49,32,61,32,34,65,65,65,65,34,10,50,32
00006322  3D20 2241 
00006326  4141 4122 
0000632A  0A32 20   
0000632D  3D20 2242 9436          dc.b      61,32,34,66,65,66,65,34,10,51,32,61,32,34,67
00006331  4142 4122 
00006335  0A33 203D 
00006339  2022 43   
0000633C  4344 4422 9437          dc.b      67,68,68,34,10,52,32,61,32,34,68,68,68,68,34
00006340  0A34 203D 
00006344  2022 4444 
00006348  4444 22   
0000634B  0D0A 00   9438          dc.b      13,10,0
                    9439   @lab6b_162:
0000634E  0D0A 506C 9440          dc.b      13,10,80,108,101,97,115,101,32,101,110,116,101
00006352  6561 7365 
00006356  2065 6E74 
0000635A  65        
0000635B  7220 7468 9441          dc.b      114,32,116,104,101,32,115,116,97,114,116,32
0000635F  6520 7374 
00006363  6172 7420 
00006367  6164 6472 9442          dc.b      97,100,100,114,101,115,115,32,121,111,117,32
0000636B  6573 7320 
0000636F  796F 7520 
00006373  776F 756C 9443          dc.b      119,111,117,108,100,32,108,105,107,101,32,116
00006377  6420 6C69 
0000637B  6B65 2074 
0000637F  6F20 7573 9444          dc.b      111,32,117,115,101,32,102,111,114,32,116,104
00006383  6520 666F 
00006387  7220 7468 
0000638B  6520 7465 9445          dc.b      101,32,116,101,115,116,32,100,97,116,97,32,105
0000638F  7374 2064 
00006393  6174 6120 
00006397  69        
00006398  6E74 6F20 9446          dc.b      110,116,111,32,109,101,109,111,114,121,32,40
0000639C  6D65 6D6F 
000063A0  7279 2028 
000063A4  456E 7375 9447          dc.b      69,110,115,117,114,101,32,116,111,32,101,110
000063A8  7265 2074 
000063AC  6F20 656E 
000063B0  7465 7220 9448          dc.b      116,101,114,32,97,110,32,101,118,101,110,32
000063B4  616E 2065 
000063B8  7665 6E20 
000063BC  6E75 6D62 9449          dc.b      110,117,109,98,101,114,41,13,10,0
000063C0  6572 290D 
000063C4  0A00      
                    9450   @lab6b_163:
000063C6  0D0A 4552 9451          dc.b      13,10,69,82,82,79,82,58,32,83,116,97,114,116
000063CA  524F 523A 
000063CE  2053 7461 
000063D2  7274      
000063D4  696E 6720 9452          dc.b      105,110,103,32,65,100,100,114,101,115,115,32
000063D8  4164 6472 
000063DC  6573 7320 
000063E0  6973 206F 9453          dc.b      105,115,32,111,117,116,115,105,100,101,32,111
000063E4  7574 7369 
000063E8  6465 206F 
000063EC  6620 3638 9454          dc.b      102,32,54,56,75,32,109,101,109,111,114,121,32
000063F0  4B20 6D65 
000063F4  6D6F 7279 
000063F8  20        
000063F9  7261 6E67 9455          dc.b      114,97,110,103,101,46,32,80,108,101,97,115,101
000063FD  652E 2050 
00006401  6C65 6173 
00006405  65        
00006406  2074 7279 9456          dc.b      32,116,114,121,32,97,103,97,105,110,32,97,110
0000640A  2061 6761 
0000640E  696E 2061 
00006412  6E        
00006413  6420 656E 9457          dc.b      100,32,101,110,115,117,114,101,32,116,104,101
00006417  7375 7265 
0000641B  2074 6865 
0000641F  2061 6464 9458          dc.b      32,97,100,100,114,101,115,115,32,105,115,32
00006423  7265 7373 
00006427  2069 7320 
0000642B  7769 7468 9459          dc.b      119,105,116,104,110,32,48,120,48,57,48,48,48
0000642F  6E20 3078 
00006433  3039 3030 
00006437  30        
00006438  3030 3020 9460          dc.b      48,48,48,32,45,32,48,120,48,57,55,70,70,70,70
0000643C  2D20 3078 
00006440  3039 3746 
00006444  4646 46   
00006447  460D 0A00 9461          dc.b      70,13,10,0
                    9462   @lab6b_164:
0000644C  0D0A 4552 9463          dc.b      13,10,69,82,82,79,82,58,32,84,104,101,32,97
00006450  524F 523A 
00006454  2054 6865 
00006458  2061      
0000645A  6464 7265 9464          dc.b      100,100,114,101,115,115,32,121,111,117,32,104
0000645E  7373 2079 
00006462  6F75 2068 
00006466  6176 6520 9465          dc.b      97,118,101,32,101,110,116,101,114,101,100,32
0000646A  656E 7465 
0000646E  7265 6420 
00006472  6973 206E 9466          dc.b      105,115,32,110,111,116,32,101,118,101,110,46
00006476  6F74 2065 
0000647A  7665 6E2E 
0000647E  2050 6C65 9467          dc.b      32,80,108,101,97,115,101,32,116,114,121,32,97
00006482  6173 6520 
00006486  7472 7920 
0000648A  61        
0000648B  6761 696E 9468          dc.b      103,97,105,110,13,10,0
0000648F  0D0A 00   
                    9469   @lab6b_165:
00006492  0D0A 506C 9470          dc.b      13,10,80,108,101,97,115,101,32,101,110,116,101
00006496  6561 7365 
0000649A  2065 6E74 
0000649E  65        
0000649F  7220 7468 9471          dc.b      114,32,116,104,101,32,101,110,100,32,97,100
000064A3  6520 656E 
000064A7  6420 6164 
000064AB  6472 6573 9472          dc.b      100,114,101,115,115,32,121,111,117,32,119,111
000064AF  7320 796F 
000064B3  7520 776F 
000064B7  756C 6420 9473          dc.b      117,108,100,32,108,105,107,101,32,116,111,32
000064BB  6C69 6B65 
000064BF  2074 6F20 
000064C3  7573 6520 9474          dc.b      117,115,101,32,102,111,114,32,116,104,101,32
000064C7  666F 7220 
000064CB  7468 6520 
000064CF  7465 7374 9475          dc.b      116,101,115,116,32,100,97,116,97,32,105,110
000064D3  2064 6174 
000064D7  6120 696E 
000064DB  206D 656D 9476          dc.b      32,109,101,109,111,114,121,32,40,69,110,115
000064DF  6F72 7920 
000064E3  2845 6E73 
000064E7  7572 6520 9477          dc.b      117,114,101,32,116,111,32,101,110,116,101,114
000064EB  746F 2065 
000064EF  6E74 6572 
000064F3  2061 6E20 9478          dc.b      32,97,110,32,101,118,101,110,32,110,117,109
000064F7  6576 656E 
000064FB  206E 756D 
000064FF  6265 7229 9479          dc.b      98,101,114,41,13,10,0
00006503  0D0A 00   
                    9480   @lab6b_166:
00006506  0D0A 4552 9481          dc.b      13,10,69,82,82,79,82,58,32,69,110,100,32,65
0000650A  524F 523A 
0000650E  2045 6E64 
00006512  2041      
00006514  6464 7265 9482          dc.b      100,100,114,101,115,115,32,105,115,32,111,117
00006518  7373 2069 
0000651C  7320 6F75 
00006520  7473 6964 9483          dc.b      116,115,105,100,101,32,111,102,32,54,56,75,32
00006524  6520 6F66 
00006528  2036 384B 
0000652C  20        
0000652D  6D65 6D6F 9484          dc.b      109,101,109,111,114,121,32,114,97,110,103,101
00006531  7279 2072 
00006535  616E 6765 
00006539  2E20 506C 9485          dc.b      46,32,80,108,101,97,115,101,32,116,114,121,32
0000653D  6561 7365 
00006541  2074 7279 
00006545  20        
00006546  6167 6169 9486          dc.b      97,103,97,105,110,32,97,110,100,32,101,110,115
0000654A  6E20 616E 
0000654E  6420 656E 
00006552  73        
00006553  7572 6520 9487          dc.b      117,114,101,32,116,104,101,32,97,100,100,114
00006557  7468 6520 
0000655B  6164 6472 
0000655F  6573 7320 9488          dc.b      101,115,115,32,105,115,32,119,105,116,104,110
00006563  6973 2077 
00006567  6974 686E 
0000656B  2030 7830 9489          dc.b      32,48,120,48,57,48,48,48,48,48,48,32,45,32,48
0000656F  3930 3030 
00006573  3030 3020 
00006577  2D20 30   
0000657A  7830 3937 9490          dc.b      120,48,57,55,70,70,70,70,70,13,10,0
0000657E  4646 4646 
00006582  460D 0A00 
                    9491   @lab6b_167:
00006586  0D0A 5752 9492          dc.b      13,10,87,82,73,84,69,58,32,91,37,48,52,88,32
0000658A  4954 453A 
0000658E  205B 2530 
00006592  3458 20   
00006595  746F 2025 9493          dc.b      116,111,32,37,48,56,120,93,0
00006599  3038 785D 
0000659D  00        
                    9494   @lab6b_168:
0000659E  0D0A 4552 9495          dc.b      13,10,69,82,82,79,82,58,32,68,97,116,97,32,119
000065A2  524F 523A 
000065A6  2044 6174 
000065AA  6120 77   
000065AD  6974 6869 9496          dc.b      105,116,104,105,110,32,109,101,109,111,114,121
000065B1  6E20 6D65 
000065B5  6D6F 7279 
000065B9  2064 6F65 9497          dc.b      32,100,111,101,115,32,110,111,116,32,109,97
000065BD  7320 6E6F 
000065C1  7420 6D61 
000065C5  7463 6820 9498          dc.b      116,99,104,32,115,101,108,101,99,116,101,100
000065C9  7365 6C65 
000065CD  6374 6564 
000065D1  2074 6573 9499          dc.b      32,116,101,115,116,32,100,97,116,97,33,32,91
000065D5  7420 6461 
000065D9  7461 2120 
000065DD  5B        
000065DE  4164 6472 9500          dc.b      65,100,100,114,101,115,115,58,32,37,48,56,120
000065E2  6573 733A 
000065E6  2025 3038 
000065EA  78        
000065EB  2045 7861 9501          dc.b      32,69,120,97,99,116,32,68,97,116,97,58,32,37
000065EF  6374 2044 
000065F3  6174 613A 
000065F7  2025      
000065F9  3032 5820 9502          dc.b      48,50,88,32,69,120,112,101,99,116,101,100,32
000065FD  4578 7065 
00006601  6374 6564 
00006605  20        
00006606  4461 7461 9503          dc.b      68,97,116,97,58,32,37,48,50,88,93,32,69,120
0000660A  3A20 2530 
0000660E  3258 5D20 
00006612  4578      
00006614  6974 696E 9504          dc.b      105,116,105,110,103,32,109,101,109,111,114,121
00006618  6720 6D65 
0000661C  6D6F 7279 
00006620  2074 6573 9505          dc.b      32,116,101,115,116,46,46,46,0
00006624  742E 2E2E 
00006628  00        
                    9506   @lab6b_169:
0000662A  0D0A 596F 9507          dc.b      13,10,89,111,117,32,104,97,118,101,32,115,101
0000662E  7520 6861 
00006632  7665 2073 
00006636  65        
00006637  6C63 7465 9508          dc.b      108,99,116,101,100,32,116,111,32,117,115,101
0000663B  6420 746F 
0000663F  2075 7365 
00006643  2062 7974 9509          dc.b      32,98,121,116,101,115,32,115,105,122,101,32
00006647  6573 2073 
0000664B  697A 6520 
0000664F  6461 7461 9510          dc.b      100,97,116,97,32,116,111,32,116,101,115,116
00006653  2074 6F20 
00006657  7465 7374 
0000665B  2079 6F75 9511          dc.b      32,121,111,117,114,32,109,101,109,111,114,121
0000665F  7220 6D65 
00006663  6D6F 7279 
00006667  00        9512          dc.b      0
                    9513   @lab6b_170:
00006668  0D0A 3120 9514          dc.b      13,10,49,32,61,32,34,65,65,65,65,65,65,65,65
0000666C  3D20 2241 
00006670  4141 4141 
00006674  4141 41   
00006677  220A 3220 9515          dc.b      34,10,50,32,61,32,34,65,66,65,66,65,66,65,66
0000667B  3D20 2241 
0000667F  4241 4241 
00006683  4241 42   
00006686  220A 3320 9516          dc.b      34,10,51,32,61,32,34,67,67,67,67,68,68,68,68
0000668A  3D20 2243 
0000668E  4343 4344 
00006692  4444 44   
00006695  220A 3420 9517          dc.b      34,10,52,32,61,32,34,65,65,66,66,67,67,68,68
00006699  3D20 2241 
0000669D  4142 4243 
000066A1  4344 44   
000066A4  220D 0A00 9518          dc.b      34,13,10,0
                    9519   @lab6b_171:
000066A8  0D0A 5741 9520          dc.b      13,10,87,65,82,78,73,78,71,58,32,77,101,109
000066AC  524E 494E 
000066B0  473A 204D 
000066B4  656D      
000066B6  6F72 7920 9521          dc.b      111,114,121,32,119,105,108,108,32,99,111,110
000066BA  7769 6C6C 
000066BE  2063 6F6E 
000066C2  7461 696E 9522          dc.b      116,97,105,110,32,116,114,117,110,99,97,116
000066C6  2074 7275 
000066CA  6E63 6174 
000066CE  6564 2064 9523          dc.b      101,100,32,100,97,116,97,0
000066D2  6174 6100 
                    9524   @lab6b_172:
000066D6  0D0A 5752 9525          dc.b      13,10,87,82,73,84,69,58,32,91,37,48,56,88,32
000066DA  4954 453A 
000066DE  205B 2530 
000066E2  3858 20   
000066E5  746F 2025 9526          dc.b      116,111,32,37,48,56,120,93,0
000066E9  3038 785D 
000066ED  00        
                    9527   @lab6b_173:
000066EE  0D0A 4552 9528          dc.b      13,10,69,82,82,79,82,58,32,68,97,116,97,32,119
000066F2  524F 523A 
000066F6  2044 6174 
000066FA  6120 77   
000066FD  6974 6869 9529          dc.b      105,116,104,105,110,32,109,101,109,111,114,121
00006701  6E20 6D65 
00006705  6D6F 7279 
00006709  2064 6F65 9530          dc.b      32,100,111,101,115,32,110,111,116,32,109,97
0000670D  7320 6E6F 
00006711  7420 6D61 
00006715  7463 6820 9531          dc.b      116,99,104,32,115,101,108,101,99,116,101,100
00006719  7365 6C65 
0000671D  6374 6564 
00006721  2074 6573 9532          dc.b      32,116,101,115,116,32,100,97,116,97,33,32,91
00006725  7420 6461 
00006729  7461 2120 
0000672D  5B        
0000672E  4164 6472 9533          dc.b      65,100,100,114,101,115,115,58,32,37,48,56,120
00006732  6573 733A 
00006736  2025 3038 
0000673A  78        
0000673B  2045 7861 9534          dc.b      32,69,120,97,99,116,32,68,97,116,97,58,32,37
0000673F  6374 2044 
00006743  6174 613A 
00006747  2025      
00006749  3038 5820 9535          dc.b      48,56,88,32,69,120,112,101,99,116,101,100,32
0000674D  4578 7065 
00006751  6374 6564 
00006755  20        
00006756  4461 7461 9536          dc.b      68,97,116,97,58,32,37,48,56,88,93,32,69,120
0000675A  3A20 2530 
0000675E  3858 5D20 
00006762  4578      
00006764  6974 696E 9537          dc.b      105,116,105,110,103,32,109,101,109,111,114,121
00006768  6720 6D65 
0000676C  6D6F 7279 
00006770  2074 6573 9538          dc.b      32,116,101,115,116,46,46,46,13,10,0
00006774  742E 2E2E 
00006778  0D0A 00   
                    9539   @lab6b_174:
0000677C  0D0A 596F 9540          dc.b      13,10,89,111,117,32,102,97,105,108,101,100,32
00006780  7520 6661 
00006784  696C 6564 
00006788  20        
00006789  746F 2073 9541          dc.b      116,111,32,115,101,108,101,99,116,32,97,32,100
0000678D  656C 6563 
00006791  7420 6120 
00006795  64        
00006796  6174 6120 9542          dc.b      97,116,97,32,116,121,112,101,32,116,111,32,117
0000679A  7479 7065 
0000679E  2074 6F20 
000067A2  75        
000067A3  7365 2120 9543          dc.b      115,101,33,32,67,108,105,99,107,32,111,112,101
000067A7  436C 6963 
000067AB  6B20 6F70 
000067AF  65        
000067B0  6E20 6D65 9544          dc.b      110,32,109,101,109,111,114,121,32,116,101,115
000067B4  6D6F 7279 
000067B8  2074 6573 
000067BC  7420 6167 9545          dc.b      116,32,97,103,97,105,110,32,116,111,32,116,114
000067C0  6169 6E20 
000067C4  746F 2074 
000067C8  72        
000067C9  7920 6167 9546          dc.b      121,32,97,103,97,105,110,46,13,10,0
000067CD  6169 6E2E 
000067D1  0D0A 00   
                    9547   @lab6b_175:
000067D4  0D0A 4932 9548          dc.b      13,10,73,50,67,32,87,114,105,116,101,58,0
000067D8  4320 5772 
000067DC  6974 653A 
000067E0  00        
                    9549   @lab6b_176:
000067E2  0D0A 456E 9550          dc.b      13,10,69,110,116,101,114,101,100,32,65,100,100
000067E6  7465 7265 
000067EA  6420 4164 
000067EE  64        
000067EF  7265 7373 9551          dc.b      114,101,115,115,32,105,115,32,105,110,118,97
000067F3  2069 7320 
000067F7  696E 7661 
000067FB  6C69 642C 9552          dc.b      108,105,100,44,32,112,108,101,97,115,101,32
000067FF  2070 6C65 
00006803  6173 6520 
00006807  656E 7465 9553          dc.b      101,110,116,101,114,32,97,32,115,109,97,108
0000680B  7220 6120 
0000680F  736D 616C 
00006813  6C65 7220 9554          dc.b      108,101,114,32,118,97,108,117,101,100,32,97
00006817  7661 6C75 
0000681B  6564 2061 
0000681F  6464 7265 9555          dc.b      100,100,114,101,115,115,46,32,82,101,116,117
00006823  7373 2E20 
00006827  5265 7475 
0000682B  726E 696E 9556          dc.b      114,110,105,110,103,32,98,97,99,107,32,116,111
0000682F  6720 6261 
00006833  636B 2074 
00006837  6F        
00006838  2074 6865 9557          dc.b      32,116,104,101,32,100,101,98,117,103,32,109
0000683C  2064 6562 
00006840  7567 206D 
00006844  6F6E 6974 9558          dc.b      111,110,105,116,111,114,32,109,101,110,117,0
00006848  6F72 206D 
0000684C  656E 7500 
                    9559   @lab6b_177:
00006850  0D0A 456E 9560          dc.b      13,10,69,110,116,101,114,32,68,97,116,97,58
00006854  7465 7220 
00006858  4461 7461 
0000685C  3A        
0000685D  2000      9561          dc.b      32,0
                    9562   @lab6b_178:
00006860  0D0A 4932 9563          dc.b      13,10,73,50,67,32,82,101,97,100,58,0
00006864  4320 5265 
00006868  6164 3A00 
                    9564   @lab6b_179:
0000686C  0D0A 4932 9565          dc.b      13,10,73,50,67,32,80,97,103,101,32,87,114,105
00006870  4320 5061 
00006874  6765 2057 
00006878  7269      
0000687A  7465 3A00 9566          dc.b      116,101,58,0
                    9567   @lab6b_180:
0000687E  0D0A 456E 9568          dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
00006882  7465 7220 
00006886  4164 6472 
0000688A  65        
0000688B  7373 2046 9569          dc.b      115,115,32,70,114,111,109,58,32,0
0000688F  726F 6D3A 
00006893  2000      
                    9570   @lab6b_181:
00006896  0D0A 456E 9571          dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
0000689A  7465 7220 
0000689E  4164 6472 
000068A2  65        
000068A3  7373 2054 9572          dc.b      115,115,32,84,111,58,32,0
000068A7  6F3A 2000 
                    9573   @lab6b_182:
000068AC  0D0A 4932 9574          dc.b      13,10,73,50,67,32,83,101,113,32,82,101,97,100
000068B0  4320 5365 
000068B4  7120 5265 
000068B8  6164      
000068BA  3A00      9575          dc.b      58,0
                    9576   @lab6b_183:
000068BC  4445 312D 9577          dc.b      68,69,49,45,54,56,107,32,66,117,103,32,86,49
000068C0  3638 6B20 
000068C4  4275 6720 
000068C8  5631      
000068CA  2E37 3700 9578          dc.b      46,55,55,0
                    9579   @lab6b_184:
000068CE  436F 7079 9580          dc.b      67,111,112,121,114,105,103,104,116,32,40,67
000068D2  7269 6768 
000068D6  7420 2843 
000068DA  2920 504A 9581          dc.b      41,32,80,74,32,68,97,118,105,101,115,32,50,48
000068DE  2044 6176 
000068E2  6965 7320 
000068E6  3230      
000068E8  3136 00   9582          dc.b      49,54,0
                    9583   @lab6b_185:
000068EC  0D0A 0D0A 9584          dc.b      13,10,13,10,75,101,110,110,121,32,87,97,107
000068F0  4B65 6E6E 
000068F4  7920 5761 
000068F8  6B        
000068F9  6162 6120 9585          dc.b      97,98,97,32,45,32,57,49,51,55,56,51,49,53,13
000068FD  2D20 3931 
00006901  3337 3833 
00006905  3135 0D   
00006908  0A4A 6163 9586          dc.b      10,74,97,99,111,98,32,89,97,110,103,32,45,32
0000690C  6F62 2059 
00006910  616E 6720 
00006914  2D20      
00006916  3234 3934 9587          dc.b      50,52,57,52,48,56,51,53,0
0000691A  3038 3335 
0000691E  00        
                    9588   @lab6b_186:
00006920  0D0A 5275 9589          dc.b      13,10,82,117,110,110,105,110,103,46,46,46,46
00006924  6E6E 696E 
00006928  672E 2E2E 
0000692C  2E        
0000692D  2E00      9590          dc.b      46,0
                    9591   @lab6b_187:
00006930  5275 6E6E 9592          dc.b      82,117,110,110,105,110,103,46,46,46,46,46,0
00006934  696E 672E 
00006938  2E2E 2E2E 
0000693C  00        
                    9593   @lab6b_188:
0000693E  4279 3A20 9594          dc.b      66,121,58,32,80,74,32,68,97,118,105,101,115
00006942  504A 2044 
00006946  6176 6965 
0000694A  73        
0000694B  00        9595          dc.b      0
                    9596   @lab6b_189:
0000694C  0D0A 2573 9597          dc.b      13,10,37,115,0
00006950  00        
                    9598   @i2c_1:
00006952  0D0A 5772 9599          dc.b      13,10,87,114,111,116,101,32,91,37,120,93,32
00006956  6F74 6520 
0000695A  5B25 785D 
0000695E  20        
0000695F  746F 2041 9600          dc.b      116,111,32,65,100,100,114,101,115,115,91,37
00006963  6464 7265 
00006967  7373 5B25 
0000696B  785D 00   9601          dc.b      120,93,0
                    9602   @i2c_2:
0000696E  0D0A 5772 9603          dc.b      13,10,87,114,111,116,101,32,91,37,120,93,32
00006972  6F74 6520 
00006976  5B25 785D 
0000697A  20        
0000697B  6672 6F6D 9604          dc.b      102,114,111,109,32,65,100,100,114,101,115,115
0000697F  2041 6464 
00006983  7265 7373 
00006987  5B25 785D 9605          dc.b      91,37,120,93,32,116,111,32,65,100,100,114,101
0000698B  2074 6F20 
0000698F  4164 6472 
00006993  65        
00006994  7373 5B25 9606          dc.b      115,115,91,37,120,93,0
00006998  785D 00   
                    9607   @i2c_3:
0000699C  0D0A 5265 9608          dc.b      13,10,82,101,97,100,32,91,37,120,93,32,102,114
000069A0  6164 205B 
000069A4  2578 5D20 
000069A8  6672      
000069AA  6F6D 2041 9609          dc.b      111,109,32,65,100,100,114,101,115,115,91,37
000069AE  6464 7265 
000069B2  7373 5B25 
000069B6  785D 00   9610          dc.b      120,93,0
                    9611   @i2c_4:
000069BA  0D0A 426C 9612          dc.b      13,10,66,108,111,99,107,32,82,101,97,100,32
000069BE  6F63 6B20 
000069C2  5265 6164 
000069C6  20        
000069C7  6F70 6572 9613          dc.b      111,112,101,114,97,116,105,111,110,32,99,111
000069CB  6174 696F 
000069CF  6E20 636F 
000069D3  6D70 6C65 9614          dc.b      109,112,108,101,116,101,13,10,0
000069D7  7465 0D0A 
000069DB  00        
                    9615   @i2c_5:
000069DC  0A49 3243 9616          dc.b      10,73,50,67,32,68,65,67,32,87,114,105,116,101
000069E0  2044 4143 
000069E4  2057 7269 
000069E8  7465      
000069EA  3A20 506C 9617          dc.b      58,32,80,108,101,97,115,101,32,99,104,101,99
000069EE  6561 7365 
000069F2  2063 6865 
000069F6  63        
000069F7  6B20 4C45 9618          dc.b      107,32,76,69,68,10,0
000069FB  440A 00   
                    9619   @canbus_1:
000069FE  4361 6E30 9620          dc.b      67,97,110,48,32,114,101,99,105,101,118,101,32
00006A02  2072 6563 
00006A06  6965 7665 
00006A0A  20        
00006A0B  6461 7461 9621          dc.b      100,97,116,97,32,97,116,32,105,110,100,101,120
00006A0F  2061 7420 
00006A13  696E 6465 
00006A17  78        
00006A18  2030 3A20 9622          dc.b      32,48,58,32,37,100,10,0
00006A1C  2564 0A00 
                    9623   @canbus_2:
00006A20  4361 6E30 9624          dc.b      67,97,110,48,32,114,101,99,105,101,118,101,32
00006A24  2072 6563 
00006A28  6965 7665 
00006A2C  20        
00006A2D  6461 7461 9625          dc.b      100,97,116,97,32,97,116,32,105,110,100,101,120
00006A31  2061 7420 
00006A35  696E 6465 
00006A39  78        
00006A3A  2031 3A20 9626          dc.b      32,49,58,32,37,100,10,0
00006A3E  2564 0A00 
                    9627   @canbus_3:
00006A42  4361 6E31 9628          dc.b      67,97,110,49,32,114,101,99,105,101,118,101,32
00006A46  2072 6563 
00006A4A  6965 7665 
00006A4E  20        
00006A4F  6461 7461 9629          dc.b      100,97,116,97,32,97,116,32,105,110,100,101,120
00006A53  2061 7420 
00006A57  696E 6465 
00006A5B  78        
00006A5C  2030 3A20 9630          dc.b      32,48,58,32,37,100,10,0
00006A60  2564 0A00 
                    9631   @canbus_4:
00006A64  4361 6E31 9632          dc.b      67,97,110,49,32,114,101,99,105,101,118,101,32
00006A68  2072 6563 
00006A6C  6965 7665 
00006A70  20        
00006A71  6461 7461 9633          dc.b      100,97,116,97,32,97,116,32,105,110,100,101,120
00006A75  2061 7420 
00006A79  696E 6465 
00006A7D  78        
00006A7E  2031 3A20 9634          dc.b      32,49,58,32,37,100,10,0
00006A82  2564 0A00 
                    9635   @canbus_5:
00006A86  0D0A 0D0A 9636          dc.b      13,10,13,10,45,45,45,45,32,67,65,78,66,85,83
00006A8A  2D2D 2D2D 
00006A8E  2043 414E 
00006A92  4255 53   
00006A95  2054 6573 9637          dc.b      32,84,101,115,116,32,45,45,45,45,13,10,0
00006A99  7420 2D2D 
00006A9D  2D2D 0D0A 
00006AA1  00        
                    9638   @canbus_6:
00006AA2  0D0A 00   9639          dc.b      13,10,0
                    9640          section   data
00006AA6            9641                   align
          0000 6AA6 9642   DataStart       equ       *
                    9643   
                    9644   *********************************************************************************************************
                    9645   * Data Section for Initialised Data - these will be placed in rom as constants and have to be copied
                    9646   * to ram as part of the CStart routine in this file
                    9647   *********************************************************************************************************
                    9648   
                    9649   MemoryTest_test_data_byte_list:
00006AA6  AAAB CCCD 9650          dc.b      170,171,204,205
                    9651   MemoryTest_test_data_word_list:
00006AAA  0000 AAAA 9652          dc.l      43690,47802,52445,56797
00006AAE  0000 BABA 
00006AB2  0000 CCDD 
00006AB6  0000 DDDD 
                    9653   MemoryTest_test_data_long_word_list:
00006ABA  AAAA AAAA 9654          dc.l      -1431655766,-1414812757,-858989091,-1430532899
00006ABE  ABAB ABAB 
00006AC2  CCCC DDDD 
00006AC6  AABB CCDD 
                    9655   @itoa_1:
00006ACA  2D32 3134 9656          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
00006ACE  3734 3833 
00006AD2  3634 3800 
                    9657          section   bss
00006AD6            9658                   align
          0000 6AD6 9659   DataEnd         equ     *                       this label will equate to the address of the last byte of global variable in it
                    9660   
                    9661   *********************************************************************************************************
                    9662   * Section for Uninitialised Data held in ROM as constants
                    9663   *********************************************************************************************************
                    9664   
0B000000            9665                   org     RamVectorTable          Ram based vector table must be stored here otherwise InstallException Handler will not work
          0000 0030 9666   DataLength      equ     DataEnd-DataStart       length of data needed to copy to Ram on bootup
                    9667   
                    9668   
0B000000            9669   bss             org       bss
                    9670   
                    9671   *********************************************************************************************************
                    9672   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    9673   * install the exception handler using the C function InstallExceptionHandler()
                    9674   *********************************************************************************************************
                    9675   
                    9676   
                    9677   
0B000000            9678   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
0B000004            9679   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
0B000008            9680   VBusError        ds.l    1      storage for address of Bus Error Handler
0B00000C            9681   VAddressError    ds.l    1      storage for address of Address Error Handler
0B000010            9682   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
0B000014            9683   VDividebyZero    ds.l    1      storage for address of divide by zero handler
0B000018            9684   VCheck           ds.l    1      ditto
0B00001C            9685   VTrapV           ds.l    1      ditto
0B000020            9686   VPrivilege       ds.l    1      ditto
0B000024            9687   VTrace           ds.l    1
0B000028            9688   VLine1010emul    ds.l    1
0B00002C            9689   VLine1111emul    ds.l    1
0B000030            9690   VUnassigned1     ds.l    1
0B000034            9691   VUnassigned2     ds.l    1
0B000038            9692   VUnassigned3     ds.l    1
0B00003C            9693   VUninit_IRQ      ds.l    1
0B000040            9694   VUnassigned4     ds.l    1
0B000044            9695   VUnassigned5     ds.l    1
0B000048            9696   VUnassigned6     ds.l    1
0B00004C            9697   VUnassigned7     ds.l    1
0B000050            9698   VUnassigned8     ds.l    1
0B000054            9699   VUnassigned9     ds.l    1
0B000058            9700   VUnassigned10    ds.l    1
0B00005C            9701   VUnassigned11    ds.l    1
0B000060            9702   VSpuriousIRQ     ds.l    1
                    9703   
                    9704   * Interrupt handlers Vector 25-31
0B000064            9705   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000068            9706   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00006C            9707   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000070            9708   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000074            9709   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000078            9710   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00007C            9711   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    9712   
                    9713   * Trap Handler vectors 32-47
0B000080            9714   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000084            9715   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000088            9716   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00008C            9717   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000090            9718   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000094            9719   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000098            9720   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00009C            9721   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A0            9722   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A4            9723   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A8            9724   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000AC            9725   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B0            9726   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B4            9727   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B8            9728   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000BC            9729   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    9730   
                    9731   * the remaining exceptions are unassigned in the 68000 so no need to allocate storage for them here
                    9732   
                    9733   ***********************************************************************************************************
                    9734   * Other Variables
                    9735   ***********************************************************************************************************
                    9736   *__DebugA5       ds.l    1
                    9737   *__UserA5        ds.l    1
                    9738   
                    9739   ***********************************************************************************************************
0B0000C0            9740   __ungetbuf:     ds.l    1       ; ungetbuffer for stdio functions
0B0000C4            9741   __allocp:       ds.l    0       ; start of allocation units
0B0000C4            9742   __heap:         ds.l    0       ; pointers for malloc functions
                    9743   
                    9744   *__himem:       ds.l    himem            ; highest memory location + 1
                    9745   *__stklen:      ds.l    stklen           ; default stack size
                    9746   
                    9747   *********************************************************************************************************
                    9748   * Section for Heap
                    9749   *********************************************************************************************************
                    9750   
                    9751   _i:
0B0000C4            9752          ds.b      4
                    9753   _x:
0B0000C8            9754          ds.b      4
                    9755   _y:
0B0000CC            9756          ds.b      4
                    9757   _z:
0B0000D0            9758          ds.b      4
                    9759   _PortA_Count:
0B0000D4            9760          ds.b      4
                    9761   _Trace:
0B0000D8            9762          ds.b      4
                    9763   _GoFlag:
0B0000DC            9764          ds.b      4
                    9765   _Echo:
0B0000E0            9766          ds.b      4
                    9767   _d0:
0B0000E4            9768          ds.b      4
                    9769   _d1:
0B0000E8            9770          ds.b      4
                    9771   _d2:
0B0000EC            9772          ds.b      4
                    9773   _d3:
0B0000F0            9774          ds.b      4
                    9775   _d4:
0B0000F4            9776          ds.b      4
                    9777   _d5:
0B0000F8            9778          ds.b      4
                    9779   _d6:
0B0000FC            9780          ds.b      4
                    9781   _d7:
0B000100            9782          ds.b      4
                    9783   _a0:
0B000104            9784          ds.b      4
                    9785   _a1:
0B000108            9786          ds.b      4
                    9787   _a2:
0B00010C            9788          ds.b      4
                    9789   _a3:
0B000110            9790          ds.b      4
                    9791   _a4:
0B000114            9792          ds.b      4
                    9793   _a5:
0B000118            9794          ds.b      4
                    9795   _a6:
0B00011C            9796          ds.b      4
                    9797   _PC:
0B000120            9798          ds.b      4
                    9799   _SSP:
0B000124            9800          ds.b      4
                    9801   _USP:
0B000128            9802          ds.b      4
                    9803   _SR:
0B00012C            9804          ds.b      2
                    9805   _BreakPointAddress:
0B00012E            9806          ds.b      32
                    9807   _BreakPointInstruction:
0B00014E            9808          ds.b      16
                    9809   _BreakPointSetOrCleared:
0B00015E            9810          ds.b      32
                    9811   _InstructionSize:
0B00017E            9812          ds.b      4
                    9813   _WatchPointAddress:
0B000182            9814          ds.b      32
                    9815   _WatchPointSetOrCleared:
0B0001A2            9816          ds.b      32
                    9817   _WatchPointString:
0B0001C2            9818          ds.b      800
                    9819   _TempString:
0B0004E2            9820          ds.b      100
                    9821   _Timer1Count:
0B000546            9822          ds.b      1
                    9823          section   heap
0B000548            9824                   align
          0B00 0548 9825   bssEnd          equ *                   end of storage space for unitialised variables
                    9826   *                                       we have to copy all initialised variable from rom to here at startup
          0B00 0548 9827   heap   equ       *
0B000548            9828                    align
          0000 0000

Assembly errors: 0
